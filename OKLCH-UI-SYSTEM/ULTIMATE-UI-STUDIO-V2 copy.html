<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI-CONFIGPRO - Universal Selector Edition</title>

    <!-- Import Maps for OKLCH 3D -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
    }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Active color groups */
            --primary: oklch(0.60 0.18 270);
            --secondary: oklch(0.65 0.15 210);
            --accent: oklch(0.75 0.15 85);
            --background: oklch(0.98 0.01 270);
            --surface: oklch(1.00 0.00 270);
            --text: oklch(0.15 0.02 270);
            --text-secondary: oklch(0.45 0.02 270);
            --border: oklch(0.88 0.01 270);
            --success: oklch(0.65 0.18 145);
            --warning: oklch(0.70 0.18 70);
            --error: oklch(0.60 0.20 25);

            /* ========== CLEAN STANDARDIZED SCAFFOLD UI ========== */

            /* ELEVATION SYSTEM - 3 Clear Layers */
            --scaffold-bg-0: oklch(0.14 0.005 270);    /* Base layer (darkest) */
            --scaffold-bg-1: oklch(0.17 0.005 270);    /* Elevated layer (cards, buttons) */
            --scaffold-bg-2: oklch(0.20 0.005 270);    /* Highest layer (inputs, hovers) */

            /* BORDER SYSTEM - 2 States */
            --scaffold-border: oklch(0.24 0.005 270);         /* Default borders */
            --scaffold-border-interactive: oklch(0.32 0.005 270);  /* Hover/Focus borders */

            /* TEXT SYSTEM - 2 Levels (High Contrast) */
            --scaffold-text-primary: oklch(0.92 0.005 270);    /* Primary text (high contrast) */
            --scaffold-text-secondary: oklch(0.65 0.005 270);  /* Secondary text (labels, muted) */

            /* SPACING SCALE - Consistent Rhythm */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 24px;
            --space-6: 32px;
            --space-7: 48px;

            /* TYPOGRAPHY SCALE - Clear Hierarchy */
            --text-xs: 11px;    /* Labels, badges */
            --text-sm: 12px;    /* Secondary text */
            --text-base: 13px;  /* Base text */
            --text-md: 14px;    /* Primary text */
            --text-lg: 16px;    /* Emphasized */
            --text-xl: 20px;    /* Subheadings */
            --text-2xl: 24px;   /* Section titles */

            /* RADIUS SCALE - Consistent Rounding */
            --radius-sm: 3px;   /* Small elements */
            --radius-md: 6px;   /* Default */
            --radius-lg: 8px;   /* Cards */
            --radius-xl: 12px;  /* Large surfaces */

            /* LEGACY SUPPORT - Map old variables to new system */
            --scaffold-bg: var(--scaffold-bg-0);
            --scaffold-bg-elevated: var(--scaffold-bg-1);
            --scaffold-bg-input: var(--scaffold-bg-2);
            --scaffold-border-hover: var(--scaffold-border-interactive);
            --scaffold-text: var(--scaffold-text-primary);
            --scaffold-text-muted: var(--scaffold-text-secondary);
            --scaffold-text-dimmed: var(--scaffold-text-secondary);
        }

        /* LIGHT SCAFFOLD THEME (when color lightness > 0.5) */
        .studio.scaffold-light {
            /* ELEVATION SYSTEM - Inverted for Light Mode */
            --scaffold-bg-0: oklch(0.96 0.005 270);    /* Base layer (lightest) */
            --scaffold-bg-1: oklch(0.98 0.005 270);    /* Elevated layer */
            --scaffold-bg-2: oklch(1.00 0.005 270);    /* Highest layer (pure white) */

            /* BORDER SYSTEM - Darker in Light Mode */
            --scaffold-border: oklch(0.86 0.005 270);
            --scaffold-border-interactive: oklch(0.72 0.005 270);

            /* TEXT SYSTEM - Inverted */
            --scaffold-text-primary: oklch(0.15 0.005 270);    /* Dark text */
            --scaffold-text-secondary: oklch(0.48 0.005 270);  /* Gray text */

            /* Legacy support inherited automatically */

            /* Override body background via inheritance */
            background: oklch(0.94 0.005 270);
            color: oklch(0.15 0.005 270);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', sans-serif;
            background: var(--scaffold-bg-0);
            color: var(--scaffold-text-primary);
            overflow: hidden;
            touch-action: manipulation; /* Prevent double-tap zoom */
            font-size: var(--text-base);
            line-height: 1.5;
        }

        /* ========== UTILITY CLASSES - Standardized Component Patterns ========== */

        /* Text Utilities */
        .scaffold-text-primary { color: var(--scaffold-text-primary) !important; }
        .scaffold-text-secondary { color: var(--scaffold-text-secondary) !important; }
        .scaffold-text-xs { font-size: var(--text-xs) !important; }
        .scaffold-text-sm { font-size: var(--text-sm) !important; }
        .scaffold-text-base { font-size: var(--text-base) !important; }
        .scaffold-text-md { font-size: var(--text-md) !important; }
        .scaffold-text-lg { font-size: var(--text-lg) !important; }
        .scaffold-text-xl { font-size: var(--text-xl) !important; }
        .scaffold-text-2xl { font-size: var(--text-2xl) !important; }

        /* Background Utilities */
        .scaffold-bg-0 { background: var(--scaffold-bg-0) !important; }
        .scaffold-bg-1 { background: var(--scaffold-bg-1) !important; }
        .scaffold-bg-2 { background: var(--scaffold-bg-2) !important; }

        /* Border Utilities */
        .scaffold-border { border: 1px solid var(--scaffold-border) !important; }
        .scaffold-border-interactive { border-color: var(--scaffold-border-interactive) !important; }

        /* Spacing Utilities */
        .p-1 { padding: var(--space-1) !important; }
        .p-2 { padding: var(--space-2) !important; }
        .p-3 { padding: var(--space-3) !important; }
        .p-4 { padding: var(--space-4) !important; }
        .p-5 { padding: var(--space-5) !important; }
        .p-6 { padding: var(--space-6) !important; }
        .p-7 { padding: var(--space-7) !important; }

        .m-1 { margin: var(--space-1) !important; }
        .m-2 { margin: var(--space-2) !important; }
        .m-3 { margin: var(--space-3) !important; }
        .m-4 { margin: var(--space-4) !important; }
        .m-5 { margin: var(--space-5) !important; }
        .m-6 { margin: var(--space-6) !important; }
        .m-7 { margin: var(--space-7) !important; }

        .gap-1 { gap: var(--space-1) !important; }
        .gap-2 { gap: var(--space-2) !important; }
        .gap-3 { gap: var(--space-3) !important; }
        .gap-4 { gap: var(--space-4) !important; }

        /* Radius Utilities */
        .radius-sm { border-radius: var(--radius-sm) !important; }
        .radius-md { border-radius: var(--radius-md) !important; }
        .radius-lg { border-radius: var(--radius-lg) !important; }
        .radius-xl { border-radius: var(--radius-xl) !important; }

        /* ========== STANDARDIZED COMPONENT PATTERNS ========== */

        /* Section Header Pattern */
        .scaffold-section-header {
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            color: var(--scaffold-text-secondary);
            margin-bottom: var(--space-3);
        }

        /* Divider Pattern */
        .scaffold-divider {
            height: 1px;
            background: var(--scaffold-border);
            margin: var(--space-4) 0;
        }

        /* Card Pattern */
        .scaffold-card {
            background: var(--scaffold-bg-1);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            transition: all 150ms ease-out;
        }

        .scaffold-card:hover {
            border-color: var(--scaffold-border-interactive);
            background: var(--scaffold-bg-2);
        }

        /* Button Pattern - Primary */
        .scaffold-btn {
            padding: var(--space-2) var(--space-3);
            background: var(--scaffold-bg-1);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-sm);
            color: var(--scaffold-text-primary);
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
        }

        .scaffold-btn:hover {
            background: var(--scaffold-bg-2);
            border-color: var(--scaffold-border-interactive);
        }

        .scaffold-btn:active {
            transform: translateY(1px);
        }

        /* Input Pattern */
        .scaffold-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--scaffold-bg-2);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-sm);
            color: var(--scaffold-text-primary);
            font-size: var(--text-sm);
            font-family: inherit;
            transition: all 150ms ease-out;
        }

        .scaffold-input:hover {
            border-color: var(--scaffold-border-interactive);
        }

        .scaffold-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px oklch(from var(--primary) l c h / 0.2);
        }

        /* Select/Dropdown Pattern */
        .scaffold-select {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--scaffold-bg-2);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-sm);
            color: var(--scaffold-text-primary);
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all 150ms ease-out;
        }

        .scaffold-select:hover {
            border-color: var(--scaffold-border-interactive);
        }

        .scaffold-select:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Label Pattern */
        .scaffold-label {
            display: block;
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--scaffold-text-primary);
            margin-bottom: var(--space-1);
        }

        /* Badge Pattern */
        .scaffold-badge {
            display: inline-flex;
            align-items: center;
            padding: var(--space-1) var(--space-2);
            background: var(--scaffold-bg-1);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--scaffold-text-primary);
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        /* Code Block Pattern */
        .scaffold-code {
            padding: var(--space-2) var(--space-3);
            background: var(--scaffold-bg-0);
            border: 1px solid var(--scaffold-border);
            border-radius: var(--radius-sm);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: var(--text-xs);
            color: var(--scaffold-text-primary);
            overflow-x: auto;
        }

        /* Skip link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: oklch(0.65 0.18 270);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            font-weight: 600;
            z-index: 10000;
            border-radius: 0 0 4px 0;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--surface);
            border-left: 1px solid var(--scaffold-border);
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            transition: right 300ms ease-out;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-panel-header {
            padding: 24px;
            background: var(--scaffold-bg);
            border-bottom: 1px solid var(--scaffold-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .settings-panel-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--scaffold-text);
        }

        .settings-close-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid var(--scaffold-border);
            color: var(--scaffold-text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 200ms;
        }

        .settings-close-btn:hover {
            background: var(--scaffold-bg);
            border-color: var(--primary);
        }

        .settings-panel-body {
            padding: 24px;
            flex: 1;
        }

        .settings-section {
            margin-bottom: 32px;
        }

        .settings-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--scaffold-text);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: var(--scaffold-bg);
            border: 1px solid var(--scaffold-border);
            border-radius: 8px;
            margin-bottom: 12px;
            transition: border-color 200ms;
        }

        .settings-option:hover {
            border-color: var(--primary);
        }

        .settings-option-label {
            flex: 1;
        }

        .settings-option-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--scaffold-text);
            margin-bottom: 4px;
        }

        .settings-option-desc {
            font-size: 12px;
            color: var(--scaffold-text-muted);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: var(--scaffold-border);
            border-radius: 12px;
            cursor: pointer;
            transition: background 200ms;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-switch-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: left 200ms;
        }

        .toggle-switch.active .toggle-switch-knob {
            left: 26px;
        }

        /* Settings Overlay */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 300ms;
        }

        .settings-overlay.open {
            opacity: 1;
            pointer-events: all;
        }

        /* ========== 2-PANEL LAYOUT ========== */
        .studio {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .studio-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ========== TOP BAR - ULTRA MINIMAL WITH AUTO-THEME ========== */
        .top-bar {
            background: var(--scaffold-bg);
            flex-shrink: 0;
            border-bottom: 1px solid var(--scaffold-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            height: 44px;
            transition: background 300ms, border-color 300ms;
        }

        .studio-title {
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--scaffold-text);
            letter-spacing: 0.3px;
            transition: color 300ms;
        }

        .mode-toggle {
            display: flex;
            gap: 4px;
        }

        .mode-btn {
            padding: 4px 10px;
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
            color: var(--scaffold-text-muted);
            border-radius: 2px;
            cursor: pointer;
            font-weight: 500;
            font-size: 11px;
            transition: all 120ms;
        }

        .mode-btn:hover {
            background: var(--scaffold-bg-elevated);
            border-color: var(--scaffold-border-hover);
            color: var(--scaffold-text);
        }

        .mode-btn.active {
            background: var(--scaffold-bg-elevated);
            border-color: var(--scaffold-border-hover);
            color: var(--scaffold-text);
        }

        .action-btns {
            display: flex;
            gap: 4px;
        }

        .top-btn {
            padding: 4px 10px;
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
            border-radius: 2px;
            color: var(--scaffold-text);
            cursor: pointer;
            font-weight: 500;
            font-size: 11px;
            transition: all 120ms;
        }

        .top-btn:hover {
            background: var(--scaffold-bg-elevated);
            border-color: var(--scaffold-border-hover);
        }

        .top-btn-primary {
            background: var(--scaffold-bg-elevated);
            border-color: var(--scaffold-border-hover);
            color: var(--scaffold-text);
        }

        .top-btn-primary:hover {
            opacity: 0.9;
        }

        /* ========== LEFT SIDEBAR - ULTRA MINIMAL WITH AUTO-THEME ========== */
        .left-sidebar {
            background: var(--scaffold-bg);
            border-right: 1px solid var(--scaffold-border);
            overflow-y: auto;
            padding: 12px;
            position: relative;
            width: 320px;
            min-width: 260px;
            max-width: 600px;
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1), background 300ms, border-color 300ms;
            will-change: transform;
        }

        /* Sidebar collapsed state */
        .left-sidebar.collapsed {
            transform: translateX(calc(-100% + 48px));
        }

        /* Sidebar resize handle - MINIMAL WITH AUTO-THEME */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: var(--scaffold-border);
            cursor: ew-resize;
            z-index: 10;
            transition: background 120ms;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.resizing {
            background: var(--scaffold-border-hover);
        }

        /* Sidebar toggle button - MINIMAL WITH AUTO-THEME */
        .sidebar-toggle-btn {
            position: absolute;
            top: 50%;
            right: -20px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
            border-left: none;
            border-radius: 0 3px 3px 0;
            color: var(--scaffold-text-muted);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 120ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 5;
        }

        .sidebar-toggle-btn:hover {
            background: var(--scaffold-bg-elevated);
            color: var(--scaffold-text);
        }

        .sidebar-toggle-btn .toggle-icon {
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .left-sidebar.collapsed .sidebar-toggle-btn .toggle-icon {
            transform: rotate(180deg);
        }

        /* Responsive widget grid container - COMPACT */
        .widget-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 140px), 1fr));
            gap: 8px;
            margin-bottom: 8px;
        }

        .widget-grid-item {
            min-width: 140px;
        }

        /* CURRENT COLOR SPOTLIGHT - HIGH CONTRAST FOR VISIBILITY */
        .spotlight {
            background: oklch(0.10 0.01 270);
            border: 2px solid oklch(0.30 0.08 270);
            border-radius: 6px;
            padding: 14px;
            margin-bottom: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: border-color 300ms cubic-bezier(0.4, 0, 0.2, 1), background 300ms;
        }

        /* LIGHT SCAFFOLD: Lighter background with strong border */
        .studio.scaffold-light .spotlight {
            background: oklch(0.98 0.005 270);
            border: 2px solid oklch(0.70 0.05 270);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .spotlight-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }

        .spotlight-title {
            display: none; /* REMOVED */
        }

        .spotlight-group {
            font-size: 10px;
            padding: 4px 10px;
            /* USE SCAFFOLD THEME COLORS - ADAPTS TO LIGHT/DARK SCAFFOLD */
            background: var(--scaffold-text, oklch(0.95 0.0 270));
            color: var(--scaffold-bg, oklch(0.08 0.0 270));
            border-radius: 3px;
            font-weight: 700;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            border: 1px solid var(--scaffold-text, oklch(0.90 0.0 270));
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .color-line-container {
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .color-name-label {
            font-size: 14px;
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            letter-spacing: 0.5px;
            text-align: center;
            /* OKLCH CODE - USES SELECTED COLOR AS BG, AUTO-INVERTED TEXT FOR MAX CONTRAST */
            color: var(--oklch-code-text, oklch(0.0 0.0 0));
            background: var(--oklch-code-bg, oklch(1.0 0.0 0));
            padding: 12px 16px;
            display: block;
            margin: 10px 0;
            border-radius: 4px;
            border: 2px solid var(--oklch-code-border, oklch(0.15 0.0 0));
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .color-name-label:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }

        /* COLOR PALETTE ATOM MAP */
        .color-palette-map {
            margin: 16px 0;
            padding: 12px;
            background: var(--scaffold-bg-elevated, oklch(0.18 0.01 270));
            border-radius: 4px;
            border: 1px solid var(--scaffold-border, oklch(0.22 0.01 270));
        }

        .palette-header {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            color: var(--scaffold-text-dimmed, oklch(0.60 0.01 270));
            margin-bottom: 10px;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .palette-atom {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            min-height: 50px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            overflow: hidden;
        }

        .palette-atom:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .palette-atom:active {
            transform: scale(0.98);
        }

        .palette-atom-label {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            font-size: 7px;
            font-weight: 700;
            text-align: center;
            padding: 2px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 2px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        /* CENTRAL CONTROL PANEL */
        .palette-atom.selected-for-control {
            box-shadow: 0 0 0 3px oklch(0.60 0.18 145);
            transform: scale(1.1);
        }

        .central-param-btn {
            transition: all 200ms;
        }

        .central-param-btn:hover {
            background: var(--scaffold-bg-elevated) !important;
            border-color: var(--scaffold-border-hover) !important;
        }

        .central-param-btn.active {
            background: oklch(0.45 0.18 145) !important;
            border-color: oklch(0.45 0.18 145) !important;
            color: white !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* HUE SPIN ANIMATION */
        @keyframes hue-spin-highlight {
            0% {
                filter: hue-rotate(0deg);
                box-shadow: 0 0 0 3px currentColor;
            }
            50% {
                filter: hue-rotate(180deg);
                box-shadow: 0 0 0 6px currentColor;
            }
            100% {
                filter: hue-rotate(360deg);
                box-shadow: 0 0 0 3px currentColor;
            }
        }

        .component-highlight {
            animation: hue-spin-highlight 250ms ease-in-out;
        }

        .color-line-wrapper {
            display: flex;
            align-items: center;
            gap: 0;
            margin-top: 8px;
        }

        .color-line {
            flex: 1;
            height: 4px;
            border-radius: 2px 0 0 2px;
            transition: all 200ms;
        }

        .color-line-container:hover .color-line {
            height: 6px;
        }

        .color-copy-circle {
            width: 26px;
            height: 26px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border: 2px solid oklch(0.40 0.08 270);
            background: oklch(0.25 0.02 270);
            color: oklch(0.90 0.01 270);
            transition: all 120ms;
            flex-shrink: 0;
        }

        .color-line-container:hover .color-copy-circle {
            background: oklch(0.35 0.05 270);
            border-color: oklch(0.50 0.12 270);
            color: oklch(1.0 0.0 270);
            transform: scale(1.05);
        }

        /* LIGHT SCAFFOLD: Adjust for light theme */
        .studio.scaffold-light .color-copy-circle {
            border: 2px solid oklch(0.60 0.05 270);
            background: oklch(0.85 0.01 270);
            color: oklch(0.20 0.01 270);
        }

        .studio.scaffold-light .color-line-container:hover .color-copy-circle {
            background: oklch(0.75 0.03 270);
            border-color: oklch(0.50 0.08 270);
            color: oklch(0.10 0.0 270);
        }

        .copy-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: oklch(0.12 0.01 270);
            color: oklch(1.0 0.0 270);
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            border: 2px solid oklch(0.35 0.08 270);
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            white-space: nowrap;
            transition: opacity 150ms;
        }

        .copy-feedback.show {
            opacity: 1;
        }

        .copy-feedback-name {
            font-size: 11px;
            font-weight: 500;
            color: oklch(0.75 0.02 270);
            margin-top: 4px;
            text-align: center;
        }

        /* LIGHT SCAFFOLD: High contrast feedback */
        .studio.scaffold-light .copy-feedback {
            background: oklch(0.95 0.01 270);
            color: oklch(0.08 0.0 270);
            border: 2px solid oklch(0.65 0.05 270);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }

        .studio.scaffold-light .copy-feedback-name {
            color: oklch(0.45 0.02 270);
        }

        /* LIGHT SCAFFOLD: Safe Zone Cards */
        .studio.scaffold-light .safe-zone-card {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
        }

        .studio.scaffold-light .safe-zone-card.safe {
            background: oklch(0.95 0.05 145);
            border-color: oklch(0.75 0.15 145);
        }

        .studio.scaffold-light .safe-zone-card.warning {
            background: oklch(0.95 0.05 70);
            border-color: oklch(0.75 0.15 70);
        }

        .studio.scaffold-light .safe-zone-card.danger {
            background: oklch(0.95 0.05 25);
            border-color: oklch(0.75 0.15 25);
        }

        /* LIGHT SCAFFOLD: Fix Buttons */
        .studio.scaffold-light .fix-btn {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border-hover);
            color: var(--scaffold-text);
        }

        .studio.scaffold-light .fix-btn:hover {
            background: var(--scaffold-bg-input);
            border-color: var(--primary);
        }

        .studio.scaffold-light .fix-btn:active {
            background: var(--scaffold-bg-elevated);
        }

        .studio.scaffold-light .fix-btn.animating {
            background: var(--scaffold-bg-input);
            border-color: var(--primary);
            color: var(--scaffold-text);
        }

        /* LIGHT SCAFFOLD: Code Snippets */
        .studio.scaffold-light .code-snippet {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
        }

        .studio.scaffold-light .code-snippet-header {
            background: var(--scaffold-bg);
            border-bottom: 1px solid var(--scaffold-border);
        }

        .studio.scaffold-light .copy-code-btn {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border-hover);
            color: var(--scaffold-text);
        }

        .studio.scaffold-light .copy-code-btn:hover {
            background: var(--scaffold-bg-input);
            border-color: var(--primary);
        }

        /* LIGHT SCAFFOLD: Scrollbar */
        .studio.scaffold-light ::-webkit-scrollbar-track {
            background: var(--scaffold-bg-elevated);
        }

        .studio.scaffold-light ::-webkit-scrollbar-thumb {
            background: var(--scaffold-border-hover);
        }

        /* LIGHT SCAFFOLD: Input Range Sliders */
        .studio.scaffold-light input[type="range"] {
            background: var(--scaffold-bg-input);
        }

        /* HOTSPOT PREVIEW CARDS */
        .hotspot-preview-card {
            padding: 8px;
            background: var(--scaffold-bg-elevated);
            border-radius: 6px;
            border: 1px solid var(--scaffold-border);
            cursor: pointer;
            transition: all 200ms;
        }

        .hotspot-preview-card:hover {
            border-color: var(--scaffold-border-hover);
            background: var(--scaffold-bg-input);
        }

        .hotspot-preview-card.active {
            border: 2px solid oklch(0.45 0.18 145);
        }

        .hotspot-preview-card-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--scaffold-text);
        }

        /* SECTIONS - ULTRA MINIMAL WITH AUTO-THEME */
        .section {
            margin-bottom: 16px;
        }

        .section-title {
            /* Standardized section header pattern */
            font-size: var(--text-xs);
            font-weight: 600;
            margin-bottom: var(--space-2);
            color: var(--scaffold-text-secondary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: color 150ms ease-out;
        }

        /* OKLCH SLIDERS - COMPACT */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .slider-label {
            font-size: 10px;
            font-weight: 600;
            width: 12px;
            color: var(--scaffold-text-muted);
            transition: color 300ms;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: oklch(0.22 0.01 270);
            outline: none;
            -webkit-appearance: none;
            touch-action: none; /* Prevent zoom on touch */
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: oklch(0.75 0.01 270);
            cursor: pointer;
            border: 1px solid oklch(0.28 0.01 270);
        }

        .slider-value {
            font-size: 10px;
            font-family: 'SF Mono', monospace;
            width: 40px;
            text-align: right;
            color: var(--scaffold-text-muted);
            transition: color 300ms;
        }

        /* 2D PICKERS - MINIMAL */
        .picker-canvas {
            display: block;
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            border-radius: 3px;
            border: 1px solid oklch(0.24 0.01 270);
            margin-bottom: 8px;
            cursor: crosshair;
            transition: width 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 3D VIEWER - MINIMAL */
        #oklch-3d-viewer {
            width: 100%;
            height: 0;
            padding-bottom: 65%; /* Aspect ratio: ~1.5:1 responsive height */
            position: relative;
            border-radius: 3px;
            border: 1px solid oklch(0.24 0.01 270);
            margin-bottom: 8px;
            transition: padding-bottom 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        #oklch-3d-viewer canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        /* COMPONENT GROUPS - MINIMAL */
        .color-group-card {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 120ms;
        }

        .color-group-card:hover {
            border-color: var(--scaffold-border-hover);
            background: var(--scaffold-bg-input);
        }

        .color-group-card.active {
            border-color: var(--scaffold-border-hover);
            background: var(--scaffold-bg-input);
        }

        .group-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .group-name {
            font-weight: 500;
            font-size: 11px;
            color: oklch(0.75 0.01 270);
        }

        .group-preview {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            border: 1px solid oklch(0.24 0.01 270);
        }

        .group-components {
            font-size: 9px;
            color: oklch(0.60 0.01 270);
        }

        /* SAFE ZONE - MINIMAL */
        .safe-zone-card {
            background: oklch(0.18 0.01 270);
            border: 1px solid oklch(0.24 0.01 270);
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .safe-zone-card.safe {
            border-color: oklch(0.40 0.05 145);
            background: oklch(0.18 0.01 145);
        }

        .safe-zone-card.warning {
            border-color: oklch(0.40 0.05 70);
            background: oklch(0.18 0.01 70);
        }

        .safe-zone-card.danger {
            border-color: oklch(0.40 0.05 25);
            background: oklch(0.18 0.01 25);
        }

        .fix-buttons-container {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid oklch(0.22 0.01 270);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .fix-btn {
            padding: 6px 10px;
            background: oklch(0.20 0.01 270);
            border: 1px solid oklch(0.28 0.01 270);
            border-radius: 2px;
            color: oklch(0.75 0.01 270);
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 120ms;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .fix-btn:hover {
            background: oklch(0.23 0.01 270);
            border-color: oklch(0.32 0.01 270);
        }

        .fix-btn:active {
            background: oklch(0.25 0.01 270);
        }

        .fix-btn.animating {
            background: oklch(0.28 0.01 270);
            border-color: oklch(0.32 0.01 270);
            color: oklch(0.85 0.01 270);
            cursor: wait;
        }

        .fix-btn.animating::after {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ========== CENTER GALLERY ========== */
        .center-gallery {
            background: var(--scaffold-bg);
            overflow-y: auto;
            padding: 48px;
            flex: 1;
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        .gallery-header {
            text-align: center;
            margin-bottom: 12px; /* Reduced from 48px (25%) */
        }

        .gallery-title {
            font-size: 24px; /* Reduced from 36px */
            font-weight: 700;
            color: var(--scaffold-text);
            margin-bottom: 4px; /* Reduced from 12px */
        }

        .gallery-subtitle {
            font-size: 14px; /* Reduced from 18px */
            color: var(--scaffold-text-muted);
        }

        .selector-hint {
            background: oklch(0.60 0.18 270 / 0.15);
            border: 1px solid oklch(0.60 0.18 270);
            border-radius: 8px;
            padding: 8px 12px; /* Reduced from 16px */
            margin-bottom: 12px; /* Reduced from 32px */
            text-align: center;
            color: var(--scaffold-text);
            font-size: 13px; /* Added smaller font */
        }

        .component-section {
            margin-bottom: 64px;
        }

        .section-header {
            /* Standardized major heading */
            font-size: var(--text-2xl);
            font-weight: 700;
            color: var(--scaffold-text-primary);
            margin-bottom: var(--space-5);
            padding-bottom: var(--space-3);
            border-bottom: 2px solid var(--scaffold-border);
        }

        /* SELECTABLE COMPONENTS */
        .selectable {
            cursor: pointer !important;
            position: relative;
            transition: all 150ms;
        }

        .selectable:hover::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 2px dashed oklch(0.60 0.18 270);
            border-radius: 8px;
            pointer-events: none;
        }

        .selectable.selected {
            outline: 3px solid oklch(0.60 0.18 270);
            outline-offset: 2px;
        }

        /* Multi-select mode for shape editing */
        .selectable.universal-selected,
        .selectable.shape-selected { /* Backwards compatibility */
            outline: 3px dashed oklch(0.55 0.18 145) !important;
            outline-offset: 2px;
            position: relative;
            z-index: 99;
        }

        .selectable.universal-selected::before,
        .selectable.shape-selected::before { /* Backwards compatibility */
            content: '✓';
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: oklch(0.55 0.18 145);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 100;
        }

        /* Button Components */
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid transparent;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 250ms;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 8px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: oklch(from var(--primary) calc(l + 0.1) c h);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px oklch(from var(--primary) l c h / 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border-color: var(--primary);
            color: var(--primary);
        }

        /* FIXED: Disabled button with proper contrast */
        .btn:disabled,
        .btn[disabled],
        button:disabled,
        button[disabled] {
            background: oklch(0.35 0.01 270);
            color: oklch(0.75 0.01 270);  /* FIXED: Increased from 0.60 to 0.75 for 3:1+ contrast */
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* UI Commandments Styles */
        .commandment-category {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border);
            border-radius: 6px;
            overflow: hidden;
        }

        .commandment-header {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--scaffold-bg);
            border: none;
            color: var(--scaffold-text);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 150ms ease;
            text-align: left;
        }

        .commandment-header:hover {
            background: var(--scaffold-bg-hover);
        }

        .commandment-content {
            overflow: hidden;
            transition: max-height 300ms cubic-bezier(0.4, 0, 0.2, 1), opacity 200ms ease;
            padding: 0 12px;
        }

        .commandment-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            padding: 0 12px;
        }

        .commandment-rule {
            padding: 8px 0;
            font-size: 11px;
            line-height: 1.5;
            color: var(--scaffold-text);
            border-bottom: 1px solid var(--scaffold-border);
        }

        .commandment-rule:last-child {
            border-bottom: none;
            padding-bottom: 12px;
        }

        .commandment-rule:first-child {
            padding-top: 12px;
        }

        .commandment-rule strong {
            color: var(--scaffold-text);
            font-weight: 600;
        }

        /* Input Components */
        .input {
            width: 100%;
            max-width: 400px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--scaffold-border);
            border-radius: 8px;
            color: var(--text);  /* FIXED: Use text color for proper contrast against surface */
            font-size: 16px;
            margin-bottom: 12px;
            transition: all 250ms;
        }

        /* FIXED: Placeholder text with proper contrast */
        .input::placeholder {
            color: var(--text);
            opacity: 0.5;  /* Make placeholder lighter but still readable (50% opacity) */
        }

        .input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px oklch(from var(--primary) l c h / 0.2);
        }

        /* Card Components */
        .card {
            background: var(--surface);
            border: 1px solid var(--scaffold-border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px oklch(0.15 0 0 / 0.1);
            transition: all 250ms;
        }

        .card:hover {
            box-shadow: 0 4px 6px oklch(0.15 0 0 / 0.1);
            transform: translateY(-2px);
        }

        /* Badge Components */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 500;
            margin: 4px;
        }

        .badge-primary {
            background: oklch(from var(--primary) l c h / 0.2);
            color: var(--primary);
        }

        .badge-accent {
            background: oklch(from var(--accent) l c h / 0.2);
            color: var(--accent);
        }

        /* Alert Components */
        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .alert-success {
            background: oklch(from var(--success) l c h / 0.15);
            border: 1px solid var(--success);
            color: var(--success);
        }

        /* Navigation */
        .nav {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: var(--surface);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .nav-item {
            padding: 8px 16px;
            border-radius: 6px;
            color: var(--scaffold-text-muted);
            cursor: pointer;
            transition: all 150ms;
        }

        .nav-item.active {
            background: var(--primary);
            color: white;
        }

        /* Code Snippets */
        .code-snippet {
            background: oklch(0.10 0.01 270);
            border: 1px solid oklch(0.25 0.01 270);
            border-radius: 8px;
            margin-top: 16px;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: oklch(0.12 0.01 270);
            border-bottom: 1px solid oklch(0.25 0.01 270);
        }

        .code-header span {
            font-size: 12px;
            font-weight: 600;
            color: oklch(0.70 0.01 270);
        }

        .copy-code-btn {
            padding: 4px 12px;
            background: oklch(0.20 0.01 270);
            border: 1px solid oklch(0.28 0.01 270);
            border-radius: 4px;
            color: oklch(0.85 0.01 270);
            cursor: pointer;
            font-size: 12px;
            transition: all 150ms;
        }

        .copy-code-btn:hover {
            background: oklch(0.25 0.01 270);
            border-color: oklch(0.60 0.18 270);
        }

        .code-content {
            padding: 16px;
            margin: 0;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: oklch(0.85 0.01 270);
            overflow-x: auto;
        }

        .code-content code {
            font-family: inherit;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--scaffold-text);
            font-size: 14px;
        }

        .checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            margin: 12px 0;
        }

        .checkbox input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Mockup Page */
        .mockup-page {
            display: none;
        }

        .mockup-page.active {
            display: block;
        }

        .mockup-tab {
            transition: all 150ms;
        }

        .mockup-tab.active {
            background: oklch(0.60 0.18 270);
            border-color: oklch(0.60 0.18 270);
            color: white;
        }

        /* Scrollbar - MINIMAL */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: oklch(0.18 0.01 270);
        }

        ::-webkit-scrollbar-thumb {
            background: oklch(0.28 0.01 270);
            border-radius: 2px;
        }

        /* ========== MOBILE RESPONSIVE ========== */
        @media (max-width: 768px) {
            /* Single column layout - stack sidebar on top */
            .studio {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                height: auto;
                min-height: 100vh;
            }

            /* Top bar adjustments */
            .top-bar {
                flex-direction: column;
                padding: 12px 16px;
                gap: 12px;
                height: auto;
            }

            .studio-title {
                font-size: 16px;
            }

            .mode-toggle {
                width: 100%;
                justify-content: center;
            }

            .action-btns {
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
            }

            /* Minimum 48px tap targets for all buttons */
            .top-btn,
            .mode-btn,
            button {
                min-height: 48px;
                min-width: 48px;
                padding: 12px 16px;
                font-size: 14px;
            }

            /* Sidebar full width on mobile */
            .left-sidebar {
                width: 100% !important;
                max-width: 100%;
                height: auto;
                max-height: none;
                position: relative;
                border-right: none;
                border-bottom: 1px solid oklch(0.25 0.01 270);
                transform: none !important;
            }

            /* Hide resize handle and toggle button on mobile */
            .sidebar-resize-handle,
            .sidebar-toggle-btn {
                display: none;
            }

            /* Gallery full width */
            .gallery {
                padding: 16px;
                overflow-y: auto;
                height: auto;
            }

            /* Responsive font sizes */
            body {
                font-size: 16px;
            }

            .section-title {
                font-size: 14px;
            }

            .slider-label {
                font-size: 14px;
                min-width: 48px;
            }

            .slider-value {
                font-size: 14px;
                min-width: 60px;
            }

            /* Larger slider handles for touch */
            input[type="range"] {
                height: 48px;
            }

            input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            input[type="range"]::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            /* Stack color group cards vertically */
            .color-group-card {
                min-height: 48px;
                padding: 12px;
            }

            /* Larger tap targets for checkboxes */
            input[type="checkbox"] {
                width: 24px;
                height: 24px;
                min-width: 24px;
                min-height: 24px;
            }

            /* Prevent horizontal scroll */
            .gallery,
            .left-sidebar,
            .studio {
                overflow-x: hidden;
            }

            /* Component gallery adjustments */
            .component {
                padding: 16px;
            }

            .btn {
                min-height: 48px;
                padding: 12px 20px;
                font-size: 16px;
            }

            /* Form inputs larger */
            input[type="text"],
            input[type="email"],
            select,
            textarea {
                min-height: 48px;
                font-size: 16px;
                padding: 12px;
            }

            /* Spotlight adjustments */
            .spotlight {
                padding: 16px;
            }

            /* Color line larger for touch */
            .color-line {
                height: 48px;
            }

            .color-copy-circle {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            /* Widget mode button larger */
            #toggle-widget-mode {
                min-height: 48px;
                padding: 12px 16px;
            }

            /* Canvas pickers larger */
            .picker-canvas {
                width: 150px !important;
                height: 150px !important;
            }

            /* Hide 3D viewer on mobile to save space */
            #oklch-3d-viewer {
                display: none;
            }

            /* Mockup tabs wrap on mobile */
            .mockup-tabs {
                flex-wrap: wrap;
            }

            .mockup-tab {
                min-height: 48px;
                padding: 12px 16px;
            }

            /* Last saved indicator wraps */
            #last-saved-indicator {
                width: 100%;
                text-align: center;
                margin-top: 8px;
            }
        }

        /* Extra small devices */
        @media (max-width: 480px) {
            .studio-title {
                font-size: 14px;
            }

            .action-btns {
                gap: 4px;
            }

            .top-btn {
                padding: 10px 12px;
                font-size: 12px;
            }

            .section {
                padding: 12px;
            }

            .color-line-container {
                font-size: 12px;
            }
        }

        /* ========== SCAFFOLD-AWARE UTILITY CLASSES ========== */

        /* Modal Components */
        .modal-base {
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            background: var(--scaffold-bg-input);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 6px;
            color: var(--scaffold-text);
            font-size: 14px;
            font-family: inherit;
        }

        .modal-option {
            padding: 14px 16px;
            margin-bottom: 8px;
            background: var(--scaffold-bg-input);
            border: 2px solid var(--scaffold-border-hover);
            border-radius: 8px;
            color: var(--scaffold-text);
            cursor: pointer;
            transition: all 200ms;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-option:hover {
            background: var(--scaffold-bg-elevated);
            border-color: var(--primary);
        }

        /* Widget Components */
        .widget-header {
            padding: 8px 12px;
            margin-top: 8px;
            background: var(--scaffold-bg);
            border-bottom: 1px solid var(--scaffold-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .widget-toggle-btn {
            padding: 4px 8px;
            background: var(--scaffold-bg-input);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 2px;
            color: var(--scaffold-text-muted);
            font-size: 9px;
            font-weight: 500;
            cursor: pointer;
            transition: all 120ms;
        }

        .widget-toggle-btn:hover {
            background: var(--scaffold-bg-elevated);
            color: var(--scaffold-text);
        }

        /* Mode Selector Buttons */
        .mode-selector-btn {
            padding: 10px 8px;
            background: var(--scaffold-bg-input);
            border: 2px solid var(--scaffold-border-hover);
            border-radius: 6px;
            color: var(--scaffold-text);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 200ms;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .mode-selector-btn:hover {
            background: var(--scaffold-bg-elevated);
            border-color: var(--primary);
        }

        .mode-selector-btn.active {
            border-color: var(--primary);
            background: var(--scaffold-bg-elevated);
        }

        /* Input Elements */
        .scaffold-input {
            width: 100%;
            padding: 8px;
            background: var(--scaffold-bg-input);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 6px;
            color: var(--scaffold-text);
            font-size: 12px;
            cursor: pointer;
        }

        .scaffold-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .scaffold-input-small {
            width: 50px;
            padding: 4px;
            background: var(--scaffold-bg-input);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 4px;
            color: var(--scaffold-text);
            font-size: 11px;
        }

        /* Select Elements */
        .scaffold-select {
            width: 100%;
            padding: 8px;
            background: var(--scaffold-bg-input);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 6px;
            color: var(--scaffold-text);
            font-size: 12px;
            cursor: pointer;
        }

        .scaffold-select:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Action Buttons */
        .action-btn {
            flex: 1;
            padding: 10px;
            background: var(--scaffold-bg-elevated);
            border: 1px solid var(--scaffold-border-hover);
            border-radius: 6px;
            color: var(--scaffold-text-muted);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 200ms;
        }

        .action-btn:hover {
            background: var(--scaffold-bg-input);
            color: var(--scaffold-text);
        }

        /* Info Containers */
        .info-container {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--scaffold-bg);
            border-radius: 8px;
            border: 1px solid var(--scaffold-border-hover);
        }

        .info-container-elevated {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--scaffold-bg-elevated);
            border-radius: 8px;
            border: 1px solid var(--scaffold-border-hover);
        }

        .info-container-highlight {
            display: none;
            margin-bottom: 12px;
            padding: 12px;
            background: var(--scaffold-bg-elevated);
            border-left: 3px solid var(--primary);
            border-radius: 4px;
            font-size: 13px;
            color: var(--scaffold-text-muted);
        }

        /* Hotspot Labels */
        .hotspot-label {
            font-size: 9px;
            color: var(--scaffold-text-muted);
            background: var(--scaffold-bg-input);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Modal Structure */
        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--scaffold-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--scaffold-text);
        }

        .modal-close-btn {
            background: transparent;
            border: none;
            color: var(--scaffold-text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 200ms;
        }

        .modal-close-btn:hover {
            color: var(--scaffold-text);
            background: var(--scaffold-bg-input);
        }

        .modal-body {
            padding: 24px;
            color: var(--scaffold-text);
            font-size: 14px;
            line-height: 1.6;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--scaffold-border);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Label Styles */
        .scaffold-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--scaffold-text-muted);
            cursor: pointer;
            margin-bottom: 8px;
        }

        .scaffold-label-small {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--scaffold-text-muted);
            cursor: pointer;
        }

        .scaffold-label-tiny {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: var(--scaffold-text-muted);
            cursor: pointer;
        }

        .scaffold-label-block {
            font-size: 11px;
            color: var(--scaffold-text-muted);
            display: block;
            margin-bottom: 4px;
        }

        .scaffold-label-block-bold {
            font-size: 11px;
            color: var(--scaffold-text-muted);
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .scaffold-text-muted-12 {
            /* Standardized secondary text */
            font-size: var(--text-sm);
            color: var(--scaffold-text-secondary);
            margin-bottom: var(--space-3);
            line-height: 1.5;
        }

        .scaffold-text-heading {
            font-size: 11px;
            font-weight: 600;
            color: var(--scaffold-text-muted);
            margin-bottom: 10px;
        }

        .scaffold-text-separator {
            font-size: 10px;
            color: var(--scaffold-text-muted);
        }
    </style>
</head>
<body>
    <!-- Skip to main content link -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- ARIA Live Region for screen reader announcements -->
    <div id="sr-announcer" role="status" aria-live="polite" aria-atomic="true" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;"></div>

    <!-- Settings Panel Overlay -->
    <div class="settings-overlay" id="settings-overlay" onclick="toggleSettingsPanel()"></div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-panel-header">
            <div class="settings-panel-title">⚙️ Settings</div>
            <button class="settings-close-btn" onclick="toggleSettingsPanel()">✕</button>
        </div>

        <div class="settings-panel-body">
            <!-- Accessibility Section -->
            <div class="settings-section">
                <div class="settings-section-title">Accessibility</div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Enforce WCAG 2.2 AA</div>
                        <div class="settings-option-desc">Require 4.5:1 contrast for text, 3:1 for UI</div>
                    </div>
                    <div class="toggle-switch" id="toggle-wcag" onclick="toggleSetting('wcag')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Enforce APCA</div>
                        <div class="settings-option-desc">Use perceptual contrast algorithm</div>
                    </div>
                    <div class="toggle-switch" id="toggle-apca" onclick="toggleSetting('apca')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Maximum Readability</div>
                        <div class="settings-option-desc">Prioritize text clarity over aesthetics</div>
                    </div>
                    <div class="toggle-switch" id="toggle-readability" onclick="toggleSetting('readability')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>
            </div>

            <!-- Auto-Save Section -->
            <div class="settings-section">
                <div class="settings-section-title">Persistence</div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Auto-Save</div>
                        <div class="settings-option-desc">Automatically save changes to localStorage</div>
                    </div>
                    <div class="toggle-switch active" id="toggle-autosave" onclick="toggleSetting('autosave')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Auto-Update URL</div>
                        <div class="settings-option-desc">Update browser URL with palette changes</div>
                    </div>
                    <div class="toggle-switch active" id="toggle-url-update" onclick="toggleSetting('urlUpdate')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>
            </div>

            <!-- UI Preferences Section -->
            <div class="settings-section">
                <div class="settings-section-title">Interface</div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Default Mode</div>
                        <div class="settings-option-desc">Starting theme mode</div>
                    </div>
                    <select id="default-mode-select" style="padding: 8px 12px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer; font-size: 13px;">
                        <option value="light">☀️ Light</option>
                        <option value="dark">🌙 Dark</option>
                    </select>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Animation Speed</div>
                        <div class="settings-option-desc">Transition duration multiplier</div>
                    </div>
                    <select id="animation-speed-select" style="padding: 8px 12px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer; font-size: 13px;">
                        <option value="0.5">Fast (0.5x)</option>
                        <option value="1" selected>Normal (1x)</option>
                        <option value="1.5">Slow (1.5x)</option>
                        <option value="0">Off</option>
                    </select>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Default Export Format</div>
                        <div class="settings-option-desc">Preferred export format</div>
                    </div>
                    <select id="export-format-select" style="padding: 8px 12px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer; font-size: 13px;">
                        <option value="1" selected>CSS Variables</option>
                        <option value="2">SCSS Variables</option>
                        <option value="3">Tailwind Config</option>
                        <option value="4">JSON</option>
                        <option value="5">HEX Palette</option>
                        <option value="6">TypeScript</option>
                    </select>
                </div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Show 3D Viewer</div>
                        <div class="settings-option-desc">Display OKLCH color space visualization</div>
                    </div>
                    <div class="toggle-switch active" id="toggle-3d-viewer" onclick="toggleSetting('3dViewer')">
                        <div class="toggle-switch-knob"></div>
                    </div>
                </div>
            </div>

            <!-- Data Management Section -->
            <div class="settings-section">
                <div class="settings-section-title">Data Management</div>

                <div class="settings-option">
                    <div class="settings-option-label">
                        <div class="settings-option-name">Export & Refresh</div>
                        <div class="settings-option-desc">Download complete state snapshot and reload page</div>
                    </div>
                </div>

                <button onclick="exportAllDataAndRefresh()" style="width: 100%; padding: 16px; background: oklch(0.35 0.18 270); border: 1px solid oklch(0.45 0.18 270); border-radius: 8px; color: oklch(0.98 0.01 270); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                    💾 Export All & Refresh
                </button>

                <div style="margin-top: 8px; padding: 8px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 6px; font-size: 11px; color: var(--scaffold-text-muted); line-height: 1.4;">
                    ℹ️ Downloads complete UI state (both palettes, settings, history) as timestamped JSON, then refreshes the page
                </div>
            </div>

            <!-- Reset Section -->
            <div class="settings-section">
                <div class="settings-section-title">Reset</div>

                <button onclick="resetSettings()" style="width: 100%; padding: 16px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 8px; color: var(--scaffold-text); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                    Reset All Settings
                </button>

                <button onclick="clearPalette()" style="width: 100%; padding: 16px; margin-top: 12px; background: oklch(0.40 0.08 0); border: 1px solid oklch(0.50 0.08 0); border-radius: 8px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                    Clear Saved Palette
                </button>
            </div>
        </div>
    </div>

    <!-- CUSTOM MODAL SYSTEM (Studio Scaffold Neutral Colors) -->
    <div id="custom-modal-overlay" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100000; align-items: center; justify-content: center;">
        <div id="custom-modal" class="modal-base" style="min-width: 400px; max-width: 600px; padding: 0; animation: modalSlideIn 200ms ease-out;">
            <!-- Modal Header -->
            <div id="modal-header" class="modal-header">
                <div id="modal-title" class="modal-title"></div>
                <button onclick="closeCustomModal()" class="modal-close-btn">✕</button>
            </div>

            <!-- Modal Body -->
            <div id="modal-body" class="modal-body">
            </div>

            <!-- Modal Footer -->
            <div id="modal-footer" class="modal-footer">
            </div>
        </div>
    </div>

    <style>
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
    </style>

    <div class="studio">
        <!-- TOP BAR -->
        <div class="top-bar">
            <div class="studio-title">
                UI-CONFIGPRO
            </div>

            <div class="mode-toggle">
                <button class="mode-btn" id="auto-theme-toggle" data-mode="auto">
                    <span id="theme-icon">◐</span> Auto
                </button>
                <button class="mode-btn" id="scaffold-theme-toggle" data-mode="light" style="margin-left: 8px;">
                    <span id="scaffold-icon">☀️</span> Scaffold
                </button>
            </div>

            <div class="action-btns">
                <button class="top-btn" onclick="loadBlueprint()">Load</button>
                <button class="top-btn" onclick="saveBlueprint()">Save</button>
                <button class="top-btn" onclick="exportTheme()">Export</button>
                <button class="top-btn" onclick="sharePalette()">Share</button>
                <button class="top-btn" onclick="toggleSettingsPanel()">Settings</button>
                <button class="top-btn" id="add-to-scaffold-btn">Add to Scaffold</button>
                <button class="top-btn" id="reset-scaffold-btn" style="display: none;">Reset</button>
                <button class="top-btn" id="random-palette-btn">Random</button>
                <button class="top-btn" id="validate-btn" style="background: oklch(0.45 0.18 230);">🔍 Validate</button>
                <button class="top-btn" id="registry-btn" style="background: oklch(0.45 0.18 280);">📊 Registry</button>
                <button class="top-btn top-btn-primary" onclick="applyToEcosystem()">Apply to Ecosystem</button>
                <span id="last-saved-indicator" style="font-size: 11px; color: oklch(0.60 0.01 270); margin-left: 12px; opacity: 0.5; font-family: monospace;">Not saved</span>
            </div>
        </div>

        <!-- STUDIO BODY (SIDEBAR + GALLERY) -->
        <div class="studio-body">
            <!-- LEFT SIDEBAR (ALL CONTROLS) -->
            <div class="left-sidebar">
            <!-- Sidebar resize handle -->
            <div class="sidebar-resize-handle"></div>

            <!-- Sidebar toggle button -->
            <button class="sidebar-toggle-btn" onclick="toggleSidebar()" aria-label="Toggle sidebar">
                <span class="toggle-icon">◀</span>
            </button>

            <!-- CURRENT COLOR SPOTLIGHT - MINIMAL -->
            <div class="spotlight">
                <div class="spotlight-header">
                    <div class="spotlight-group" id="current-group">PRIMARY</div>
                </div>

                <!-- OKLCH Code Display (clickable to copy) -->
                <div class="color-line-container" id="color-line-container">
                    <div class="color-name-label" id="color-name-label">oklch(0.60 0.18 270)</div>
                </div>

                <!-- COLOR PALETTE ATOM MAP - Click to navigate -->
                <div class="color-palette-map">
                    <div class="palette-header">COLOR PALETTE</div>
                    <div class="palette-grid" id="palette-grid">
                        <!-- Dynamically populated with color atoms -->
                    </div>
                </div>

                <!-- 🎯 3D OKLCH SLICE VISUALIZER - Interactive Color Space Explorer -->
                <div style="margin: 16px 0; padding: 16px; background: var(--scaffold-bg-elevated); border: 1px solid var(--scaffold-border); border-radius: 8px;">
                    <div style="font-size: 10px; font-weight: 600; color: var(--scaffold-text-muted); letter-spacing: 0.5px; text-transform: uppercase; margin-bottom: 12px; text-align: center;">
                        🎯 3D OKLCH Slice Explorer
                    </div>

                    <!-- 3D Visualization Container -->
                    <div id="oklch-3d-slice-viewer" style="width: 100%; height: 200px; background: var(--scaffold-bg); border-radius: 6px; border: 1px solid var(--scaffold-border); position: relative; overflow: hidden;">
                        <!-- Three.js canvas will be inserted here -->
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--scaffold-text-muted); font-size: 11px; pointer-events: none;">
                            <div style="margin-bottom: 8px;">Select L, C, or H below</div>
                            <div style="font-size: 9px; opacity: 0.7;">Drag slider to explore color slice</div>
                        </div>
                    </div>

                    <!-- Slice Info Display -->
                    <div style="margin-top: 8px; padding: 8px; background: var(--scaffold-bg); border-radius: 4px; border: 1px solid var(--scaffold-border);">
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 10px;">
                            <span style="color: var(--scaffold-text-muted);">Current Slice:</span>
                            <span id="current-slice-info" style="font-weight: 600; color: var(--scaffold-text);">L = 0.60 (Lightness)</span>
                        </div>
                        <div style="margin-top: 4px; font-size: 9px; color: var(--scaffold-text-muted); font-style: italic;">
                            💡 Slice at 100% opacity • Rest at 50% transparency
                        </div>
                    </div>
                </div>

                <div class="color-palette-map">
                    <!-- CENTRAL SLIDE CONTROL PANEL -->
                    <div style="margin-top: 12px; padding: 12px; background: var(--scaffold-bg-elevated); border: 1px solid var(--scaffold-border); border-radius: 8px;">
                        <!-- Selected Color Indicator -->
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <div id="central-control-color-preview" style="width: 24px; height: 24px; border-radius: 4px; border: 1px solid var(--scaffold-border);"></div>
                            <div style="flex: 1;">
                                <div id="central-control-color-name" style="font-size: 11px; font-weight: 600; color: var(--scaffold-text);">PRIMARY</div>
                                <div id="central-control-color-value" style="font-size: 9px; color: var(--scaffold-text-muted);">oklch(0.60 0.18 270)</div>
                            </div>
                        </div>

                        <!-- Parameter Selector (REVOLVER) -->
                        <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                            <button class="central-param-btn active" data-param="l" style="flex: 1; padding: 6px; background: var(--scaffold-bg-input); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; font-weight: 600; color: var(--scaffold-text); cursor: pointer; transition: all 200ms;">L</button>
                            <button class="central-param-btn" data-param="c" style="flex: 1; padding: 6px; background: var(--scaffold-bg-input); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; font-weight: 600; color: var(--scaffold-text); cursor: pointer; transition: all 200ms;">C</button>
                            <button class="central-param-btn" data-param="h" style="flex: 1; padding: 6px; background: var(--scaffold-bg-input); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; font-weight: 600; color: var(--scaffold-text); cursor: pointer; transition: all 200ms;">H</button>
                        </div>

                        <!-- Master Slider -->
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="range" id="central-master-slider" min="0" max="100" value="60" step="1" style="flex: 1; cursor: pointer;" aria-label="Central master slider">
                            <span id="central-slider-value" style="font-size: 11px; font-weight: 600; color: var(--scaffold-text); min-width: 40px; text-align: right;">0.60</span>
                        </div>

                        <!-- Counter-Weight Indicator -->
                        <div style="margin-top: 8px; font-size: 9px; color: var(--scaffold-text-muted); text-align: center;">
                            <span id="counter-weight-status">⚖️ Counter-Weight: Balanced</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- WIDGET CUSTOMIZATION HEADER - MINIMAL -->
            <div class="widget-header">
                <div style="font-size: 9px; font-weight: 600; color: var(--scaffold-text-muted); letter-spacing: 0.5px; text-transform: uppercase;">Sidebar Widgets</div>
                <button id="toggle-widget-mode" class="widget-toggle-btn">
                    Customize
                </button>
            </div>

            <!-- OKLCH SLIDERS -->
            <div class="section" data-widget-id="oklch-sliders">
                <div class="section-title">OKLCH Controls</div>
                <div class="slider-row">
                    <span class="slider-label">L</span>
                    <input type="range" id="current-l" min="0" max="100" value="60" step="1" aria-label="Lightness from 0 to 100 percent">
                    <span class="slider-value" id="current-l-val">0.60</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label">C</span>
                    <input type="range" id="current-c" min="0" max="37" value="18" step="1" aria-label="Chroma from 0 to 37">
                    <span class="slider-value" id="current-c-val">0.18</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label">H</span>
                    <input type="range" id="current-h" min="0" max="360" value="270" step="1" aria-label="Hue from 0 to 360 degrees">
                    <span class="slider-value" id="current-h-val">270</span>
                </div>
            </div>

            <!-- 3D VISUALIZATIONS (RESPONSIVE GRID) -->
            <div class="widget-grid-container" style="grid-template-columns: repeat(auto-fit, minmax(min(100%, 180px), 1fr));">
                <!-- 3D OKLCH VIEWER -->
                <div class="section widget-grid-item" data-widget-id="3d-viewer" style="grid-column: 1 / -1;">
                    <div class="section-title">3D Color Space</div>
                    <div id="oklch-3d-viewer"></div>
                </div>

                <!-- HUE WHEEL -->
                <div class="section widget-grid-item" data-widget-id="hue-wheel">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div class="section-title" style="margin-bottom: 0;">Hue Wheel</div>
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="toggle-hue-wheel" checked style="cursor: pointer;">
                            <span>Show</span>
                        </label>
                    </div>
                    <div id="hue-wheel-container" style="display: flex; justify-content: center;">
                        <canvas id="hue-wheel" class="picker-canvas"></canvas>
                    </div>
                </div>

                <!-- CHROMA × LIGHTNESS -->
                <div class="section widget-grid-item" data-widget-id="chroma-lightness">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div class="section-title" style="margin-bottom: 0;">Chroma × Lightness</div>
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="toggle-chroma-lightness" checked style="cursor: pointer;">
                            <span>Show</span>
                        </label>
                    </div>
                    <div id="chroma-lightness-container" style="display: flex; justify-content: center;">
                        <canvas id="chroma-lightness" class="picker-canvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- COLOR GROUPS -->
            <div class="section" data-widget-id="color-groups">
                <div class="section-title">Color Groups</div>

                <!-- LIVING EXAMPLE: Primary Button -->
                <div class="color-group-card active" data-group="primary">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <button class="btn btn-primary" style="pointer-events: none; width: 100%; cursor: pointer;">Primary Button</button>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Brand, CTA, Links</div>
                    </div>
                </div>

                <!-- LIVING EXAMPLE: Secondary Button -->
                <div class="color-group-card" data-group="secondary">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <button class="btn btn-secondary" style="pointer-events: none; width: 100%; cursor: pointer;">Secondary</button>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Buttons, Headers</div>
                    </div>
                </div>

                <!-- LIVING EXAMPLE: Accent Badge -->
                <div class="color-group-card" data-group="accent">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <span class="badge badge-accent" style="pointer-events: none; cursor: pointer; font-size: 13px; padding: 6px 16px;">Accent Badge</span>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Badges, Highlights</div>
                    </div>
                </div>

                <!-- LIVING EXAMPLE: Background Preview -->
                <div class="color-group-card" data-group="background">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <div style="width: 100%; height: 40px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 6px; position: relative; overflow: hidden; cursor: pointer;">
                            <!-- Checkerboard pattern for visibility -->
                            <div style="position: absolute; inset: 0; background-image: linear-gradient(45deg, transparent 48%, var(--scaffold-text-muted) 48%, var(--scaffold-text-muted) 52%, transparent 52%), linear-gradient(-45deg, transparent 48%, var(--scaffold-text-muted) 48%, var(--scaffold-text-muted) 52%, transparent 52%); background-size: 8px 8px; opacity: 0.03; pointer-events: none;"></div>
                            <div style="position: absolute; inset: 0; background: var(--scaffold-bg);"></div>
                        </div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Page Background</div>
                    </div>
                </div>

                <!-- LIVING EXAMPLE: Surface Card -->
                <div class="color-group-card" data-group="surface">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <div class="card" style="width: 100%; padding: 12px; cursor: pointer; min-height: 40px; display: flex; align-items: center; justify-content: center;">
                            <span style="font-size: 12px; font-weight: 500; color: var(--scaffold-text);">Surface Card</span>
                        </div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Cards, Inputs, Panels</div>
                    </div>
                </div>

                <!-- LIVING EXAMPLE: Text Sample -->
                <div class="color-group-card" data-group="text">
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <div style="width: 100%; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                            <span style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); line-height: 1;">Abc</span>
                        </div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center;">Body Text, Headings</div>
                    </div>
                </div>
            </div>

            <!-- UNIVERSAL SELECTION SYSTEM (Multi-Mode Multi-Select) -->
            <div class="section" data-widget-id="shape-sliders">
                <div class="section-title">Selection Controls</div>
                <div class="scaffold-text-muted-12">
                    Select multiple components and apply color, shape, typography, layout, or custom group operations
                </div>

                <!-- Mode Selector -->
                <div style="margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
                        <button class="mode-selector-btn" data-mode="color" onclick="setSelectionMode('color')">
                            <span style="font-size: 18px;">🎨</span>
                            <span>Color</span>
                        </button>
                        <button class="mode-selector-btn" data-mode="shape" onclick="setSelectionMode('shape')">
                            <span style="font-size: 18px;">📐</span>
                            <span>Shape</span>
                        </button>
                        <button class="mode-selector-btn" data-mode="typography" onclick="setSelectionMode('typography')">
                            <span style="font-size: 18px;">✍️</span>
                            <span>Typography</span>
                        </button>
                        <button class="mode-selector-btn" data-mode="layout" onclick="setSelectionMode('layout')">
                            <span style="font-size: 18px;">📦</span>
                            <span>Layout</span>
                        </button>
                        <button class="mode-selector-btn" data-mode="custom" onclick="setSelectionMode('custom')">
                            <span style="font-size: 18px;">🏷️</span>
                            <span>Custom</span>
                        </button>
                        <button class="mode-selector-btn" data-mode="null" style="border-color: oklch(0.55 0.18 145);" onclick="setSelectionMode(null)">
                            <span style="font-size: 18px;">❌</span>
                            <span>Disable</span>
                        </button>
                    </div>
                </div>

                <!-- Selection Count Display -->
                <div id="shape-selection-count" class="info-container-highlight">
                    <strong style="color: oklch(0.55 0.18 145);">0</strong> components selected
                </div>

                <!-- SHAPE PROPERTIES -->
                <div id="shape-controls" style="display: none;">
                    <div class="slider-row">
                        <span class="slider-label">🔘 Border Radius</span>
                        <input type="range" id="shape-border-radius" min="0" max="50" value="8" step="1" aria-label="Border radius" disabled>
                        <span class="slider-value" id="shape-border-radius-val">8px</span>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">📦 Padding</span>
                        <input type="range" id="shape-padding" min="0" max="100" value="12" step="1" aria-label="Padding" disabled>
                        <span class="slider-value" id="shape-padding-val">12px</span>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">↔️ Margin</span>
                        <input type="range" id="shape-margin" min="0" max="100" value="0" step="1" aria-label="Margin" disabled>
                        <span class="slider-value" id="shape-margin-val">0px</span>
                    </div>
                </div>

                <!-- TYPOGRAPHY PROPERTIES -->
                <div id="typography-controls" style="display: none;">
                    <div class="slider-row">
                        <span class="slider-label">📏 Font Size</span>
                        <input type="range" id="typography-fontSize" min="8" max="72" value="14" step="1" aria-label="Font size" disabled>
                        <span class="slider-value" id="typography-fontSize-val">14px</span>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">💪 Font Weight</span>
                        <input type="range" id="typography-fontWeight" min="100" max="900" value="400" step="100" aria-label="Font weight" disabled>
                        <span class="slider-value" id="typography-fontWeight-val">400</span>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">📐 Line Height</span>
                        <input type="range" id="typography-lineHeight" min="1.0" max="3.0" value="1.5" step="0.1" aria-label="Line height" disabled>
                        <span class="slider-value" id="typography-lineHeight-val">1.5</span>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">↔️ Letter Spacing</span>
                        <input type="range" id="typography-letterSpacing" min="-2" max="10" value="0" step="0.5" aria-label="Letter spacing" disabled>
                        <span class="slider-value" id="typography-letterSpacing-val">0px</span>
                    </div>
                </div>

                <!-- LAYOUT PROPERTIES -->
                <div id="layout-controls" style="display: none;">
                    <div style="margin-bottom: 12px;">
                        <label class="scaffold-label-block">📊 Display</label>
                        <select id="layout-display" class="scaffold-select" disabled>
                            <option value="block">Block</option>
                            <option value="inline-block">Inline Block</option>
                            <option value="flex">Flex</option>
                            <option value="grid">Grid</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label class="scaffold-label-block">➡️ Flex Direction</label>
                        <select id="layout-flexDirection" class="scaffold-select" disabled>
                            <option value="row">Row</option>
                            <option value="column">Column</option>
                        </select>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">📏 Gap</span>
                        <input type="range" id="layout-gap" min="0" max="100" value="12" step="1" aria-label="Gap" disabled>
                        <span class="slider-value" id="layout-gap-val">12px</span>
                    </div>
                </div>

                <!-- CUSTOM GROUP PROPERTIES -->
                <div id="custom-controls" style="display: none;">
                    <div style="margin-bottom: 12px;">
                        <label class="scaffold-label-block">🏷️ Group Name</label>
                        <input type="text" id="custom-group-name" placeholder="e.g., hero-buttons" class="scaffold-input">
                    </div>
                    <button onclick="saveCustomGroup()" style="width: 100%; padding: 10px; background: oklch(0.55 0.18 145); border: none; border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer;">
                        💾 Save Custom Group
                    </button>
                </div>

                <!-- Action Buttons -->
                <div id="selection-actions" style="display: none; margin-top: 12px;">
                    <div style="display: flex; gap: 8px;">
                        <button onclick="clearSelection()"
                                class="action-btn">
                            Clear Selection
                        </button>
                        <button onclick="resetStyles()"
                                class="action-btn">
                            Reset Styles
                        </button>
                    </div>
                </div>
            </div>

            <!-- COLOR HARMONY DISTRIBUTIONS -->
            <div class="section" data-widget-id="color-harmony">
                <div class="section-title">Color Harmony</div>
                <div class="scaffold-text-muted-12">
                    Apply classical color theory to your palette
                </div>

                <div style="margin-bottom: 12px;">
                    <label class="scaffold-label-block">
                        Harmony Type
                    </label>
                    <select id="harmony-type" class="scaffold-select">
                        <option value="monochromatic">🎯 Monochromatic (Same hue)</option>
                        <option value="complementary">🔄 Complementary (180°)</option>
                        <option value="analogous">📐 Analogous (±30°)</option>
                        <option value="triadic">🔺 Triadic (120° splits)</option>
                        <option value="tetradic">⬜ Tetradic/Square (90° splits)</option>
                        <option value="split-complementary">✂️ Split-Complementary (180° ± 30°)</option>
                    </select>
                </div>

                <button id="apply-harmony-btn" style="width: 100%; padding: 10px; background: oklch(0.60 0.18 270); border: 1px solid oklch(0.70 0.18 270); border-radius: 6px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                    ✨ Apply Harmony to Palette
                </button>

                <div id="harmony-preview" class="info-container-elevated" style="margin-top: 12px; padding: 8px; display: none;">
                    <div style="font-size: 10px; font-weight: 600; color: oklch(0.55 0.01 270); margin-bottom: 6px;">PREVIEW:</div>
                    <div id="harmony-colors" style="display: flex; gap: 4px; flex-wrap: wrap;"></div>
                </div>
            </div>

            <!-- RANDOM BEAUTIFUL UI GENERATOR -->
            <div class="section" data-widget-id="random-beautiful-ui">
                <div class="section-title">Random Beautiful UI</div>
                <div class="scaffold-text-muted-12">
                    Explore curated UI hotspots - perfectly aligned color combinations
                </div>

                <!-- Exploration Mode Slider -->
                <div style="margin-bottom: 16px;">
                    <label class="scaffold-label-block-bold">
                        🎯 Exploration Mode
                    </label>
                    <div style="display: flex; justify-content: space-between; font-size: 9px; color: oklch(0.50 0.01 270); margin-bottom: 4px;">
                        <span>Conservative</span>
                        <span>Adventurous</span>
                    </div>
                    <input type="range" id="exploration-mode" min="0" max="100" value="50" style="width: 100%; cursor: pointer;" aria-label="Exploration mode from 0 conservative to 100 adventurous">
                    <div style="font-size: 10px; color: oklch(0.55 0.01 270); margin-top: 4px; text-align: center;">
                        <span id="exploration-mode-label">Balanced</span> (<span id="exploration-mode-val">50</span>% adventure)
                    </div>
                </div>

                <!-- Hotspot Configuration -->
                <div class="info-container">
                    <div class="scaffold-text-heading">
                        🎨 Hotspot Filters
                    </div>

                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 10px; color: oklch(0.60 0.01 270); display: block; margin-bottom: 4px;">Harmony Weight</label>
                        <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                            <label class="scaffold-label-tiny">
                                <input type="checkbox" class="harmony-weight" value="monochromatic" checked style="cursor: pointer;">
                                <span>Mono</span>
                            </label>
                            <label class="scaffold-label-tiny">
                                <input type="checkbox" class="harmony-weight" value="complementary" checked style="cursor: pointer;">
                                <span>Compl</span>
                            </label>
                            <label class="scaffold-label-tiny">
                                <input type="checkbox" class="harmony-weight" value="analogous" checked style="cursor: pointer;">
                                <span>Analog</span>
                            </label>
                            <label class="scaffold-label-tiny">
                                <input type="checkbox" class="harmony-weight" value="triadic" checked style="cursor: pointer;">
                                <span>Triad</span>
                            </label>
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 10px; color: oklch(0.60 0.01 270); display: block; margin-bottom: 4px;">Lightness Range</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="number" id="lightness-min" min="0" max="100" value="20" class="scaffold-input-small">
                            <span class="scaffold-text-separator">to</span>
                            <input type="number" id="lightness-max" min="0" max="100" value="90" class="scaffold-input-small">
                            <span class="scaffold-text-separator">%</span>
                        </div>
                    </div>

                    <div>
                        <label style="font-size: 10px; color: oklch(0.60 0.01 270); display: block; margin-bottom: 4px;">Chroma Range</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="number" id="chroma-min" min="0" max="37" value="5" class="scaffold-input-small">
                            <span class="scaffold-text-separator">to</span>
                            <input type="number" id="chroma-max" min="0" max="37" value="25" class="scaffold-input-small">
                            <span class="scaffold-text-separator">%</span>
                        </div>
                    </div>
                </div>

                <!-- Hotspot Preview -->
                <div class="info-container-elevated">
                    <div class="scaffold-text-heading">
                        👁️ Next Hotspots
                    </div>
                    <div id="hotspot-preview" style="display: flex; gap: 8px; flex-direction: column;">
                        <!-- Hotspot previews will be injected here -->
                    </div>
                </div>

                <!-- Navigation Controls -->
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button id="prev-hotspot-btn" style="flex: 1; padding: 10px; background: oklch(0.35 0.01 270); border: 1px solid oklch(0.45 0.01 270); border-radius: 6px; color: oklch(0.70 0.01 270); font-size: 12px; font-weight: 600; cursor: pointer;">
                        ← Prev
                    </button>
                    <button id="jump-hotspot-btn" style="flex: 2; padding: 10px; background: oklch(0.45 0.18 145); border: 1px solid oklch(0.55 0.18 145); border-radius: 6px; color: white; font-size: 13px; font-weight: 600; cursor: pointer;">
                        🎲 Jump to Hotspot
                    </button>
                    <button id="next-hotspot-btn" style="flex: 1; padding: 10px; background: oklch(0.35 0.01 270); border: 1px solid oklch(0.45 0.01 270); border-radius: 6px; color: oklch(0.70 0.01 270); font-size: 12px; font-weight: 600; cursor: pointer;">
                        Next →
                    </button>
                </div>

                <div style="font-size: 9px; color: oklch(0.50 0.01 270); text-align: center; line-height: 1.4;">
                    Current Hotspot: <span id="current-hotspot-name" style="color: oklch(0.70 0.01 270); font-weight: 600;">None</span>
                </div>
            </div>

            <!-- TEMPLATE LIBRARY -->
            <div class="section" data-widget-id="template-library">
                <div class="section-title">Template Library</div>
                <div class="scaffold-text-muted-12">
                    Load pre-configured themes with customizable layers
                </div>

                <!-- Template Selection -->
                <div style="margin-bottom: 16px;">
                    <label class="scaffold-label-block-bold">
                        Select Template
                    </label>
                    <select id="template-selector" class="scaffold-select" style="padding: 10px; font-size: 13px; font-weight: 500;">
                        <option value="">-- Choose a template --</option>
                        <option value="corporate-blue">🏢 Corporate Blue</option>
                        <option value="nature-green">🌿 Nature Green</option>
                        <option value="sunset-orange">🌅 Sunset Orange</option>
                        <option value="ocean-teal">🌊 Ocean Teal</option>
                        <option value="purple-premium">💎 Purple Premium</option>
                        <option value="minimal-mono">⚫ Minimal Monochrome</option>
                    </select>
                </div>

                <!-- Template Preview -->
                <div id="template-preview" class="info-container-elevated" style="display: none;">
                    <div style="font-size: 10px; font-weight: 600; color: oklch(0.55 0.01 270); margin-bottom: 8px;">PREVIEW:</div>
                    <div id="template-colors" style="display: flex; gap: 4px; margin-bottom: 12px;">
                        <!-- Color swatches will be injected here -->
                    </div>
                    <div id="template-description" style="font-size: 11px; color: oklch(0.60 0.01 270); line-height: 1.4;">
                        <!-- Template description -->
                    </div>
                </div>

                <!-- Configuration Layers -->
                <div id="template-layers" class="info-container" style="display: none;">
                    <div class="scaffold-text-heading">
                        📋 Configuration Layers
                    </div>
                    <div style="font-size: 10px; color: oklch(0.55 0.01 270); margin-bottom: 12px; line-height: 1.4;">
                        Select which layers to import
                    </div>

                    <div class="template-layer-option">
                        <label class="scaffold-label">
                            <input type="checkbox" class="layer-checkbox" data-layer="colors" checked style="cursor: pointer;">
                            <span>🎨 Color Palette (6 colors)</span>
                        </label>
                    </div>

                    <div class="template-layer-option">
                        <label class="scaffold-label">
                            <input type="checkbox" class="layer-checkbox" data-layer="counterweight" checked style="cursor: pointer;">
                            <span>⚖️ Counter-Weight Rules</span>
                        </label>
                    </div>

                    <div class="template-layer-option">
                        <label class="scaffold-label">
                            <input type="checkbox" class="layer-checkbox" data-layer="compliance" checked style="cursor: pointer;">
                            <span>✅ Compliance Settings (WCAG/APCA)</span>
                        </label>
                    </div>

                    <div class="template-layer-option">
                        <label class="scaffold-label">
                            <input type="checkbox" class="layer-checkbox" data-layer="harmony" style="cursor: pointer;">
                            <span>🎨 Harmony Preference</span>
                        </label>
                    </div>

                    <div class="template-layer-option">
                        <label class="scaffold-label">
                            <input type="checkbox" class="layer-checkbox" data-layer="animation" style="cursor: pointer;">
                            <span>⚡ Animation Settings</span>
                        </label>
                    </div>
                </div>

                <!-- Import Button -->
                <button id="import-template-btn" disabled style="width: 100%; padding: 12px; background: oklch(0.35 0.01 270); border: 1px solid oklch(0.45 0.01 270); border-radius: 8px; color: oklch(0.75 0.01 270); font-size: 14px; font-weight: 600; cursor: not-allowed; transition: all 200ms;">
                    📥 Import to Current UI
                </button>
            </div>

            <!-- TRANSFORMATION TEMPLATES -->
            <div class="section" data-widget-id="counter-weight">
                <div class="section-title">Counter-Weight System</div>
                <div class="scaffold-text-muted-12">
                    Color transformation templates for light/dark mode switching
                </div>

                <!-- Template Selector -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 8px; color: oklch(0.70 0.01 270);">
                        Active Template
                    </label>
                    <select id="transformation-template" class="scaffold-select" style="padding: 8px 12px; font-size: 14px;">
                        <option value="standard">Standard Inversion</option>
                        <option value="perceptual">Perceptual Balance</option>
                        <option value="high-contrast">High Contrast (WCAG AAA)</option>
                        <option value="muted-dark">Muted Dark Mode</option>
                        <option value="vibrant-dark">Vibrant Dark Mode</option>
                    </select>
                </div>

                <!-- Template Configuration -->
                <div id="template-config" style="margin-top: 16px;">
                    <!-- Configuration options appear here based on selected template -->
                    <div class="config-option">
                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: oklch(0.60 0.01 270);">
                            Lightness Adjustment
                        </label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="range" id="template-lightness-adjust" min="-20" max="20" value="0" step="1" style="flex: 1;" aria-label="Lightness adjustment from minus 20 to plus 20 percent">
                            <span id="template-lightness-val" style="font-size: 11px; font-family: monospace; color: oklch(0.70 0.01 270); min-width: 40px;">0%</span>
                        </div>
                    </div>

                    <div class="config-option" style="margin-top: 12px;">
                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: oklch(0.60 0.01 270);">
                            Chroma Adjustment
                        </label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="range" id="template-chroma-adjust" min="-30" max="30" value="0" step="1" style="flex: 1;" aria-label="Chroma adjustment from minus 30 to plus 30 percent">
                            <span id="template-chroma-val" style="font-size: 11px; font-family: monospace; color: oklch(0.70 0.01 270); min-width: 40px;">0%</span>
                        </div>
                    </div>

                    <div class="config-option" style="margin-top: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: oklch(0.70 0.01 270); cursor: pointer;">
                            <input type="checkbox" id="template-maintain-contrast" checked style="cursor: pointer;">
                            Maintain WCAG Contrast
                        </label>
                    </div>
                </div>

                <!-- Animation Timing Controls -->
                <div class="info-container-elevated" style="margin-top: 16px;">
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 12px; color: oklch(0.70 0.01 270);">
                        ⚡ Animation Settings
                    </div>

                    <div style="margin-bottom: 12px;">
                        <label class="scaffold-label-block">
                            Duration (ms)
                        </label>
                        <input type="range" id="animation-duration" min="200" max="2000" value="800" step="100"
                               style="width: 100%; cursor: pointer;" aria-label="Animation duration from 200 to 2000 milliseconds">
                        <div style="font-size: 10px; color: oklch(0.55 0.01 270); margin-top: 2px;">
                            <span id="animation-duration-val">800</span>ms
                        </div>
                    </div>

                    <div class="config-option">
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="constant-speed-mode" style="cursor: pointer;">
                            Constant Speed (vs. Constant Time)
                        </label>
                        <div style="font-size: 9px; color: oklch(0.50 0.01 270); margin-top: 4px; margin-left: 20px;">
                            Speed adapts duration based on color distance
                        </div>
                    </div>
                </div>

                <!-- Compliance Toggles -->
                <div class="info-container-elevated" style="margin-top: 16px;">
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 12px; color: oklch(0.70 0.01 270);">
                        🔒 Accessibility Rules
                    </div>

                    <div class="config-option" style="margin-bottom: 8px;">
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="allow-wcag-violation" style="cursor: pointer;">
                            Allow WCAG 2.2 Violation
                        </label>
                    </div>

                    <div class="config-option" style="margin-bottom: 8px;">
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="allow-apca-violation" style="cursor: pointer;">
                            Allow APCA Violation
                        </label>
                    </div>

                    <div class="config-option" style="margin-bottom: 8px;">
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="ensure-max-readability" checked style="cursor: pointer;">
                            Always Ensure Max Readability
                        </label>
                    </div>

                    <div class="config-option">
                        <label class="scaffold-label-small">
                            <input type="checkbox" id="enforce-brightness-consistency" checked style="cursor: pointer;">
                            Enforce Brightness Consistency (±20%)
                        </label>
                        <div style="font-size: 9px; color: oklch(0.50 0.01 270); margin-top: 4px; margin-left: 24px;">
                            Component colors stay within ±20% of theme brightness
                        </div>
                    </div>
                </div>

                <!-- Auto-Sync Indicator -->
                <div class="info-container-elevated" style="margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 12px; font-weight: 600; color: oklch(0.70 0.01 270);">🔄 Auto-Sync Status</span>
                        <span id="auto-sync-status" style="font-size: 10px; padding: 3px 8px; background: oklch(0.45 0.18 145); color: white; border-radius: 4px; font-weight: 600;">ACTIVE</span>
                    </div>
                    <div style="font-size: 11px; color: oklch(0.55 0.01 270); line-height: 1.5;">
                        Both modes coexist - editing any color automatically generates opposite mode equivalent
                    </div>
                </div>

                <!-- Current Mode Indicator -->
                <div class="info-container-elevated" style="margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 12px; color: oklch(0.60 0.01 270);">Current Mode:</span>
                        <span id="current-mode-indicator" style="font-size: 13px; font-weight: 600; color: oklch(0.80 0.01 270);">☀️ Light</span>
                    </div>
                </div>
            </div>

            <!-- SAFE ZONE -->
            <div class="section" data-widget-id="compliance">
                <div class="section-title">WCAG Compliance</div>
                <div class="safe-zone-card safe" id="safe-zone">
                    <div style="font-weight: 600; margin-bottom: 8px;">✓ All Safe</div>
                    <div style="font-size: 12px; line-height: 1.6;" id="safe-zone-details">
                        <div>Text contrast: 12.3:1</div>
                        <div>Button contrast: 7.8:1</div>
                    </div>
                </div>
            </div>

            <!-- 📜 UI COMMANDMENTS - Universal Design Rules -->
            <div class="section" data-widget-id="ui-commandments">
                <div class="section-title">📜 UI Commandments</div>
                <p style="font-size: 11px; color: var(--scaffold-text-muted); margin-bottom: 12px; line-height: 1.4;">
                    Universal design rules for weights, counter-weights, and always great-looking UI
                </p>

                <!-- Expandable Categories -->
                <div style="display: flex; flex-direction: column; gap: 8px;">

                    <!-- 0. GOLDEN CONSTRAINTS OF UI BEAUTY (ENFORCED AUTOMATICALLY) -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">✨ Golden Constraints (Auto-Enforced)</span>
                            <span style="opacity: 0.6; font-size: 10px;">6 formula sets</span>
                        </button>
                        <div class="commandment-content" style="max-height: 2000px;">
                            <div class="commandment-rule"><strong>📐 FORMULA SET 1: Contrast Preservation</strong><br>Text vs Background MUST maintain ≥4.5:1 contrast (WCAG AA). System auto-adjusts lightness to preserve readability when background changes.</div>

                            <div class="commandment-rule"><strong>🏔️ FORMULA SET 2: Surface Lightness Coherence</strong><br>
                            • Light mode: Surfaces MUST be L ∈ [0.85, 1.0] (high lightness only)<br>
                            • Dark mode: Surfaces MUST be L ∈ [0.0, 0.20] (low lightness only)<br>
                            • <strong>FORBIDDEN:</strong> Mid-lightness surfaces (0.3-0.7) look muddy and ugly</div>

                            <div class="commandment-rule"><strong>🎨 FORMULA SET 3: Background Safe Zone</strong><br>
                            Backgrounds MUST be: <strong>Low Chroma (C ≤ 0.02) + (Very Light L≥0.9 OR Very Dark L≤0.15)</strong><br>
                            • Light mode background: L ∈ [0.9, 1.0], C ≤ 0.02<br>
                            • Dark mode background: L ∈ [0.0, 0.15], C ≤ 0.02<br>
                            • Avoids mid-lightness (looks unprofessional)</div>

                            <div class="commandment-rule"><strong>🔘 FORMULA SET 4: Discrete Button Colors</strong><br>
                            Buttons MUST be subtle, not garish:<br>
                            • Maximum chroma: C ≤ 0.15 (VERY DISCRETE)<br>
                            • Minimum contrast: 3:1 vs background<br>
                            • <strong>AVOID:</strong> Strong saturated colors on 2D surfaces (looks cheap)</div>

                            <div class="commandment-rule"><strong>🚫 FORMULA SET 5: Forbidden Zones</strong><br>
                            <strong>FORBIDDEN:</strong> Mid-Lightness (0.3-0.7) + High-Chroma (&gt;0.15) = UGLY!<br>
                            • ✅ ALLOWED: High-L + High-C (light accent)<br>
                            • ✅ ALLOWED: Low-L + High-C (dark accent)<br>
                            • ✅ ALLOWED: Mid-L + Low-C (neutral surface)<br>
                            • 🚫 FORBIDDEN: Mid-L + High-C (cheap looking)</div>

                            <div class="commandment-rule"><strong>📊 FORMULA SET 6: Chroma Hierarchy by Layer</strong><br>
                            Professional chroma limits (automatically enforced):<br>
                            • Background: C ≤ 0.02 (nearly neutral)<br>
                            • Surface: C ≤ 0.03 (very subtle)<br>
                            • Text: C ≤ 0.02 (neutral for readability)<br>
                            • Buttons: C ≤ 0.15 (discrete, not loud)<br>
                            • Accent: C ≤ 0.20 (maximum saturation, rare use)</div>
                        </div>
                    </div>

                    <!-- 1. COUNTER-WEIGHT SYSTEM (42D Hyper-Space) -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">⚖️ Counter-Weight System (42D Hyper-Space)</span>
                            <span style="opacity: 0.6; font-size: 10px;">7 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Trajectory Formulas</strong>: All color transformations MUST use trajectory-based formulas, NOT naive inversion</div>
                            <div class="commandment-rule">2. <strong>Bidirectional Sync</strong>: Light mode ↔ Dark mode transformations preserve perceptual relationships</div>
                            <div class="commandment-rule">3. <strong>Mathematical Coherence</strong>: 42-dimensional hyper-space maintains harmony across all color-component pairs</div>
                            <div class="commandment-rule">4. <strong>Influence Graph</strong>: Each pair influences related pairs through topology edges</div>
                            <div class="commandment-rule">5. <strong>Weight Adjustment</strong>: Lightness and chroma weights can be tuned (0.0-2.0x) per color group</div>
                            <div class="commandment-rule">6. <strong>Compliance First</strong>: Trajectory adjustments override for WCAG/APCA compliance when enforced</div>
                            <div class="commandment-rule">7. <strong>Random Palette</strong>: Generate from ONE primary color → trajectory system computes all related pairs</div>
                        </div>
                    </div>

                    <!-- 2. WCAG ACCESSIBILITY RULES -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">♿ WCAG 2.2 Accessibility Rules</span>
                            <span style="opacity: 0.6; font-size: 10px;">6 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Text Contrast</strong>: MUST be ≥4.5:1 against background (WCAG AA)</div>
                            <div class="commandment-rule">2. <strong>UI Component Contrast</strong>: MUST be ≥3:1 against background (WCAG AA)</div>
                            <div class="commandment-rule">3. <strong>AAA Compliance</strong>: Text ≥7:1, UI ≥4.5:1 for maximum accessibility (optional)</div>
                            <div class="commandment-rule">4. <strong>Disabled States</strong>: Ensure 3:1+ contrast (e.g., disabled button text: L=0.75 vs L=0.60)</div>
                            <div class="commandment-rule">5. <strong>Max Readability</strong>: When enabled, maximize text contrast (L→0.95 light mode, L→0.15 dark mode) + reduce chroma (C≤0.02)</div>
                            <div class="commandment-rule">6. <strong>Auto-Fix</strong>: Iterate lightness adjustment until compliance achieved (max 20 attempts)</div>
                        </div>
                    </div>

                    <!-- 3. APCA (PERCEPTUAL CONTRAST) -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">👁️ APCA Perceptual Contrast</span>
                            <span style="opacity: 0.6; font-size: 10px;">4 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Minimum Lc</strong>: Body text MUST be ≥60 Lc (APCA standard)</div>
                            <div class="commandment-rule">2. <strong>UI Elements</strong>: MUST be ≥45 Lc for interactive components</div>
                            <div class="commandment-rule">3. <strong>Perceptual Balance</strong>: APCA accounts for font weight, size, and viewing conditions</div>
                            <div class="commandment-rule">4. <strong>Future-Proof</strong>: APCA is next-gen WCAG 3.0 standard (forward compatibility)</div>
                        </div>
                    </div>

                    <!-- 4. TYPOGRAPHY SCALE -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">🔤 Typography Scale</span>
                            <span style="opacity: 0.6; font-size: 10px;">8 sizes</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule"><strong>--text-xs</strong>: 11px (labels, badges, metadata)</div>
                            <div class="commandment-rule"><strong>--text-sm</strong>: 12px (secondary text, descriptions)</div>
                            <div class="commandment-rule"><strong>--text-base</strong>: 14px (body text, standard UI)</div>
                            <div class="commandment-rule"><strong>--text-md</strong>: 16px (important body text)</div>
                            <div class="commandment-rule"><strong>--text-lg</strong>: 18px (subheadings)</div>
                            <div class="commandment-rule"><strong>--text-xl</strong>: 20px (section headings)</div>
                            <div class="commandment-rule"><strong>--text-2xl</strong>: 24px (page headings)</div>
                            <div class="commandment-rule"><strong>Line Height</strong>: 1.5 (optimal readability for body text)</div>
                        </div>
                    </div>

                    <!-- 5. SPACING SCALE (4px Base) -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">📏 Spacing Scale (4px Base)</span>
                            <span style="opacity: 0.6; font-size: 10px;">7 steps</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule"><strong>--space-1</strong>: 4px (tight spacing, icons)</div>
                            <div class="commandment-rule"><strong>--space-2</strong>: 8px (compact padding)</div>
                            <div class="commandment-rule"><strong>--space-3</strong>: 12px (standard padding)</div>
                            <div class="commandment-rule"><strong>--space-4</strong>: 16px (section spacing)</div>
                            <div class="commandment-rule"><strong>--space-5</strong>: 24px (large spacing)</div>
                            <div class="commandment-rule"><strong>--space-6</strong>: 32px (extra large spacing)</div>
                            <div class="commandment-rule"><strong>--space-7</strong>: 48px (major section dividers)</div>
                        </div>
                    </div>

                    <!-- 6. BORDER RADIUS SCALE -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">⭕ Border Radius Scale</span>
                            <span style="opacity: 0.6; font-size: 10px;">4 sizes</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule"><strong>--radius-sm</strong>: 4px (buttons, inputs, badges)</div>
                            <div class="commandment-rule"><strong>--radius-md</strong>: 8px (cards, panels)</div>
                            <div class="commandment-rule"><strong>--radius-lg</strong>: 12px (modals, large containers)</div>
                            <div class="commandment-rule"><strong>--radius-xl</strong>: 16px (hero sections, major UI elements)</div>
                        </div>
                    </div>

                    <!-- 7. COLOR HARMONY RULES -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">🎨 Color Harmony Rules</span>
                            <span style="opacity: 0.6; font-size: 10px;">6 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Chroma Consistency</strong>: Surface/background MUST have low chroma (C≤0.02) for neutrality</div>
                            <div class="commandment-rule">2. <strong>Lightness Separation</strong>: Adjacent elements need ≥0.15 lightness delta for visual hierarchy</div>
                            <div class="commandment-rule">3. <strong>Hue Harmony</strong>: Use complementary (180°), triadic (120°), or analogous (30°) relationships</div>
                            <div class="commandment-rule">4. <strong>Saturation Strategy</strong>: Primary actions have highest chroma, secondary/tertiary progressively lower</div>
                            <div class="commandment-rule">5. <strong>Background Neutrality</strong>: Backgrounds MUST NOT compete with content (C≤0.01 optimal)</div>
                            <div class="commandment-rule">6. <strong>Perceptual Uniformity</strong>: OKLCH ensures equal perceptual steps in color transformations</div>
                        </div>
                    </div>

                    <!-- 8. VISUAL HIERARCHY -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">👑 Visual Hierarchy</span>
                            <span style="opacity: 0.6; font-size: 10px;">5 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Z-Index Layers</strong>: Background (0) → Surface (1) → Elevated (2) → Modal (100) → Tooltip (200)</div>
                            <div class="commandment-rule">2. <strong>Size Hierarchy</strong>: Headers 1.5-2x body text, labels 0.75-0.85x body text</div>
                            <div class="commandment-rule">3. <strong>Weight Hierarchy</strong>: Headers bold (600-700), body regular (400), labels medium (500)</div>
                            <div class="commandment-rule">4. <strong>Color Hierarchy</strong>: Primary actions highest chroma → Secondary → Tertiary → Neutral</div>
                            <div class="commandment-rule">5. <strong>Spacing Hierarchy</strong>: Major sections (48px) → Sections (24px) → Components (12px) → Elements (4px)</div>
                        </div>
                    </div>

                    <!-- 9. LAYOUT PRINCIPLES -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">📐 Layout Principles</span>
                            <span style="opacity: 0.6; font-size: 10px;">6 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Max Content Width</strong>: 1280px for readability (prevents eye strain on large displays)</div>
                            <div class="commandment-rule">2. <strong>Sidebar Width</strong>: 280px left sidebar (navigation), 320px right sidebar (tools)</div>
                            <div class="commandment-rule">3. <strong>Grid System</strong>: 12-column grid with 16px gutters for flexible layouts</div>
                            <div class="commandment-rule">4. <strong>Card Padding</strong>: 16px standard, 24px large cards, 12px compact</div>
                            <div class="commandment-rule">5. <strong>Touch Targets</strong>: Minimum 44x44px for mobile accessibility</div>
                            <div class="commandment-rule">6. <strong>Responsive Breakpoints</strong>: Mobile (&lt;768px), Tablet (768-1024px), Desktop (&gt;1024px)</div>
                        </div>
                    </div>

                    <!-- 10. INTERACTION RULES -->
                    <div class="commandment-category">
                        <button class="commandment-header" onclick="toggleCommandmentCategory(this)">
                            <span style="transform: rotate(90deg); display: inline-block; transition: transform 200ms;">▶</span>
                            <span style="flex: 1; text-align: left;">⚡ Interaction Rules</span>
                            <span style="opacity: 0.6; font-size: 10px;">6 rules</span>
                        </button>
                        <div class="commandment-content" style="max-height: 1000px;">
                            <div class="commandment-rule">1. <strong>Hover States</strong>: Background darkens by 5% (light mode) or lightens by 5% (dark mode)</div>
                            <div class="commandment-rule">2. <strong>Active States</strong>: Background darkens by 10% + scale(0.98) for tactile feedback</div>
                            <div class="commandment-rule">3. <strong>Transition Timing</strong>: 150-200ms for UI interactions, 300-400ms for layout changes</div>
                            <div class="commandment-rule">4. <strong>Easing</strong>: cubic-bezier(0.4, 0, 0.2, 1) for smooth, natural motion</div>
                            <div class="commandment-rule">5. <strong>Focus Indicators</strong>: 2px solid outline with 2px offset, 3:1 contrast minimum</div>
                            <div class="commandment-rule">6. <strong>Loading States</strong>: Skeleton screens or spinners with 0.6 opacity pulse animation</div>
                        </div>
                    </div>

                </div>

                <!-- Quick Actions -->
                <div style="margin-top: 16px; padding: 12px; background: var(--scaffold-bg-elevated); border: 1px solid var(--scaffold-border); border-radius: 8px;">
                    <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-bottom: 8px;">QUICK ACTIONS</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="expandAllCommandments()" style="flex: 1; padding: 8px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 11px; cursor: pointer;">Expand All</button>
                        <button onclick="collapseAllCommandments()" style="flex: 1; padding: 8px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 11px; cursor: pointer;">Collapse All</button>
                    </div>
                </div>
            </div>

            <!-- 🔬 DIAGNOSTIC LENS - The Mathematician's Eye -->
            <div class="section" data-widget-id="diagnostic-lens">
                <div class="section-title">🔬 Diagnostic Lens</div>
                <p style="font-size: 11px; color: var(--scaffold-text-muted); margin-bottom: 12px; line-height: 1.4;">
                    Hyper-dimensional state analyzer: Maps all atoms, color-group pairs, metadata, and counter-weight topology
                </p>

                <!-- Quick Stats -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                    <div style="background: var(--scaffold-bg); padding: 8px; border-radius: 6px; border: 1px solid var(--scaffold-border);">
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-bottom: 2px;">ATOMS</div>
                        <div style="font-size: 16px; font-weight: 700; color: var(--scaffold-text);" id="diagnostic-atoms-count">0</div>
                    </div>
                    <div style="background: var(--scaffold-bg); padding: 8px; border-radius: 6px; border: 1px solid var(--scaffold-border);">
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-bottom: 2px;">PAIRS</div>
                        <div style="font-size: 16px; font-weight: 700; color: var(--scaffold-text);" id="diagnostic-pairs-count">0</div>
                    </div>
                </div>

                <!-- Scan Button -->
                <button onclick="runDiagnosticScan()" style="width: 100%; padding: 12px; background: oklch(0.45 0.18 270); border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 12px; transition: all 200ms;">
                    🔬 Run Full Diagnostic Scan
                </button>

                <!-- Results Container -->
                <div id="diagnostic-results" style="max-height: 400px; overflow-y: auto; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 8px; padding: 8px; font-size: 11px; line-height: 1.5; display: none;">
                    <!-- Will be populated by diagnostic scan -->
                </div>

                <!-- Analysis Tabs -->
                <div style="display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap;" id="diagnostic-tabs">
                    <button class="diagnostic-tab active" data-view="atoms" style="flex: 1; padding: 6px; background: var(--scaffold-bg-elevated); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; cursor: pointer; font-weight: 600;">ATOMS</button>
                    <button class="diagnostic-tab" data-view="topology" style="flex: 1; padding: 6px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; cursor: pointer; font-weight: 600;">TOPOLOGY</button>
                    <button class="diagnostic-tab" data-view="patterns" style="flex: 1; padding: 6px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; cursor: pointer; font-weight: 600;">PATTERNS</button>
                    <button class="diagnostic-tab" data-view="weights" style="flex: 1; padding: 6px; background: var(--scaffold-bg); border: 1px solid var(--scaffold-border); border-radius: 4px; font-size: 10px; cursor: pointer; font-weight: 600;">WEIGHTS</button>
                </div>
            </div>
        </div>

        <!-- CENTER GALLERY -->
        <div class="center-gallery">
            <div class="gallery-header">
                <div class="gallery-title">Component Gallery</div>
                <div class="gallery-subtitle">Click any element to edit its color</div>
            </div>

            <!-- VIEW TOGGLE -->
            <div style="display: flex; justify-content: center; margin-bottom: 8px;">
                <div class="mode-toggle">
                    <button class="mode-btn active" id="library-view-btn">📚 Library View</button>
                    <button class="mode-btn" id="mockup-view-btn">🎨 Mockup Pages</button>
                </div>
            </div>

            <div class="selector-hint">
                👆 <strong>Universal Selector Active</strong> - Click any button, badge, card, or UI element to instantly edit its color in the left sidebar
            </div>

            <!-- LIBRARY VIEW (Comprehensive Component Library) -->
            <main id="main-content">
            <div id="library-view">

            <!-- PURPOSE CATEGORY: BUTTONS -->
            <div class="component-section">
                <div class="section-header">🔘 Buttons - Actions & CTAs</div>
                <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                    <button class="btn btn-primary selectable" data-color-group="primary">Primary Action</button>
                    <button class="btn btn-secondary selectable" data-color-group="secondary">Secondary</button>
                    <button class="btn btn-outline selectable" data-color-group="primary">Outline</button>
                    <button class="btn btn-primary selectable" data-color-group="primary" style="padding: 8px 16px; font-size: 12px;">Small</button>
                    <button class="btn btn-primary selectable" data-color-group="primary" style="padding: 16px 32px; font-size: 16px;">Large</button>
                    <button class="btn btn-primary selectable" data-color-group="primary" style="opacity: 0.5; cursor: not-allowed;" disabled>Disabled</button>
                    <button class="btn btn-primary selectable" data-color-group="primary" style="border-radius: 50%; width: 40px; height: 40px; padding: 0;">🔍</button>
                    <button style="background: transparent; border: none; color: var(--primary); text-decoration: underline; cursor: pointer; padding: 8px; font-size: 14px;" class="selectable" data-color-group="primary">Link Button</button>
                </div>
            </div>

            <!-- PURPOSE CATEGORY: FORM CONTROLS -->
            <div class="component-section">
                <div class="section-header">📝 Form Controls - Data Input</div>
                <div style="display: grid; gap: 16px; max-width: 600px;">
                    <!-- Text Input -->
                    <input type="text" class="input selectable" data-color-group="surface" placeholder="Text input..." style="width: 100%;">

                    <!-- Email Input -->
                    <input type="email" class="input selectable" data-color-group="surface" placeholder="email@example.com" style="width: 100%;">

                    <!-- Textarea -->
                    <textarea class="input selectable" data-color-group="surface" placeholder="Multiline text..." style="width: 100%; min-height: 80px; font-family: inherit; resize: vertical;"></textarea>

                    <!-- Select Dropdown -->
                    <select class="input selectable" data-color-group="surface" style="width: 100%;">
                        <option>Select option...</option>
                        <option>Option 1</option>
                        <option>Option 2</option>
                        <option>Option 3</option>
                    </select>

                    <!-- Checkbox -->
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary);" class="selectable" data-color-group="primary">
                        <span style="color: var(--scaffold-text); font-size: 14px;">Checkbox option</span>
                    </label>

                    <!-- Radio Buttons -->
                    <div style="display: flex; gap: 24px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="radio-demo" checked style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary);" class="selectable" data-color-group="primary">
                            <span style="color: var(--scaffold-text); font-size: 14px;">Radio 1</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="radio-demo" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary);" class="selectable" data-color-group="primary">
                            <span style="color: var(--scaffold-text); font-size: 14px;">Radio 2</span>
                        </label>
                    </div>

                    <!-- Toggle Switch -->
                    <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                        <div class="toggle-switch active selectable" data-color-group="primary">
                            <div class="toggle-switch-knob"></div>
                        </div>
                        <span style="color: var(--scaffold-text); font-size: 14px;">Toggle switch</span>
                    </label>

                    <!-- File Upload -->
                    <div style="border: 2px dashed var(--scaffold-border); border-radius: 8px; padding: 24px; text-align: center; cursor: pointer; background: var(--scaffold-bg);" class="selectable" data-color-group="surface">
                        <div style="font-size: 32px; margin-bottom: 8px;">📁</div>
                        <div style="color: var(--scaffold-text); font-size: 14px; font-weight: 500; margin-bottom: 4px;">Click to upload</div>
                        <div style="color: var(--scaffold-text-muted); font-size: 12px;">or drag and drop files here</div>
                    </div>
                </div>
            </div>

            <!-- PURPOSE CATEGORY: NAVIGATION -->
            <div class="component-section">
                <div class="section-header">🧭 Navigation - Wayfinding & Routing</div>

                <!-- Navbar -->
                <div style="background: var(--surface); border-radius: 8px; padding: 16px; margin-bottom: 16px;" class="selectable" data-color-group="surface">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 18px; font-weight: 700; color: var(--scaffold-text);">Brand Logo</div>
                        <div style="display: flex; gap: 24px; align-items: center;">
                            <span style="color: var(--primary); font-weight: 600; cursor: pointer;" class="selectable" data-color-group="primary">Home</span>
                            <span style="color: var(--scaffold-text); cursor: pointer;">Products</span>
                            <span style="color: var(--scaffold-text); cursor: pointer;">About</span>
                            <button class="btn btn-primary selectable" data-color-group="primary" style="padding: 8px 16px; font-size: 14px;">Sign Up</button>
                        </div>
                    </div>
                </div>

                <!-- Tabs -->
                <div style="display: flex; gap: 4px; border-bottom: 2px solid var(--scaffold-border); margin-bottom: 16px;">
                    <div style="padding: 12px 24px; border-bottom: 3px solid var(--primary); margin-bottom: -2px; font-weight: 600; color: var(--primary); cursor: pointer;" class="selectable" data-color-group="primary">Overview</div>
                    <div style="padding: 12px 24px; color: var(--scaffold-text-muted); cursor: pointer;">Details</div>
                    <div style="padding: 12px 24px; color: var(--scaffold-text-muted); cursor: pointer;">Settings</div>
                </div>

                <!-- Breadcrumbs -->
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; margin-bottom: 16px;">
                    <span style="color: var(--primary); cursor: pointer;" class="selectable" data-color-group="primary">Home</span>
                    <span style="color: var(--scaffold-text-muted);">›</span>
                    <span style="color: var(--primary); cursor: pointer;" class="selectable" data-color-group="primary">Products</span>
                    <span style="color: var(--scaffold-text-muted);">›</span>
                    <span style="color: var(--scaffold-text); font-weight: 500;">Details</span>
                </div>

                <!-- Pagination -->
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button style="padding: 8px 12px; background: var(--surface); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer;" class="selectable" data-color-group="surface">‹ Prev</button>
                    <button style="padding: 8px 12px; background: var(--primary); border: 1px solid var(--primary); border-radius: 6px; color: white; font-weight: 600; cursor: pointer;" class="selectable" data-color-group="primary">1</button>
                    <button style="padding: 8px 12px; background: var(--surface); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer;" class="selectable" data-color-group="surface">2</button>
                    <button style="padding: 8px 12px; background: var(--surface); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer;" class="selectable" data-color-group="surface">3</button>
                    <button style="padding: 8px 12px; background: var(--surface); border: 1px solid var(--scaffold-border); border-radius: 6px; color: var(--scaffold-text); cursor: pointer;" class="selectable" data-color-group="surface">Next ›</button>
                </div>
            </div>

            <!-- PURPOSE CATEGORY: FEEDBACK -->
            <div class="component-section">
                <div class="section-header">📢 Feedback - Status & Notifications</div>

                <!-- Alerts -->
                <div style="display: grid; gap: 12px; margin-bottom: 16px;">
                    <div class="alert alert-success selectable" data-color-group="success" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: oklch(0.85 0.08 145); border-left: 4px solid oklch(0.55 0.12 145); border-radius: 8px;">
                        <span style="font-size: 20px;">✓</span>
                        <span style="color: oklch(0.30 0.08 145); font-weight: 500;">Success! Operation completed successfully</span>
                    </div>
                    <div class="selectable" data-color-group="primary" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: oklch(0.90 0.08 270); border-left: 4px solid var(--primary); border-radius: 8px;">
                        <span style="font-size: 20px;">ℹ</span>
                        <span style="color: var(--primary); font-weight: 500;">Info: New updates available</span>
                    </div>
                    <div class="selectable" data-color-group="accent" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: oklch(0.92 0.08 60); border-left: 4px solid oklch(0.70 0.12 60); border-radius: 8px;">
                        <span style="font-size: 20px;">⚠</span>
                        <span style="color: oklch(0.40 0.08 60); font-weight: 500;">Warning: Please review your settings</span>
                    </div>
                </div>

                <!-- Toast/Notification -->
                <div class="card selectable" data-color-group="surface" style="max-width: 350px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--scaffold-text); margin-bottom: 4px;">Notification Title</div>
                            <div style="font-size: 14px; color: var(--scaffold-text-muted);">Your changes have been saved successfully.</div>
                        </div>
                        <button style="background: transparent; border: none; color: var(--scaffold-text-muted); cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px;">×</button>
                    </div>
                </div>

                <!-- Progress Bar -->
                <div style="margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="font-size: 14px; color: var(--scaffold-text); font-weight: 500;">Upload Progress</span>
                        <span style="font-size: 14px; color: var(--scaffold-text-muted);">65%</span>
                    </div>
                    <div style="width: 100%; height: 8px; background: var(--scaffold-bg); border-radius: 4px; overflow: hidden;">
                        <div style="width: 65%; height: 100%; background: var(--primary); border-radius: 4px; transition: width 300ms;" class="selectable" data-color-group="primary"></div>
                    </div>
                </div>

                <!-- Spinner/Loader -->
                <div style="margin-top: 24px; display: flex; align-items: center; gap: 16px;">
                    <div style="width: 32px; height: 32px; border: 3px solid var(--scaffold-bg); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite;" class="selectable" data-color-group="primary"></div>
                    <span style="color: var(--scaffold-text); font-size: 14px;">Loading...</span>
                </div>
            </div>

            <!-- PURPOSE CATEGORY: LAYOUT -->
            <div class="component-section">
                <div class="section-header">📐 Layout - Structure & Organization</div>

                <!-- Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-bottom: 24px;">
                    <div class="card selectable" data-color-group="surface">
                        <div style="font-size: 18px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Simple Card</div>
                        <div style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 16px;">Card with title and description content.</div>
                        <button class="btn btn-outline selectable" data-color-group="primary" style="padding: 8px 16px; font-size: 13px;">Action</button>
                    </div>

                    <div class="card selectable" data-color-group="surface">
                        <div style="width: 100%; height: 120px; background: var(--scaffold-bg); border-radius: 6px; margin-bottom: 12px;"></div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 4px;">Image Card</div>
                        <div style="font-size: 13px; color: var(--scaffold-text-muted);">Card with image placeholder</div>
                    </div>
                </div>

                <!-- Container -->
                <div style="max-width: 800px; margin: 0 auto 24px; padding: 24px; background: var(--surface); border-radius: 8px;" class="selectable" data-color-group="surface">
                    <div style="font-size: 16px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Container Component</div>
                    <div style="color: var(--scaffold-text-muted); font-size: 14px;">Centered container with max-width constraint for readable content width.</div>
                </div>

                <!-- Divider -->
                <div style="margin: 24px 0;">
                    <div style="height: 1px; background: var(--scaffold-border);"></div>
                </div>

                <!-- Accordion/Collapse -->
                <div style="border: 1px solid var(--scaffold-border); border-radius: 8px; overflow: hidden;">
                    <div style="padding: 16px; background: var(--surface); cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--scaffold-border);" class="selectable" data-color-group="surface">
                        <span style="font-weight: 600; color: var(--scaffold-text);">Accordion Section 1</span>
                        <span style="color: var(--scaffold-text-muted);">▼</span>
                    </div>
                    <div style="padding: 16px; background: var(--scaffold-bg); color: var(--scaffold-text-muted); font-size: 14px;">
                        Expandable content goes here. Click header to toggle.
                    </div>
                    <div style="padding: 16px; background: var(--surface); cursor: pointer; display: flex; justify-content: space-between; align-items: center;" class="selectable" data-color-group="surface">
                        <span style="font-weight: 600; color: var(--scaffold-text);">Accordion Section 2</span>
                        <span style="color: var(--scaffold-text-muted);">▶</span>
                    </div>
                </div>
            </div>

            <!-- PURPOSE CATEGORY: DATA DISPLAY -->
            <div class="component-section">
                <div class="section-header">📊 Data Display - Information Presentation</div>

                <!-- Table -->
                <div style="overflow-x: auto; margin-bottom: 24px;">
                    <table style="width: 100%; border-collapse: collapse; background: var(--surface); border-radius: 8px; overflow: hidden;" class="selectable" data-color-group="surface">
                        <thead>
                            <tr style="background: var(--scaffold-bg);">
                                <th style="padding: 12px; text-align: left; font-weight: 600; color: var(--scaffold-text); border-bottom: 2px solid var(--scaffold-border);">Name</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600; color: var(--scaffold-text); border-bottom: 2px solid var(--scaffold-border);">Status</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600; color: var(--scaffold-text); border-bottom: 2px solid var(--scaffold-border);">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 12px; color: var(--scaffold-text); border-bottom: 1px solid var(--scaffold-border);">Project Alpha</td>
                                <td style="padding: 12px; border-bottom: 1px solid var(--scaffold-border);"><span class="badge badge-primary selectable" data-color-group="primary">Active</span></td>
                                <td style="padding: 12px; text-align: right; color: var(--scaffold-text); border-bottom: 1px solid var(--scaffold-border);">$12,500</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; color: var(--scaffold-text); border-bottom: 1px solid var(--scaffold-border);">Project Beta</td>
                                <td style="padding: 12px; border-bottom: 1px solid var(--scaffold-border);"><span class="badge badge-accent selectable" data-color-group="accent">Pending</span></td>
                                <td style="padding: 12px; text-align: right; color: var(--scaffold-text); border-bottom: 1px solid var(--scaffold-border);">$8,300</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; color: var(--scaffold-text);">Project Gamma</td>
                                <td style="padding: 12px;"><span class="badge badge-primary selectable" data-color-group="primary">Complete</span></td>
                                <td style="padding: 12px; text-align: right; color: var(--scaffold-text);">$15,750</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Lists -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-bottom: 24px;">
                    <div class="card selectable" data-color-group="surface">
                        <div style="font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">Unordered List</div>
                        <ul style="list-style: disc; padding-left: 24px; color: var(--scaffold-text-muted); font-size: 14px;">
                            <li style="margin-bottom: 8px;">First item</li>
                            <li style="margin-bottom: 8px;">Second item</li>
                            <li>Third item</li>
                        </ul>
                    </div>

                    <div class="card selectable" data-color-group="surface">
                        <div style="font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">Ordered List</div>
                        <ol style="list-style: decimal; padding-left: 24px; color: var(--scaffold-text-muted); font-size: 14px;">
                            <li style="margin-bottom: 8px;">First step</li>
                            <li style="margin-bottom: 8px;">Second step</li>
                            <li>Third step</li>
                        </ol>
                    </div>
                </div>

                <!-- Stats/KPIs -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px;">
                    <div class="card selectable" data-color-group="surface" style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700; color: var(--primary);" class="selectable" data-color-group="primary">1,234</div>
                        <div style="font-size: 14px; color: var(--scaffold-text-muted); margin-top: 4px;">Total Users</div>
                    </div>

                    <div class="card selectable" data-color-group="surface" style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700; color: var(--accent);" class="selectable" data-color-group="accent">$45.2K</div>
                        <div style="font-size: 14px; color: var(--scaffold-text-muted); margin-top: 4px;">Revenue</div>
                    </div>

                    <div class="card selectable" data-color-group="surface" style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700; color: var(--secondary);" class="selectable" data-color-group="secondary">89%</div>
                        <div style="font-size: 14px; color: var(--scaffold-text-muted); margin-top: 4px;">Satisfaction</div>
                    </div>
                </div>

                <!-- Badges/Tags -->
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 24px;">
                    <span class="badge badge-primary selectable" data-color-group="primary">Featured</span>
                    <span class="badge badge-secondary selectable" data-color-group="secondary">New</span>
                    <span class="badge badge-accent selectable" data-color-group="accent">Popular</span>
                    <span class="badge badge-primary selectable" data-color-group="primary" style="font-size: 11px; padding: 4px 10px;">Small</span>
                    <span class="badge badge-accent selectable" data-color-group="accent" style="font-size: 15px; padding: 8px 16px;">Large</span>
                </div>

                <!-- Avatar/Profile -->
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="width: 48px; height: 48px; border-radius: 50%; background: var(--primary); display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 18px;" class="selectable" data-color-group="primary">JD</div>
                    <div>
                        <div style="font-weight: 600; color: var(--scaffold-text); font-size: 14px;">John Doe</div>
                        <div style="font-size: 12px; color: var(--scaffold-text-muted);">john@example.com</div>
                    </div>
                </div>
            </div>

            </div> <!-- END library-view -->

            <!-- MOCKUP VIEW (Realistic Pages) -->
            <div id="mockup-view" style="display: none;">

                <!-- Mockup Tabs -->
                <div style="display: flex; gap: 8px; margin-bottom: 24px; flex-wrap: wrap;">
                    <button class="top-btn mockup-tab active" data-mockup="dashboard">📊 Dashboard</button>
                    <button class="top-btn mockup-tab" data-mockup="landing">🚀 Landing Page</button>
                    <button class="top-btn mockup-tab" data-mockup="settings">⚙️ Settings</button>
                    <button class="top-btn mockup-tab" data-mockup="ecommerce">🛍️ E-commerce</button>
                    <button class="top-btn mockup-tab" data-mockup="admin">🔐 Admin Panel</button>
                    <button class="top-btn mockup-tab" data-mockup="blog">📝 Blog</button>
                    <button class="top-btn mockup-tab" data-mockup="portfolio">🎨 Portfolio</button>
                    <button class="top-btn mockup-tab" data-mockup="social">💬 Social Media</button>
                    <button class="top-btn mockup-tab" data-mockup="analytics">📈 Analytics</button>
                    <button class="top-btn mockup-tab" data-mockup="crm">👥 CRM</button>
                </div>

                <!-- DASHBOARD MOCKUP -->
                <div class="mockup-page active" id="mockup-dashboard">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <!-- Header -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px;">
                            <div>
                                <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 8px;">Dashboard</h1>
                                <p style="color: var(--scaffold-text-muted);">Welcome back, here's what's happening</p>
                            </div>
                            <button class="btn btn-primary selectable" data-color-group="primary">New Project</button>
                        </div>

                        <!-- Stats Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 24px; margin-bottom: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Total Revenue</div>
                                <div style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 8px;">$45,231</div>
                                <div style="display: flex; align-items: center; gap: 4px; color: var(--success); font-size: 14px;">
                                    <span>↗</span>
                                    <span>+12.5%</span>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Active Users</div>
                                <div style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 8px;">2,853</div>
                                <div style="display: flex; align-items: center; gap: 4px; color: var(--success); font-size: 14px;">
                                    <span>↗</span>
                                    <span>+5.2%</span>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Conversions</div>
                                <div style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 8px;">623</div>
                                <div style="display: flex; align-items: center; gap: 4px; color: var(--error); font-size: 14px;">
                                    <span>↘</span>
                                    <span>-2.1%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Main Content Area -->
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 24px;">
                            <!-- Recent Activity -->
                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Recent Activity</h3>
                                <div style="space-y: 16px;">
                                    <div style="padding: 12px 0; border-bottom: 1px solid var(--scaffold-border);">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                            <span style="font-weight: 500; color: var(--scaffold-text);">New user registration</span>
                                            <span class="badge badge-primary selectable" data-color-group="primary">New</span>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">2 minutes ago</span>
                                    </div>
                                    <div style="padding: 12px 0; border-bottom: 1px solid var(--scaffold-border);">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                            <span style="font-weight: 500; color: var(--scaffold-text);">Payment received</span>
                                            <span class="badge badge-accent selectable" data-color-group="accent">$299</span>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">15 minutes ago</span>
                                    </div>
                                    <div style="padding: 12px 0;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                            <span style="font-weight: 500; color: var(--scaffold-text);">Project completed</span>
                                            <span class="badge badge-primary selectable" data-color-group="primary">Done</span>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">1 hour ago</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Quick Actions -->
                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Quick Actions</h3>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button class="btn btn-primary selectable" data-color-group="primary" style="width: 100%;">Create Invoice</button>
                                    <button class="btn btn-secondary selectable" data-color-group="secondary" style="width: 100%;">Add Customer</button>
                                    <button class="btn btn-outline selectable" data-color-group="primary" style="width: 100%;">View Reports</button>
                                </div>
                            </div>
                        </div>

                        <!-- Task Progress Section -->
                        <div style="margin-top: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Active Tasks</h3>
                                <div style="display: flex; flex-direction: column; gap: 16px;">
                                    <div style="padding: 12px; border-left: 3px solid var(--primary); background: var(--scaffold-bg); border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                            <span style="font-weight: 600; color: var(--scaffold-text);">Website Redesign</span>
                                            <span class="badge badge-accent selectable" data-color-group="accent">In Progress</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: var(--scaffold-bg); border-radius: 4px; margin-bottom: 8px;">
                                            <div style="width: 65%; height: 100%; background: var(--primary); border-radius: 4px;"></div>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">65% complete • Due in 5 days</span>
                                    </div>
                                    <div style="padding: 12px; border-left: 3px solid var(--secondary); background: var(--scaffold-bg); border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                            <span style="font-weight: 600; color: var(--scaffold-text);">API Integration</span>
                                            <span class="badge badge-primary selectable" data-color-group="primary">Review</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: var(--scaffold-bg); border-radius: 4px; margin-bottom: 8px;">
                                            <div style="width: 90%; height: 100%; background: var(--secondary); border-radius: 4px;"></div>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">90% complete • Due tomorrow</span>
                                    </div>
                                    <div style="padding: 12px; border-left: 3px solid var(--accent); background: var(--scaffold-bg); border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                            <span style="font-weight: 600; color: var(--scaffold-text);">Mobile App Launch</span>
                                            <span class="badge badge-accent selectable" data-color-group="accent">Planning</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: var(--scaffold-bg); border-radius: 4px; margin-bottom: 8px;">
                                            <div style="width: 15%; height: 100%; background: var(--accent); border-radius: 4px;"></div>
                                        </div>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">15% complete • Due in 2 weeks</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Team Members Table -->
                        <div style="margin-top: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Team Performance</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse;">
                                        <thead>
                                            <tr style="border-bottom: 2px solid var(--scaffold-border);">
                                                <th style="text-align: left; padding: 12px; color: var(--scaffold-text-muted); font-weight: 600;">Member</th>
                                                <th style="text-align: left; padding: 12px; color: var(--scaffold-text-muted); font-weight: 600;">Role</th>
                                                <th style="text-align: left; padding: 12px; color: var(--scaffold-text-muted); font-weight: 600;">Tasks</th>
                                                <th style="text-align: left; padding: 12px; color: var(--scaffold-text-muted); font-weight: 600;">Status</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr style="border-bottom: 1px solid var(--scaffold-border);">
                                                <td style="padding: 12px; color: var(--scaffold-text);">Sarah Johnson</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">Designer</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">8/10</td>
                                                <td style="padding: 12px;"><span class="badge badge-primary selectable" data-color-group="primary">Active</span></td>
                                            </tr>
                                            <tr style="border-bottom: 1px solid var(--scaffold-border);">
                                                <td style="padding: 12px; color: var(--scaffold-text);">Mike Chen</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">Developer</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">12/15</td>
                                                <td style="padding: 12px;"><span class="badge badge-accent selectable" data-color-group="accent">Busy</span></td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 12px; color: var(--scaffold-text);">Emma Wilson</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">Manager</td>
                                                <td style="padding: 12px; color: var(--scaffold-text);">5/8</td>
                                                <td style="padding: 12px;"><span class="badge badge-primary selectable" data-color-group="primary">Active</span></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: flex-end;">
                                    <button class="btn btn-outline selectable" data-color-group="secondary">View All</button>
                                    <button class="btn btn-primary selectable" data-color-group="primary">Add Member</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- LANDING PAGE MOCKUP -->
                <div class="mockup-page" id="mockup-landing" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <!-- Hero Section -->
                        <div style="text-align: center; padding: 80px 0;">
                            <h1 style="font-size: 56px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 24px; line-height: 1.1;">
                                Build Something <br>Amazing Today
                            </h1>
                            <p style="font-size: 20px; color: var(--scaffold-text-muted); margin-bottom: 32px; max-width: 600px; margin-left: auto; margin-right: auto;">
                                The ultimate platform for creators, developers, and innovators to bring their ideas to life.
                            </p>
                            <div style="display: flex; gap: 16px; justify-content: center;">
                                <button class="btn btn-primary selectable" data-color-group="primary" style="font-size: 18px; padding: 16px 32px;">Get Started</button>
                                <button class="btn btn-outline selectable" data-color-group="primary" style="font-size: 18px; padding: 16px 32px;">Learn More</button>
                            </div>
                        </div>

                        <!-- Features Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 32px; margin-top: 80px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="font-size: 40px; margin-bottom: 16px;">⚡</div>
                                <h3 style="font-size: 24px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">Lightning Fast</h3>
                                <p style="color: var(--scaffold-text-muted); line-height: 1.6;">Optimized for speed and performance. Your users will love the experience.</p>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="font-size: 40px; margin-bottom: 16px;">🔒</div>
                                <h3 style="font-size: 24px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">Secure by Default</h3>
                                <p style="color: var(--scaffold-text-muted); line-height: 1.6;">Enterprise-grade security built into every layer of the platform.</p>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="font-size: 40px; margin-bottom: 16px;">🎨</div>
                                <h3 style="font-size: 24px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">Fully Customizable</h3>
                                <p style="color: var(--scaffold-text-muted); line-height: 1.6;">Make it yours with extensive theming and configuration options.</p>
                            </div>
                        </div>

                        <!-- CTA Section -->
                        <div class="card selectable" data-color-group="surface" style="margin-top: 80px; text-align: center; padding: 64px;">
                            <h2 style="font-size: 40px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 16px;">Ready to get started?</h2>
                            <p style="font-size: 18px; color: var(--scaffold-text-muted); margin-bottom: 32px;">Join thousands of users already building with our platform.</p>
                            <button class="btn btn-primary selectable" data-color-group="primary" style="font-size: 18px; padding: 16px 48px;">Start Free Trial</button>
                        </div>
                    </div>
                </div>

                <!-- SETTINGS MOCKUP -->
                <div class="mockup-page" id="mockup-settings" style="display: none;">
                    <div style="max-width: 800px; margin: 0 auto;">
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">Settings</h1>

                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Profile</h3>
                            <div class="form-group">
                                <label class="form-label">Full Name</label>
                                <input type="text" class="input selectable" data-color-group="surface" value="John Doe">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Email Address</label>
                                <input type="email" class="input selectable" data-color-group="surface" value="john@example.com">
                            </div>
                            <button class="btn btn-primary selectable" data-color-group="primary">Save Changes</button>
                        </div>

                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Notifications</h3>
                            <div class="checkbox">
                                <input type="checkbox" checked>
                                <span>Email notifications</span>
                            </div>
                            <div class="checkbox">
                                <input type="checkbox" checked>
                                <span>Push notifications</span>
                            </div>
                            <div class="checkbox">
                                <input type="checkbox">
                                <span>SMS notifications</span>
                            </div>
                        </div>

                        <div class="card selectable" data-color-group="surface">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Danger Zone</h3>
                            <p style="color: var(--scaffold-text-muted); margin-bottom: 16px;">Once you delete your account, there is no going back.</p>
                            <button class="btn" style="background: var(--error); color: white; border: none;">Delete Account</button>
                        </div>
                    </div>
                </div>

                <!-- ECOMMERCE MOCKUP -->
                <div class="mockup-page" id="mockup-ecommerce" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <!-- Product Grid -->
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">Shop</h1>

                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 24px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 1; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <h3 style="font-size: 18px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Premium Product</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">High-quality item with excellent features</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 24px; font-weight: 700; color: var(--scaffold-text);">$299</span>
                                    <button class="btn btn-primary selectable" data-color-group="primary">Add to Cart</button>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 1; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                                    <span class="badge badge-accent selectable" data-color-group="accent">Sale</span>
                                    <span class="badge badge-primary selectable" data-color-group="primary">Featured</span>
                                </div>
                                <h3 style="font-size: 18px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Best Seller</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">Most popular item this month</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <span style="font-size: 24px; font-weight: 700; color: var(--scaffold-text);">$199</span>
                                        <span style="font-size: 16px; color: var(--scaffold-text-muted); text-decoration: line-through; margin-left: 8px;">$249</span>
                                    </div>
                                    <button class="btn btn-primary selectable" data-color-group="primary">Add to Cart</button>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 1; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <h3 style="font-size: 18px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Standard Edition</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">Great value for everyday use</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 24px; font-weight: 700; color: var(--scaffold-text);">$149</span>
                                    <button class="btn btn-secondary selectable" data-color-group="secondary">Add to Cart</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ADMIN PANEL MOCKUP -->
                <div class="mockup-page" id="mockup-admin" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">🔐 Admin Panel</h1>

                        <!-- User Management -->
                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text);">User Management</h3>
                                <button class="btn btn-primary selectable" data-color-group="primary">Add User</button>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">John Doe</span>
                                        <span class="badge badge-primary selectable" data-color-group="primary">Admin</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">john@example.com</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-outline selectable" data-color-group="primary" style="flex: 1;">Edit</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary" style="flex: 1;">Suspend</button>
                                    </div>
                                </div>
                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">Jane Smith</span>
                                        <span class="badge badge-accent selectable" data-color-group="accent">Editor</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">jane@example.com</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-outline selectable" data-color-group="primary" style="flex: 1;">Edit</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary" style="flex: 1;">Suspend</button>
                                    </div>
                                </div>
                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">Bob Wilson</span>
                                        <span class="badge badge-primary selectable" data-color-group="primary">User</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">bob@example.com</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-outline selectable" data-color-group="primary" style="flex: 1;">Edit</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary" style="flex: 1;">Suspend</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- System Settings -->
                        <div class="card selectable" data-color-group="surface">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">System Settings</h3>
                            <div style="display: flex; flex-direction: column; gap: 16px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--scaffold-bg); border-radius: 8px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--scaffold-text);">Enable Maintenance Mode</div>
                                        <div style="font-size: 12px; color: var(--scaffold-text-muted);">Temporarily disable site access</div>
                                    </div>
                                    <button class="btn btn-secondary selectable" data-color-group="secondary">Toggle</button>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--scaffold-bg); border-radius: 8px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--scaffold-text);">Clear Cache</div>
                                        <div style="font-size: 12px; color: var(--scaffold-text-muted);">Remove cached data to improve performance</div>
                                    </div>
                                    <button class="btn btn-primary selectable" data-color-group="primary">Clear</button>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--scaffold-bg); border-radius: 8px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--scaffold-text);">Database Backup</div>
                                        <div style="font-size: 12px; color: var(--scaffold-text-muted);">Create a backup of all data</div>
                                    </div>
                                    <button class="btn btn-primary selectable" data-color-group="primary">Backup</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- BLOG MOCKUP -->
                <div class="mockup-page" id="mockup-blog" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">📝 Blog</h1>

                        <!-- Featured Post -->
                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 32px; padding: 32px;">
                            <span class="badge badge-accent selectable" data-color-group="accent" style="margin-bottom: 16px;">Featured</span>
                            <h2 style="font-size: 28px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 16px;">Getting Started with OKLCH Color Space</h2>
                            <p style="color: var(--scaffold-text-muted); font-size: 16px; line-height: 1.6; margin-bottom: 16px;">
                                Discover the power of perceptually uniform colors and how OKLCH revolutionizes digital design with predictable lightness and chroma values.
                            </p>
                            <div style="display: flex; gap: 16px; align-items: center;">
                                <span style="font-size: 14px; color: var(--scaffold-text-muted);">By Sarah Johnson • 5 min read</span>
                                <button class="btn btn-primary selectable" data-color-group="primary">Read More</button>
                            </div>
                        </div>

                        <!-- Blog Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 24px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; height: 200px; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <span class="badge badge-primary selectable" data-color-group="primary">Design</span>
                                    <span class="badge badge-accent selectable" data-color-group="accent">Tutorial</span>
                                </div>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Color Theory Fundamentals</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">Learn the basics of color harmony and how to create stunning palettes.</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">3 days ago</span>
                                    <button class="btn btn-outline selectable" data-color-group="primary">Read</button>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; height: 200px; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <span class="badge badge-secondary selectable" data-color-group="secondary">Development</span>
                                </div>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">CSS Custom Properties Deep Dive</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">Master CSS variables and create dynamic, themeable user interfaces.</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">1 week ago</span>
                                    <button class="btn btn-outline selectable" data-color-group="primary">Read</button>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; height: 200px; background: var(--scaffold-bg); border-radius: 8px; margin-bottom: 16px;"></div>
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <span class="badge badge-accent selectable" data-color-group="accent">Case Study</span>
                                </div>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Redesigning with Accessibility</h3>
                                <p style="color: var(--scaffold-text-muted); margin-bottom: 12px;">How we improved contrast ratios and achieved WCAG AAA compliance.</p>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">2 weeks ago</span>
                                    <button class="btn btn-outline selectable" data-color-group="primary">Read</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PORTFOLIO MOCKUP -->
                <div class="mockup-page" id="mockup-portfolio" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <div style="text-align: center; margin-bottom: 48px;">
                            <h1 style="font-size: 48px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 16px;">🎨 Creative Portfolio</h1>
                            <p style="font-size: 20px; color: var(--scaffold-text-muted); margin-bottom: 24px;">Showcasing design excellence and innovation</p>
                            <div style="display: flex; gap: 12px; justify-content: center;">
                                <button class="btn btn-primary selectable" data-color-group="primary">View Work</button>
                                <button class="btn btn-outline selectable" data-color-group="primary">Contact</button>
                            </div>
                        </div>

                        <!-- Project Filter -->
                        <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 32px; flex-wrap: wrap;">
                            <button class="btn btn-primary selectable" data-color-group="primary">All</button>
                            <button class="btn btn-outline selectable" data-color-group="primary">Web Design</button>
                            <button class="btn btn-outline selectable" data-color-group="primary">Mobile Apps</button>
                            <button class="btn btn-outline selectable" data-color-group="primary">Branding</button>
                            <button class="btn btn-outline selectable" data-color-group="primary">Illustration</button>
                        </div>

                        <!-- Portfolio Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 16/9; background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); border-radius: 8px; margin-bottom: 16px;"></div>
                                <span class="badge badge-primary selectable" data-color-group="primary" style="margin-bottom: 12px;">Web Design</span>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">E-Commerce Platform</h3>
                                <p style="color: var(--scaffold-text-muted);">Modern shopping experience with seamless checkout</p>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 16/9; background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%); border-radius: 8px; margin-bottom: 16px;"></div>
                                <span class="badge badge-accent selectable" data-color-group="accent" style="margin-bottom: 12px;">Mobile App</span>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Fitness Tracker</h3>
                                <p style="color: var(--scaffold-text-muted);">Track workouts and achieve your fitness goals</p>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 16/9; background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%); border-radius: 8px; margin-bottom: 16px;"></div>
                                <span class="badge badge-secondary selectable" data-color-group="secondary" style="margin-bottom: 12px;">Branding</span>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Startup Identity</h3>
                                <p style="color: var(--scaffold-text-muted);">Complete brand identity for tech startup</p>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="width: 100%; aspect-ratio: 16/9; background: linear-gradient(135deg, var(--primary) 50%, var(--accent) 100%); border-radius: 8px; margin-bottom: 16px;"></div>
                                <span class="badge badge-primary selectable" data-color-group="primary" style="margin-bottom: 12px;">Illustration</span>
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 8px;">Character Design</h3>
                                <p style="color: var(--scaffold-text-muted);">Unique characters for animated series</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SOCIAL MEDIA MOCKUP -->
                <div class="mockup-page" id="mockup-social" style="display: none;">
                    <div style="max-width: 900px; margin: 0 auto;">
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">💬 Social Feed</h1>

                        <!-- Create Post -->
                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <div style="display: flex; gap: 16px; align-items: flex-start;">
                                <div style="width: 48px; height: 48px; background: var(--primary); border-radius: 50%;"></div>
                                <div style="flex: 1;">
                                    <input type="text" class="input selectable" data-color-group="surface" placeholder="What's on your mind?" style="width: 100%; margin-bottom: 12px;">
                                    <div style="display: flex; gap: 8px; justify-content: flex-end;">
                                        <button class="btn btn-outline selectable" data-color-group="secondary">📷 Photo</button>
                                        <button class="btn btn-primary selectable" data-color-group="primary">Post</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Posts -->
                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <div style="display: flex; gap: 16px; margin-bottom: 16px;">
                                <div style="width: 48px; height: 48px; background: var(--accent); border-radius: 50%;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--scaffold-text);">Sarah Johnson</div>
                                    <div style="font-size: 12px; color: var(--scaffold-text-muted);">2 hours ago</div>
                                </div>
                                <span class="badge badge-primary selectable" data-color-group="primary">Following</span>
                            </div>
                            <p style="color: var(--scaffold-text); margin-bottom: 16px; line-height: 1.6;">
                                Just finished redesigning our app with OKLCH colors! The perceptual uniformity makes such a difference in creating harmonious interfaces. 🎨✨
                            </p>
                            <div style="display: flex; gap: 12px;">
                                <button class="btn btn-outline selectable" data-color-group="primary">👍 Like (24)</button>
                                <button class="btn btn-outline selectable" data-color-group="secondary">💬 Comment (8)</button>
                                <button class="btn btn-outline selectable" data-color-group="accent">🔄 Share</button>
                            </div>
                        </div>

                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <div style="display: flex; gap: 16px; margin-bottom: 16px;">
                                <div style="width: 48px; height: 48px; background: var(--secondary); border-radius: 50%;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--scaffold-text);">Mike Chen</div>
                                    <div style="font-size: 12px; color: var(--scaffold-text-muted);">5 hours ago</div>
                                </div>
                                <span class="badge badge-accent selectable" data-color-group="accent">Verified</span>
                            </div>
                            <p style="color: var(--scaffold-text); margin-bottom: 16px; line-height: 1.6;">
                                New blog post: "Understanding Color Accessibility in Modern Design" - Check it out! 📝
                            </p>
                            <div style="display: flex; gap: 12px;">
                                <button class="btn btn-outline selectable" data-color-group="primary">👍 Like (156)</button>
                                <button class="btn btn-outline selectable" data-color-group="secondary">💬 Comment (43)</button>
                                <button class="btn btn-outline selectable" data-color-group="accent">🔄 Share</button>
                            </div>
                        </div>

                        <div class="card selectable" data-color-group="surface">
                            <div style="display: flex; gap: 16px; margin-bottom: 16px;">
                                <div style="width: 48px; height: 48px; background: var(--primary); border-radius: 50%;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--scaffold-text);">Emma Wilson</div>
                                    <div style="font-size: 12px; color: var(--scaffold-text-muted);">1 day ago</div>
                                </div>
                            </div>
                            <p style="color: var(--scaffold-text); margin-bottom: 16px; line-height: 1.6;">
                                Looking for feedback on my latest design project. What do you all think? 🤔
                            </p>
                            <div style="display: flex; gap: 12px;">
                                <button class="btn btn-outline selectable" data-color-group="primary">👍 Like (89)</button>
                                <button class="btn btn-outline selectable" data-color-group="secondary">💬 Comment (27)</button>
                                <button class="btn btn-outline selectable" data-color-group="accent">🔄 Share</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ANALYTICS MOCKUP -->
                <div class="mockup-page" id="mockup-analytics" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text); margin-bottom: 32px;">📈 Analytics Dashboard</h1>

                        <!-- KPI Cards -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 24px; margin-bottom: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                    <div>
                                        <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Page Views</div>
                                        <div style="font-size: 36px; font-weight: 700; color: var(--scaffold-text);">1.2M</div>
                                    </div>
                                    <span class="badge badge-primary selectable" data-color-group="primary">+15%</span>
                                </div>
                                <div style="width: 100%; height: 60px; background: linear-gradient(to top, var(--primary) 0%, transparent 100%); border-radius: 4px;"></div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                    <div>
                                        <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Conversion Rate</div>
                                        <div style="font-size: 36px; font-weight: 700; color: var(--scaffold-text);">3.4%</div>
                                    </div>
                                    <span class="badge badge-accent selectable" data-color-group="accent">+8%</span>
                                </div>
                                <div style="width: 100%; height: 60px; background: linear-gradient(to top, var(--accent) 0%, transparent 100%); border-radius: 4px;"></div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                    <div>
                                        <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Bounce Rate</div>
                                        <div style="font-size: 36px; font-weight: 700; color: var(--scaffold-text);">42%</div>
                                    </div>
                                    <span class="badge badge-secondary selectable" data-color-group="secondary">-5%</span>
                                </div>
                                <div style="width: 100%; height: 60px; background: linear-gradient(to top, var(--secondary) 0%, transparent 100%); border-radius: 4px;"></div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                    <div>
                                        <div style="color: var(--scaffold-text-muted); font-size: 14px; margin-bottom: 8px;">Avg. Session</div>
                                        <div style="font-size: 36px; font-weight: 700; color: var(--scaffold-text);">4:32</div>
                                    </div>
                                    <span class="badge badge-primary selectable" data-color-group="primary">+12%</span>
                                </div>
                                <div style="width: 100%; height: 60px; background: linear-gradient(to top, var(--primary) 0%, transparent 100%); border-radius: 4px;"></div>
                            </div>
                        </div>

                        <!-- Traffic Sources -->
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 24px; margin-bottom: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 24px;">Traffic Sources</h3>
                                <div style="display: flex; flex-direction: column; gap: 16px;">
                                    <div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: var(--scaffold-text);">Organic Search</span>
                                            <span style="font-weight: 600; color: var(--scaffold-text);">45%</span>
                                        </div>
                                        <div style="width: 100%; height: 12px; background: var(--scaffold-bg); border-radius: 6px;">
                                            <div style="width: 45%; height: 100%; background: var(--primary); border-radius: 6px;"></div>
                                        </div>
                                    </div>
                                    <div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: var(--scaffold-text);">Direct</span>
                                            <span style="font-weight: 600; color: var(--scaffold-text);">30%</span>
                                        </div>
                                        <div style="width: 100%; height: 12px; background: var(--scaffold-bg); border-radius: 6px;">
                                            <div style="width: 30%; height: 100%; background: var(--accent); border-radius: 6px;"></div>
                                        </div>
                                    </div>
                                    <div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: var(--scaffold-text);">Social Media</span>
                                            <span style="font-weight: 600; color: var(--scaffold-text);">15%</span>
                                        </div>
                                        <div style="width: 100%; height: 12px; background: var(--scaffold-bg); border-radius: 6px;">
                                            <div style="width: 15%; height: 100%; background: var(--secondary); border-radius: 6px;"></div>
                                        </div>
                                    </div>
                                    <div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: var(--scaffold-text);">Referral</span>
                                            <span style="font-weight: 600; color: var(--scaffold-text);">10%</span>
                                        </div>
                                        <div style="width: 100%; height: 12px; background: var(--scaffold-bg); border-radius: 6px;">
                                            <div style="width: 10%; height: 100%; background: var(--primary); border-radius: 6px;"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="card selectable" data-color-group="surface">
                                <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Quick Actions</h3>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button class="btn btn-primary selectable" data-color-group="primary" style="width: 100%;">Export Report</button>
                                    <button class="btn btn-outline selectable" data-color-group="primary" style="width: 100%;">Schedule Report</button>
                                    <button class="btn btn-outline selectable" data-color-group="secondary" style="width: 100%;">Set Goals</button>
                                    <button class="btn btn-outline selectable" data-color-group="accent" style="width: 100%;">View Insights</button>
                                </div>
                            </div>
                        </div>

                        <!-- Top Pages -->
                        <div class="card selectable" data-color-group="surface">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Top Pages</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 2px solid var(--scaffold-border);">
                                        <th style="text-align: left; padding: 12px; color: var(--scaffold-text-muted);">Page</th>
                                        <th style="text-align: right; padding: 12px; color: var(--scaffold-text-muted);">Views</th>
                                        <th style="text-align: right; padding: 12px; color: var(--scaffold-text-muted);">Avg. Time</th>
                                        <th style="text-align: right; padding: 12px; color: var(--scaffold-text-muted);">Bounce</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr style="border-bottom: 1px solid var(--scaffold-border);">
                                        <td style="padding: 12px; color: var(--scaffold-text);">/home</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">245,891</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">3:24</td>
                                        <td style="text-align: right; padding: 12px;"><span class="badge badge-primary selectable" data-color-group="primary">38%</span></td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid var(--scaffold-border);">
                                        <td style="padding: 12px; color: var(--scaffold-text);">/products</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">128,456</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">5:18</td>
                                        <td style="text-align: right; padding: 12px;"><span class="badge badge-accent selectable" data-color-group="accent">25%</span></td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 12px; color: var(--scaffold-text);">/blog</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">87,234</td>
                                        <td style="text-align: right; padding: 12px; color: var(--scaffold-text);">6:42</td>
                                        <td style="text-align: right; padding: 12px;"><span class="badge badge-secondary selectable" data-color-group="secondary">45%</span></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- CRM MOCKUP -->
                <div class="mockup-page" id="mockup-crm" style="display: none;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px;">
                            <h1 style="font-size: 32px; font-weight: 700; color: var(--scaffold-text);">👥 CRM Dashboard</h1>
                            <button class="btn btn-primary selectable" data-color-group="primary">Add Contact</button>
                        </div>

                        <!-- Pipeline Stats -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 32px;">
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 12px; margin-bottom: 4px;">Leads</div>
                                <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">156</div>
                                <span class="badge badge-primary selectable" data-color-group="primary" style="margin-top: 8px;">+12 this week</span>
                            </div>
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 12px; margin-bottom: 4px;">Qualified</div>
                                <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">87</div>
                                <span class="badge badge-accent selectable" data-color-group="accent" style="margin-top: 8px;">+5 this week</span>
                            </div>
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 12px; margin-bottom: 4px;">Proposals</div>
                                <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">34</div>
                                <span class="badge badge-secondary selectable" data-color-group="secondary" style="margin-top: 8px;">+8 this week</span>
                            </div>
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 12px; margin-bottom: 4px;">Closed</div>
                                <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">23</div>
                                <span class="badge badge-primary selectable" data-color-group="primary" style="margin-top: 8px;">+3 this week</span>
                            </div>
                            <div class="card selectable" data-color-group="surface">
                                <div style="color: var(--scaffold-text-muted); font-size: 12px; margin-bottom: 4px;">Revenue</div>
                                <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">$125k</div>
                                <span class="badge badge-accent selectable" data-color-group="accent" style="margin-top: 8px;">+$45k this month</span>
                            </div>
                        </div>

                        <!-- Recent Contacts -->
                        <div class="card selectable" data-color-group="surface" style="margin-bottom: 24px;">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Recent Contacts</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                                        <div style="width: 48px; height: 48px; background: var(--primary); border-radius: 50%;"></div>
                                        <div style="flex: 1;">
                                            <div style="font-weight: 600; color: var(--scaffold-text);">Acme Corp</div>
                                            <div style="font-size: 12px; color: var(--scaffold-text-muted);">John Smith • CEO</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <span class="badge badge-accent selectable" data-color-group="accent">Hot Lead</span>
                                        <span class="badge badge-primary selectable" data-color-group="primary">Enterprise</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">Interested in enterprise plan. Follow up scheduled for next week.</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-primary selectable" data-color-group="primary" style="flex: 1;">Contact</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary">Edit</button>
                                    </div>
                                </div>

                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                                        <div style="width: 48px; height: 48px; background: var(--accent); border-radius: 50%;"></div>
                                        <div style="flex: 1;">
                                            <div style="font-weight: 600; color: var(--scaffold-text);">TechStart Inc</div>
                                            <div style="font-size: 12px; color: var(--scaffold-text-muted);">Sarah Lee • Founder</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <span class="badge badge-primary selectable" data-color-group="primary">Qualified</span>
                                        <span class="badge badge-accent selectable" data-color-group="accent">Startup</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">Requested demo. Great fit for our product suite.</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-primary selectable" data-color-group="primary" style="flex: 1;">Schedule</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary">Edit</button>
                                    </div>
                                </div>

                                <div style="padding: 16px; border: 1px solid var(--scaffold-border); border-radius: 8px;">
                                    <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                                        <div style="width: 48px; height: 48px; background: var(--secondary); border-radius: 50%;"></div>
                                        <div style="flex: 1;">
                                            <div style="font-weight: 600; color: var(--scaffold-text);">Global Systems</div>
                                            <div style="font-size: 12px; color: var(--scaffold-text-muted);">Mike Chen • CTO</div>
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <span class="badge badge-secondary selectable" data-color-group="secondary">Proposal Sent</span>
                                    </div>
                                    <p style="font-size: 14px; color: var(--scaffold-text-muted); margin-bottom: 12px;">Awaiting decision. Proposal sent 3 days ago.</p>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-primary selectable" data-color-group="primary" style="flex: 1;">Follow Up</button>
                                        <button class="btn btn-outline selectable" data-color-group="secondary">Edit</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Activity Feed -->
                        <div class="card selectable" data-color-group="surface">
                            <h3 style="font-size: 20px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 16px;">Recent Activity</h3>
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                                <div style="padding: 12px; background: var(--scaffold-bg); border-radius: 8px; border-left: 3px solid var(--primary);">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">New lead added</span>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">5 minutes ago</span>
                                    </div>
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">Jane Doe from Design Co inquired about pricing</span>
                                </div>
                                <div style="padding: 12px; background: var(--scaffold-bg); border-radius: 8px; border-left: 3px solid var(--accent);">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">Meeting scheduled</span>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">1 hour ago</span>
                                    </div>
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">Demo call with Acme Corp set for tomorrow at 2 PM</span>
                                </div>
                                <div style="padding: 12px; background: var(--scaffold-bg); border-radius: 8px; border-left: 3px solid var(--secondary);">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <span style="font-weight: 600; color: var(--scaffold-text);">Deal closed</span>
                                        <span style="font-size: 12px; color: var(--scaffold-text-muted);">3 hours ago</span>
                                    </div>
                                    <span style="font-size: 14px; color: var(--scaffold-text-muted);">TechStart Inc signed annual contract worth $25,000</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div> <!-- END mockup-view -->

        </div> <!-- END center-gallery -->
        </div> <!-- END studio-body -->
    </div> <!-- END studio -->

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // CURRENT COLOR STATE
        let currentGroup = 'primary';
        let currentColor = { l: 0.60, c: 0.18, h: 270 };
        let currentMode = 'light'; // 'light' or 'dark'

        // ========== UNIVERSAL SELECTION SYSTEM STATE ==========
        /**
         * Universal selection mode - null means color selection mode (default)
         * @type {null | 'color' | 'shape' | 'typography' | 'layout' | 'custom'}
         */
        let selectionMode = null;

        /**
         * Currently selected elements across all modes
         * @type {Set<HTMLElement>}
         */
        let selectedElements = new Set();

        /**
         * Original styles for selected elements (for reset functionality)
         * @type {Map<HTMLElement, Object>}
         */
        let originalStyles = new Map();

        /**
         * Custom groups created by user
         * @type {Map<string, Set<HTMLElement>>}
         */
        let customGroups = new Map();

        // ========== SELECTION OPERATIONS REGISTRY ==========
        /**
         * Registry of all available operations that can be applied to selected elements
         * Each operation defines its UI controls and apply function
         */
        const SELECTION_OPERATIONS = {
            color: {
                name: 'Color Group',
                icon: '🎨',
                controls: 'color-group-selector', // References a UI element ID
                apply: function(elements, colorGroup) {
                    elements.forEach(el => {
                        el.dataset.colorGroup = colorGroup;
                    });
                }
            },
            shape: {
                name: 'Shape Properties',
                icon: '📐',
                controls: 'shape-controls',
                properties: {
                    borderRadius: { min: 0, max: 50, unit: 'px', label: 'Border Radius' },
                    padding: { min: 0, max: 100, unit: 'px', label: 'Padding' },
                    margin: { min: 0, max: 100, unit: 'px', label: 'Margin' }
                },
                apply: function(elements, property, value) {
                    const config = this.properties[property];
                    elements.forEach(el => {
                        el.style[property] = `${value}${config.unit}`;
                    });
                }
            },
            typography: {
                name: 'Typography',
                icon: '✍️',
                properties: {
                    fontSize: { min: 8, max: 72, unit: 'px', label: 'Font Size' },
                    fontWeight: { min: 100, max: 900, step: 100, unit: '', label: 'Font Weight' },
                    lineHeight: { min: 1.0, max: 3.0, step: 0.1, unit: '', label: 'Line Height' },
                    letterSpacing: { min: -2, max: 10, unit: 'px', label: 'Letter Spacing' }
                },
                apply: function(elements, property, value) {
                    const config = this.properties[property];
                    elements.forEach(el => {
                        el.style[property] = value + config.unit;
                    });
                }
            },
            layout: {
                name: 'Layout',
                icon: '📦',
                properties: {
                    display: { options: ['block', 'inline-block', 'flex', 'grid', 'none'], label: 'Display' },
                    flexDirection: { options: ['row', 'column'], label: 'Flex Direction' },
                    gap: { min: 0, max: 100, unit: 'px', label: 'Gap' }
                },
                apply: function(elements, property, value) {
                    elements.forEach(el => {
                        el.style[property] = value;
                    });
                }
            },
            custom: {
                name: 'Custom Group',
                icon: '🏷️',
                apply: function(elements, groupName) {
                    if (!customGroups.has(groupName)) {
                        customGroups.set(groupName, new Set());
                    }
                    const group = customGroups.get(groupName);
                    elements.forEach(el => {
                        group.add(el);
                        el.dataset.customGroup = groupName;
                    });
                }
            }
        };

        // COLOR STORAGE FOR BOTH MODES (Counter-Weight System)
        let colorPalette = {
            light: {
                primary: { l: 0.60, c: 0.18, h: 270 },
                secondary: { l: 0.65, c: 0.15, h: 210 },
                accent: { l: 0.75, c: 0.15, h: 85 },
                background: { l: 0.98, c: 0.01, h: 270 },
                surface: { l: 1.00, c: 0.00, h: 270 },
                text: { l: 0.15, c: 0.02, h: 270 }
            },
            dark: {
                primary: { l: 0.65, c: 0.18, h: 270 },
                secondary: { l: 0.70, c: 0.15, h: 210 },
                accent: { l: 0.80, c: 0.15, h: 85 },
                background: { l: 0.15, c: 0.01, h: 270 },
                surface: { l: 0.18, c: 0.01, h: 270 },
                text: { l: 0.95, c: 0.01, h: 270 }
            }
        };

        // TRANSFORMATION TEMPLATES
        const transformationTemplates = {
            standard: {
                name: 'Standard Inversion',
                description: 'Simple lightness inversion',
                transform: (color, group) => {
                    if (group === 'background' || group === 'surface') {
                        return { l: 1.0 - color.l, c: color.c, h: color.h };
                    } else if (group === 'text') {
                        return { l: 1.0 - color.l, c: color.c * 0.5, h: color.h };
                    } else {
                        // Primary, Secondary, Accent: slight lightness boost in dark mode
                        return { l: Math.min(1.0, color.l + 0.05), c: color.c, h: color.h };
                    }
                }
            },
            perceptual: {
                name: 'Perceptual Balance',
                description: 'Maintains perceived brightness relationships',
                transform: (color, group) => {
                    if (group === 'background' || group === 'surface') {
                        // Deep inversion for backgrounds
                        return { l: 0.15 + (0.98 - color.l) * 0.05, c: color.c, h: color.h };
                    } else if (group === 'text') {
                        // Text needs high contrast
                        return { l: 0.95, c: color.c * 0.5, h: color.h };
                    } else {
                        // Colors get slightly lighter and more saturated
                        return {
                            l: Math.min(1.0, color.l + 0.10),
                            c: Math.min(0.37, color.c * 1.1),
                            h: color.h
                        };
                    }
                }
            },
            'high-contrast': {
                name: 'High Contrast (WCAG AAA)',
                description: 'Maximum contrast for accessibility',
                transform: (color, group) => {
                    if (group === 'background') {
                        return { l: 0.10, c: 0.01, h: color.h };
                    } else if (group === 'surface') {
                        return { l: 0.15, c: 0.01, h: color.h };
                    } else if (group === 'text') {
                        return { l: 1.00, c: 0.00, h: color.h };
                    } else {
                        // Ensure 7:1 contrast against dark background
                        return { l: Math.max(0.70, color.l), c: color.c, h: color.h };
                    }
                }
            },
            'muted-dark': {
                name: 'Muted Dark Mode',
                description: 'Lower chroma for comfortable viewing',
                transform: (color, group) => {
                    if (group === 'background' || group === 'surface') {
                        return { l: 1.0 - color.l, c: color.c * 0.5, h: color.h };
                    } else if (group === 'text') {
                        return { l: 0.90, c: 0.01, h: color.h };
                    } else {
                        // Reduce chroma for easier viewing
                        return {
                            l: Math.min(1.0, color.l + 0.05),
                            c: color.c * 0.7,
                            h: color.h
                        };
                    }
                }
            },
            'vibrant-dark': {
                name: 'Vibrant Dark Mode',
                description: 'Higher chroma for punchy colors',
                transform: (color, group) => {
                    if (group === 'background' || group === 'surface') {
                        return { l: 1.0 - color.l, c: color.c, h: color.h };
                    } else if (group === 'text') {
                        return { l: 0.95, c: color.c, h: color.h };
                    } else {
                        // Boost chroma for vibrant look
                        return {
                            l: Math.min(1.0, color.l + 0.10),
                            c: Math.min(0.37, color.c * 1.3),
                            h: color.h
                        };
                    }
                }
            }
        };

        let activeTemplate = 'standard';
        let templateAdjustments = {
            lightnessAdjust: 0,
            chromaAdjust: 0,
            maintainContrast: true
        };

        // ========== UNIVERSAL SELECTOR (Event Delegation Pattern) ==========

        /**
         * Initializes the universal selector system with multi-mode support
         * Supports: color (default), shape, typography, layout, custom groups
         *
         * @description EVENT DELEGATION: Single listener on document instead of individual listeners
         *              Reduces event listeners from ~52 to 1 (98% reduction!)
         *              Performance: Lower memory usage, faster DOM updates
         */
        function initUniversalSelector() {
            document.addEventListener('click', (e) => {
                // Find closest .selectable element (bubbling up)
                const element = e.target.closest('.selectable');
                if (!element) return;

                e.stopPropagation();

                // ========== MULTI-SELECT MODE (Any operation type) ==========
                if (selectionMode !== null) {
                    // Toggle element selection
                    if (selectedElements.has(element)) {
                        selectedElements.delete(element);
                        element.classList.remove('universal-selected');
                    } else {
                        selectedElements.add(element);
                        element.classList.add('universal-selected');

                        // Store original styles if not already stored
                        if (!originalStyles.has(element)) {
                            const computedStyle = getComputedStyle(element);
                            originalStyles.set(element, {
                                borderRadius: computedStyle.borderRadius,
                                padding: computedStyle.padding,
                                margin: computedStyle.margin,
                                fontSize: computedStyle.fontSize,
                                fontWeight: computedStyle.fontWeight,
                                lineHeight: computedStyle.lineHeight,
                                letterSpacing: computedStyle.letterSpacing,
                                display: computedStyle.display,
                                flexDirection: computedStyle.flexDirection,
                                gap: computedStyle.gap
                            });
                        }
                    }

                    // Update UI based on current selection mode
                    updateUniversalSelectionUI();
                    return;
                }

                // ========== DEFAULT MODE: Color selection behavior ==========
                // Remove previous selection
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));

                // Mark as selected
                element.classList.add('selected');

                // Get color group from element
                const group = element.dataset.colorGroup;
                if (group) {
                    selectColorGroup(group);
                }
            });
        }

        /**
         * Updates UI elements based on current selection mode and count
         * Shows/hides controls, updates selection count, enables/disables sliders
         */
        function updateUniversalSelectionUI() {
            const count = selectedElements.size;
            const mode = selectionMode;

            // Update selection count display (reuse existing shape UI for now)
            const countDisplay = document.getElementById('shape-selection-count');
            if (countDisplay) {
                const operation = SELECTION_OPERATIONS[mode];
                const icon = operation ? operation.icon : '📦';
                countDisplay.innerHTML = `<strong style="color: oklch(0.55 0.18 145);">${count}</strong> component${count !== 1 ? 's' : ''} selected ${icon} ${operation ? operation.name : 'Mode'}`;
            }

            // Enable/disable controls based on selection count
            const slider = document.getElementById('shape-border-radius');
            if (slider) {
                slider.disabled = count === 0;
                slider.style.cursor = count > 0 ? 'pointer' : 'not-allowed';
                slider.style.opacity = count > 0 ? '1' : '0.5';
            }

            // Announce to screen readers
            if (count > 0) {
                const operation = SELECTION_OPERATIONS[mode];
                const modeName = operation ? operation.name : 'operation';
                announceToScreenReader(`${count} component${count !== 1 ? 's' : ''} selected for ${modeName}`);
            }
        }

        /**
         * Selects a color group and updates all UI elements
         * @param {string} group - Color group name (primary, secondary, accent, background, surface, text, border, error, warning, success, info, muted)
         *
         * @description
         * - Reads current CSS variable value from :root
         * - Parses OKLCH values and updates currentColor state
         * - Updates all sliders to reflect current color
         * - Highlights active color group card
         * - Updates 3D viewer color point
         * - Announces selection to screen readers
         *
         * @example
         * selectColorGroup('primary'); // Selects primary color group
         */
        function selectColorGroup(group) {
            currentGroup = group;

            // Get current color value
            const root = document.documentElement;
            const colorValue = getComputedStyle(root).getPropertyValue(`--${group}`).trim();
            const match = colorValue.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);

            if (match) {
                currentColor.l = parseFloat(match[1]);
                currentColor.c = parseFloat(match[2]);
                currentColor.h = parseFloat(match[3]);

                // ========== INTEGRATED: Current Group Badge with Color Name ==========
                const colorName = getClosestColorName(currentColor);
                const groupDisplayName = getGroupDisplayName(group);
                document.getElementById('current-group').textContent = `${colorName} ${groupDisplayName}`;

                // Update sliders
                document.getElementById('current-l').value = currentColor.l * 100;
                document.getElementById('current-c').value = currentColor.c * 100;
                document.getElementById('current-h').value = currentColor.h;

                // Update value displays
                document.getElementById('current-l-val').textContent = currentColor.l.toFixed(2);
                document.getElementById('current-c-val').textContent = currentColor.c.toFixed(2);
                document.getElementById('current-h-val').textContent = currentColor.h.toFixed(0);

                // Update OKLCH code display FIRST with selected color and inverted text (instant)
                updateOklchCodeDisplay(currentColor.l, currentColor.c, currentColor.h);

                // Update color line display with exact currentColor values (instant)
                updateColorLineDisplay(currentColor.l, currentColor.c, currentColor.h);

                // Update spotlight accent colors
                updateSpotlightAccent();

                // Update scaffold theme (based on background lightness, not current selection)
                updateScaffoldTheme();

                // Update 3D viewer
                if (window.updateColorPoint) {
                    window.updateColorPoint(currentColor.l, currentColor.c, currentColor.h);
                }
            }

            // Highlight active group card
            document.querySelectorAll('.color-group-card').forEach(card => {
                card.classList.toggle('active', card.dataset.group === group);
            });

            // ========== INTEGRATED: Announce with color name to screen readers ==========
            const colorName = getClosestColorName(currentColor);
            const colorDesc = `${colorName} color selected. Lightness ${currentColor.l.toFixed(2)}, Chroma ${currentColor.c.toFixed(2)}, Hue ${currentColor.h.toFixed(0)}`;
            announceToScreenReader(`Selected ${group} color. ${colorDesc}`);
        }

        // ========== SHAPE CONTROLS SYSTEM ==========

        /**
         * Sets the current selection mode and updates UI accordingly
         * @param {null|'color'|'shape'|'typography'|'layout'|'custom'} mode - Selection mode to activate
         */
        function setSelectionMode(mode) {
            // Clear previous selections when switching modes
            if (selectionMode !== mode) {
                clearSelection();
            }

            selectionMode = mode;

            // Update button styles - highlight active mode
            document.querySelectorAll('.mode-selector-btn').forEach(btn => {
                const btnMode = btn.dataset.mode;
                if (btnMode === String(mode)) {
                    btn.style.background = 'oklch(0.55 0.18 145)';
                    btn.style.borderColor = 'oklch(0.55 0.18 145)';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'oklch(0.20 0.01 270)';
                    btn.style.borderColor = 'oklch(0.40 0.01 270)';
                    btn.style.color = 'oklch(0.80 0.01 270)';
                }
            });

            // Show/hide controls based on mode
            const shapeControls = document.getElementById('shape-controls');
            const typographyControls = document.getElementById('typography-controls');
            const layoutControls = document.getElementById('layout-controls');
            const customControls = document.getElementById('custom-controls');
            const selectionCount = document.getElementById('shape-selection-count');
            const selectionActions = document.getElementById('selection-actions');

            // Hide all controls first
            shapeControls.style.display = 'none';
            typographyControls.style.display = 'none';
            layoutControls.style.display = 'none';
            customControls.style.display = 'none';
            selectionCount.style.display = 'none';
            selectionActions.style.display = 'none';

            // Show controls for active mode
            if (mode !== null) {
                selectionCount.style.display = 'block';
                selectionActions.style.display = 'block';

                if (mode === 'shape') {
                    shapeControls.style.display = 'block';
                } else if (mode === 'typography') {
                    typographyControls.style.display = 'block';
                } else if (mode === 'layout') {
                    layoutControls.style.display = 'block';
                } else if (mode === 'custom') {
                    customControls.style.display = 'block';
                }

                const operation = SELECTION_OPERATIONS[mode];
                const modeLabel = operation ? operation.name : mode;
                showFloatingLog(`${operation?.icon || '🎯'} ${modeLabel} mode enabled - Click components to select`, 2500);
                announceToScreenReader(`${modeLabel} multi-select mode enabled. Click components to select them.`);
            } else {
                showFloatingLog('Selection mode disabled', 1500);
                announceToScreenReader('Selection mode disabled');
            }

            updateUniversalSelectionUI();
        }

        /**
         * Initializes all property sliders for universal selection system
         */
        function initPropertySliders() {
            // Shape properties
            initSlider('shape-border-radius', 'borderRadius', 'px');
            initSlider('shape-padding', 'padding', 'px');
            initSlider('shape-margin', 'margin', 'px');

            // Typography properties
            initSlider('typography-fontSize', 'fontSize', 'px');
            initSlider('typography-fontWeight', 'fontWeight', '');
            initSlider('typography-lineHeight', 'lineHeight', '');
            initSlider('typography-letterSpacing', 'letterSpacing', 'px');

            // Layout properties
            initSlider('layout-gap', 'gap', 'px');

            // Layout dropdowns
            initDropdown('layout-display', 'display');
            initDropdown('layout-flexDirection', 'flexDirection');
        }

        /**
         * Generic slider initializer for property control
         * @param {string} id - Slider element ID
         * @param {string} property - CSS property name
         * @param {string} unit - Unit suffix (px, em, etc)
         */
        function initSlider(id, property, unit) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id}-val`);
            if (!slider || !valueDisplay) return;

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                valueDisplay.textContent = `${value}${unit}`;

                // Apply property to all selected elements
                selectedElements.forEach(element => {
                    element.style[property] = `${value}${unit}`;
                });

                // Announce to screen readers (debounced)
                clearTimeout(window.propertyAnnouncerTimeout);
                window.propertyAnnouncerTimeout = setTimeout(() => {
                    announceToScreenReader(`${property} set to ${value}${unit} for ${selectedElements.size} components`);
                }, 500);
            });
        }

        /**
         * Generic dropdown initializer for property control
         * @param {string} id - Dropdown element ID
         * @param {string} property - CSS property name
         */
        function initDropdown(id, property) {
            const dropdown = document.getElementById(id);
            if (!dropdown) return;

            dropdown.addEventListener('change', () => {
                const value = dropdown.value;

                // Apply property to all selected elements
                selectedElements.forEach(element => {
                    element.style[property] = value;
                });

                announceToScreenReader(`${property} set to ${value} for ${selectedElements.size} components`);
            });
        }

        // Deprecated - keeping for backwards compatibility
        function initShapeBorderRadiusSlider() {
            const slider = document.getElementById('shape-border-radius');
            const valueDisplay = document.getElementById('shape-border-radius-val');

            slider.addEventListener('input', () => {
                const radiusValue = parseInt(slider.value);
                valueDisplay.textContent = `${radiusValue}px`;

                // Apply border-radius to all selected elements
                selectedElements.forEach(element => {
                    element.style.borderRadius = `${radiusValue}px`;
                });

                // Announce to screen readers (debounced)
                clearTimeout(window.shapeRadiusAnnouncerTimeout);
                window.shapeRadiusAnnouncerTimeout = setTimeout(() => {
                    announceToScreenReader(`Border radius set to ${radiusValue} pixels for ${selectedElements.size} components`);
                }, 500);
            });

            // Touch event support for mobile
            let touchStartX = 0;
            let touchStartValue = 0;

            slider.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartValue = parseInt(slider.value);
                e.preventDefault();
            }, { passive: false });

            slider.addEventListener('touchmove', (e) => {
                const touchX = e.touches[0].clientX;
                const deltaX = touchX - touchStartX;
                const sliderRect = slider.getBoundingClientRect();
                const sliderWidth = sliderRect.width;

                const range = 50; // max - min
                const deltaValue = (deltaX / sliderWidth) * range;
                let newValue = touchStartValue + deltaValue;
                newValue = Math.max(0, Math.min(50, Math.round(newValue)));

                slider.value = newValue;
                valueDisplay.textContent = `${newValue}px`;

                // Apply border-radius to all selected elements
                shapeSelectedElements.forEach(element => {
                    element.style.borderRadius = `${newValue}px`;
                });

                e.preventDefault();
            }, { passive: false });
        }

        /**
         * Clears all selected elements and resets selection state
         */
        function clearSelection() {
            // Remove universal-selected class from all elements
            selectedElements.forEach(element => {
                element.classList.remove('universal-selected');
                // Also remove old class for backwards compatibility
                element.classList.remove('shape-selected');
            });

            // Clear the set
            selectedElements.clear();

            // Update UI
            updateUniversalSelectionUI();

            showFloatingLog('🔲 Selection cleared', 1500);
            announceToScreenReader('Selection cleared');
        }

        /**
         * Resets all styles for selected elements to their original values
         */
        function resetStyles() {
            const count = selectedElements.size;

            // Reset all properties for all selected elements to their original values
            selectedElements.forEach(element => {
                const original = originalStyles.get(element);
                if (original) {
                    // Restore all stored properties
                    Object.keys(original).forEach(prop => {
                        element.style[prop] = original[prop];
                    });
                }
            });

            showFloatingLog(`↩️ Styles reset to original for ${count} component${count !== 1 ? 's' : ''}`, 2000);
            announceToScreenReader(`Styles reset to original values for ${count} components`);
        }

        /**
         * Saves currently selected elements as a named custom group
         */
        function saveCustomGroup() {
            const nameInput = document.getElementById('custom-group-name');
            const groupName = nameInput.value.trim();

            if (!groupName) {
                showFloatingLog('⚠️ Please enter a group name', 2000, 'warning');
                return;
            }

            if (selectedElements.size === 0) {
                showFloatingLog('⚠️ No elements selected', 2000, 'warning');
                return;
            }

            // Save group
            customGroups.set(groupName, new Set(selectedElements));

            showFloatingLog(`✅ Custom group "${groupName}" saved with ${selectedElements.size} components`, 2500, 'success');
            announceToScreenReader(`Custom group ${groupName} saved with ${selectedElements.size} components`);

            // Clear input
            nameInput.value = '';
        }

        // Deprecated - keeping for backwards compatibility
        function clearShapeSelection() {
            clearSelection();
        }

        // Deprecated - keeping for backwards compatibility
        function resetShapeRadius() {
            resetStyles();
        }

        // Make functions globally accessible
        window.setSelectionMode = setSelectionMode;
        window.clearSelection = clearSelection;
        window.resetStyles = resetStyles;
        window.saveCustomGroup = saveCustomGroup;
        // Deprecated - backwards compatibility
        window.toggleShapeMode = () => setSelectionMode(selectionMode === null ? 'shape' : null);
        window.clearShapeSelection = clearSelection;
        window.resetShapeRadius = resetStyles;

        // ========== MEMOIZATION SYSTEM ==========

        /**
         * LRU Cache-based memoization wrapper for expensive functions
         * Provides 10x+ performance boost for repeated calculations
         */
        class MemoCache {
            constructor(maxSize = 1000) {
                this.cache = new Map();
                this.maxSize = maxSize;
            }

            generateKey(...args) {
                // Generate unique cache key from arguments
                return JSON.stringify(args);
            }

            get(key) {
                if (!this.cache.has(key)) return undefined;

                // LRU: Move to end (most recently used)
                const value = this.cache.get(key);
                this.cache.delete(key);
                this.cache.set(key, value);
                return value;
            }

            set(key, value) {
                // Remove oldest entry if cache is full (LRU eviction)
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                this.cache.set(key, value);
            }

            clear() {
                this.cache.clear();
            }

            get size() {
                return this.cache.size;
            }
        }

        /**
         * Memoize function with automatic caching
         * @param {Function} fn - Function to memoize
         * @param {Number} maxSize - Maximum cache size (default: 1000)
         */
        function memoize(fn, maxSize = 1000) {
            const cache = new MemoCache(maxSize);

            const memoized = function(...args) {
                const key = cache.generateKey(...args);
                const cached = cache.get(key);

                if (cached !== undefined) {
                    return cached;
                }

                // Calculate and cache result
                const result = fn.apply(this, args);
                cache.set(key, result);
                return result;
            };

            // Expose cache for debugging/monitoring
            memoized.cache = cache;
            memoized.clearCache = () => cache.clear();

            return memoized;
        }

        // ========== INPUT SANITIZATION SYSTEM ==========

        function sanitizeNumber(value, min, max, defaultValue = min) {
            const num = parseFloat(value);

            // Check if valid number
            if (isNaN(num) || !isFinite(num)) {
                return defaultValue;
            }

            // Clamp to range
            return Math.max(min, Math.min(max, num));
        }

        // DEBOUNCE UTILITY - Delays function execution until after specified wait time
        function debounce(func, wait = 100) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function sanitizeColorValue(colorObj) {
            // Sanitize OKLCH color object
            return {
                l: sanitizeNumber(colorObj.l, 0, 1, 0.5),
                c: sanitizeNumber(colorObj.c, 0, 0.37, 0.1),
                h: sanitizeNumber(colorObj.h, 0, 360, 270)
            };
        }

        function sanitizeString(str, maxLength = 1000) {
            if (typeof str !== 'string') return '';

            // Remove potentially dangerous characters
            const cleaned = str
                .slice(0, maxLength)
                .replace(/[<>\"'&]/g, '') // Remove HTML special chars
                .replace(/javascript:/gi, '') // Remove javascript: protocol
                .replace(/on\w+=/gi, ''); // Remove event handlers

            return cleaned;
        }

        function sanitizeJSON(jsonStr) {
            try {
                const parsed = JSON.parse(jsonStr);

                // Validate it's an object
                if (typeof parsed !== 'object' || parsed === null) {
                    throw new Error('Invalid JSON structure');
                }

                return parsed;
            } catch (e) {
                console.error('JSON sanitization failed:', e);
                return null;
            }
        }

        function validatePaletteData(data) {
            // Validate palette structure
            if (!data || typeof data !== 'object') return false;

            const requiredModes = ['light', 'dark'];
            const requiredGroups = ['primary', 'secondary', 'accent', 'background', 'surface', 'text'];

            for (const mode of requiredModes) {
                if (!data[mode] || typeof data[mode] !== 'object') return false;

                for (const group of requiredGroups) {
                    const color = data[mode][group];
                    if (!color || typeof color !== 'object') return false;

                    // Validate color values
                    if (typeof color.l !== 'number' ||
                        typeof color.c !== 'number' ||
                        typeof color.h !== 'number') {
                        return false;
                    }

                    // Sanitize color values in place
                    data[mode][group] = sanitizeColorValue(color);
                }
            }

            return true;
        }

        // ========== OKLCH SLIDERS ==========

        function initSliders() {
            const sliders = ['l', 'c', 'h'];

            sliders.forEach(component => {
                const slider = document.getElementById(`current-${component}`);
                const valueDisplay = document.getElementById(`current-${component}-val`);

                // HEAVY OPERATIONS - Debounced to 100ms for performance
                const performHeavyOperations = debounce((finalColor, displayValue) => {
                    // ⚖️ AUTO-COUNTER-WEIGHT SYSTEM: Real-time bidirectional sync
                    const compliantColor = enforceComplianceAndSync(finalColor, currentGroup);
                    const finalColorStr = `oklch(${compliantColor.l.toFixed(2)} ${compliantColor.c.toFixed(2)} ${compliantColor.h})`;

                    // Apply compliance-adjusted color
                    document.documentElement.style.setProperty(`--${currentGroup}`, finalColorStr);

                    // Update current color with compliance-adjusted values
                    currentColor.l = compliantColor.l;
                    currentColor.c = compliantColor.c;
                    currentColor.h = compliantColor.h;

                    // Update OKLCH code display with compliant color
                    updateOklchCodeDisplay(compliantColor.l, compliantColor.c, compliantColor.h);

                    // Update color line display with compliant color
                    updateColorLineDisplay(compliantColor.l, compliantColor.c, compliantColor.h);

                    // Update spotlight accent colors
                    updateSpotlightAccent();

                    // Update scaffold theme (based on background lightness, not current selection)
                    updateScaffoldTheme();

                    // Update 3D viewer (heavy operation)
                    if (window.updateColorPoint) {
                        window.updateColorPoint(compliantColor.l, compliantColor.c, compliantColor.h);
                    }

                    // Update safe zone (heavy operation)
                    updateSafeZone();

                    // Update URL with new palette (already debounced)
                    scheduleURLUpdate();

                    // Announce color change to screen readers (debounced)
                    clearTimeout(window.colorChangeAnnouncerTimeout);
                    window.colorChangeAnnouncerTimeout = setTimeout(() => {
                        const componentName = component === 'l' ? 'Lightness' : component === 'c' ? 'Chroma' : 'Hue';
                        announceToScreenReader(`${currentGroup} ${componentName} adjusted to ${displayValue}`);
                    }, 500);

                    // ========== INTEGRATED: Update all color names after slider adjustment ==========
                    updateAllColorNames();
                }, 100); // 100ms debounce for heavy operations

                // Shared update function for both input and touch events
                const updateSliderValue = () => {
                    let value = parseFloat(slider.value);

                    // Sanitize input based on component type
                    if (component === 'l') {
                        value = sanitizeNumber(value, 0, 100, 60);
                    } else if (component === 'c') {
                        value = sanitizeNumber(value, 0, 37, 18);
                    } else if (component === 'h') {
                        value = sanitizeNumber(value, 0, 360, 270);
                    }

                    let displayValue;
                    if (component === 'l' || component === 'c') {
                        displayValue = (value / 100).toFixed(2);
                        value = value / 100;
                    } else {
                        displayValue = value;
                    }

                    // INSTANT VISUAL FEEDBACK (0ms delay)
                    valueDisplay.textContent = displayValue;

                    // Create preview color for instant feedback
                    const previewColor = {
                        l: component === 'l' ? value : currentColor.l,
                        c: component === 'c' ? value : currentColor.c,
                        h: component === 'h' ? value : currentColor.h
                    };

                    // Update OKLCH display INSTANTLY with preview color
                    updateOklchCodeDisplay(previewColor.l, previewColor.c, previewColor.h);
                    updateColorLineDisplay(previewColor.l, previewColor.c, previewColor.h);

                    // Apply preview color to CSS variable INSTANTLY
                    const previewColorStr = `oklch(${previewColor.l.toFixed(2)} ${previewColor.c.toFixed(2)} ${previewColor.h})`;
                    document.documentElement.style.setProperty(`--${currentGroup}`, previewColorStr);

                    // Update current color
                    currentColor[component] = value;

                    // DEBOUNCED HEAVY OPERATIONS (100ms delay)
                    performHeavyOperations(previewColor, displayValue);
                };

                // Standard input event
                slider.addEventListener('input', updateSliderValue);

                // Touch event support for mobile
                let touchStartX = 0;
                let touchStartValue = 0;

                slider.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartValue = parseFloat(slider.value);
                    e.preventDefault(); // Prevent scrolling while dragging slider
                }, { passive: false });

                slider.addEventListener('touchmove', (e) => {
                    const touchX = e.touches[0].clientX;
                    const deltaX = touchX - touchStartX;
                    const sliderRect = slider.getBoundingClientRect();
                    const sliderWidth = sliderRect.width;
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const range = max - min;

                    // Calculate new value based on touch movement
                    const deltaValue = (deltaX / sliderWidth) * range;
                    let newValue = touchStartValue + deltaValue;

                    // Clamp to min/max
                    newValue = Math.max(min, Math.min(max, newValue));

                    slider.value = newValue;
                    updateSliderValue();

                    e.preventDefault(); // Prevent scrolling
                }, { passive: false });

                slider.addEventListener('touchend', (e) => {
                    e.preventDefault();
                }, { passive: false });
            });
        }

        // ========== 2D PICKERS (REAL COMPONENTS) ==========

        function init2DPickers() {
            // HUE WHEEL - Full interactive circular selector
            const hueCanvas = document.getElementById('hue-wheel');
            const hueCtx = hueCanvas.getContext('2d');

            // RESPONSIVE: Calculate canvas size based on sidebar width
            const sidebar = document.querySelector('.left-sidebar');
            const gridItem = hueCanvas.closest('.widget-grid-item');
            const canvasSize = Math.min(gridItem ? gridItem.offsetWidth - 40 : 160, 240);
            hueCanvas.width = canvasSize;
            hueCanvas.height = canvasSize;

            const hueSize = hueCanvas.width;
            const hueCenter = hueSize / 2;
            const hueRadius = hueSize / 2 - 10;

            let isDraggingHue = false;

            function drawHueWheel() {
                hueCtx.clearRect(0, 0, hueSize, hueSize);

                // Draw full hue spectrum circle
                for (let angle = 0; angle < 360; angle += 1) {
                    const startAngle = (angle - 90) * Math.PI / 180;
                    const endAngle = (angle + 1 - 90) * Math.PI / 180;

                    hueCtx.beginPath();
                    hueCtx.moveTo(hueCenter, hueCenter);
                    hueCtx.arc(hueCenter, hueCenter, hueRadius, startAngle, endAngle);
                    hueCtx.closePath();
                    hueCtx.fillStyle = `oklch(${currentColor.l} ${currentColor.c} ${angle})`;
                    hueCtx.fill();
                }

                // Draw white center circle
                hueCtx.beginPath();
                hueCtx.arc(hueCenter, hueCenter, hueRadius * 0.3, 0, Math.PI * 2);
                hueCtx.fillStyle = 'oklch(1 0 0)';
                hueCtx.fill();

                // Draw selected hue indicator
                const selectedAngle = (currentColor.h - 90) * Math.PI / 180;
                const indicatorX = hueCenter + Math.cos(selectedAngle) * hueRadius * 0.65;
                const indicatorY = hueCenter + Math.sin(selectedAngle) * hueRadius * 0.65;

                hueCtx.beginPath();
                hueCtx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
                hueCtx.fillStyle = 'white';
                hueCtx.strokeStyle = 'black';
                hueCtx.lineWidth = 2;
                hueCtx.fill();
                hueCtx.stroke();
            }

            function getHueFromPosition(x, y) {
                const rect = hueCanvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;

                const dx = canvasX - hueCenter;
                const dy = canvasY - hueCenter;

                let angle = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                if (angle < 0) angle += 360;

                return Math.round(angle) % 360;
            }

            hueCanvas.addEventListener('mousedown', (e) => {
                isDraggingHue = true;
                const hue = getHueFromPosition(e.clientX, e.clientY);
                currentColor.h = hue;
                document.getElementById('current-h').value = hue;
                document.getElementById('current-h').dispatchEvent(new Event('input'));
                drawHueWheel();
            });

            hueCanvas.addEventListener('mousemove', (e) => {
                if (isDraggingHue) {
                    const hue = getHueFromPosition(e.clientX, e.clientY);
                    currentColor.h = hue;
                    document.getElementById('current-h').value = hue;
                    document.getElementById('current-h').dispatchEvent(new Event('input'));
                    drawHueWheel();
                }
            });

            hueCanvas.addEventListener('mouseup', () => { isDraggingHue = false; });
            hueCanvas.addEventListener('mouseleave', () => { isDraggingHue = false; });

            // CHROMA × LIGHTNESS - 2D gradient selector
            const clCanvas = document.getElementById('chroma-lightness');
            const clCtx = clCanvas.getContext('2d');

            // RESPONSIVE: Calculate canvas size based on sidebar width
            const clGridItem = clCanvas.closest('.widget-grid-item');
            const clCanvasSize = Math.min(clGridItem ? clGridItem.offsetWidth - 40 : 160, 240);
            clCanvas.width = clCanvasSize;
            clCanvas.height = clCanvasSize;

            const clSize = clCanvas.width;

            let isDraggingCL = false;

            function drawChromaLightness() {
                const imageData = clCtx.createImageData(clSize, clSize);

                for (let y = 0; y < clSize; y++) {
                    for (let x = 0; x < clSize; x++) {
                        const l = 1 - (y / clSize); // top = 1, bottom = 0
                        const c = (x / clSize) * 0.37; // left = 0, right = 0.37

                        const rgb = oklchToRgb(l, c, currentColor.h);
                        const idx = (y * clSize + x) * 4;
                        imageData.data[idx] = rgb[0];
                        imageData.data[idx + 1] = rgb[1];
                        imageData.data[idx + 2] = rgb[2];
                        imageData.data[idx + 3] = 255;
                    }
                }

                clCtx.putImageData(imageData, 0, 0);

                // Draw crosshair for current selection
                const crossX = (currentColor.c / 0.37) * clSize;
                const crossY = (1 - currentColor.l) * clSize;

                clCtx.strokeStyle = 'white';
                clCtx.lineWidth = 2;
                clCtx.beginPath();
                clCtx.moveTo(crossX - 10, crossY);
                clCtx.lineTo(crossX + 10, crossY);
                clCtx.moveTo(crossX, crossY - 10);
                clCtx.lineTo(crossX, crossY + 10);
                clCtx.stroke();

                clCtx.strokeStyle = 'black';
                clCtx.lineWidth = 1;
                clCtx.beginPath();
                clCtx.arc(crossX, crossY, 8, 0, Math.PI * 2);
                clCtx.stroke();
            }

            function getCLFromPosition(x, y) {
                const rect = clCanvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;

                const l = Math.max(0, Math.min(1, 1 - (canvasY / clSize)));
                const c = Math.max(0, Math.min(0.37, (canvasX / clSize) * 0.37));

                return { l, c };
            }

            clCanvas.addEventListener('mousedown', (e) => {
                isDraggingCL = true;
                const { l, c } = getCLFromPosition(e.clientX, e.clientY);
                currentColor.l = l;
                currentColor.c = c;
                document.getElementById('current-l').value = l * 100;
                document.getElementById('current-c').value = c * 100;
                document.getElementById('current-l').dispatchEvent(new Event('input'));
                drawChromaLightness();
            });

            clCanvas.addEventListener('mousemove', (e) => {
                if (isDraggingCL) {
                    const { l, c } = getCLFromPosition(e.clientX, e.clientY);
                    currentColor.l = l;
                    currentColor.c = c;
                    document.getElementById('current-l').value = l * 100;
                    document.getElementById('current-c').value = c * 100;
                    document.getElementById('current-l').dispatchEvent(new Event('input'));
                    drawChromaLightness();
                }
            });

            clCanvas.addEventListener('mouseup', () => { isDraggingCL = false; });
            clCanvas.addEventListener('mouseleave', () => { isDraggingCL = false; });

            // Store draw functions for updates
            window.drawHueWheel = drawHueWheel;
            window.drawChromaLightness = drawChromaLightness;

            // Initial draw
            drawHueWheel();
            drawChromaLightness();
        }

        // ========== TOGGLE 2D PICKERS ==========

        function init2DPickerToggles() {
            const hueToggle = document.getElementById('toggle-hue-wheel');
            const hueContainer = document.getElementById('hue-wheel-container');
            const clToggle = document.getElementById('toggle-chroma-lightness');
            const clContainer = document.getElementById('chroma-lightness-container');

            // Load saved state from localStorage
            const hueVisible = localStorage.getItem('hue-wheel-visible') !== 'false';
            const clVisible = localStorage.getItem('chroma-lightness-visible') !== 'false';

            // Apply saved state
            if (hueToggle && hueContainer) {
                hueToggle.checked = hueVisible;
                hueContainer.style.display = hueVisible ? 'flex' : 'none';

                hueToggle.addEventListener('change', (e) => {
                    const isVisible = e.target.checked;
                    hueContainer.style.display = isVisible ? 'flex' : 'none';
                    localStorage.setItem('hue-wheel-visible', isVisible);
                });
            }

            if (clToggle && clContainer) {
                clToggle.checked = clVisible;
                clContainer.style.display = clVisible ? 'flex' : 'none';

                clToggle.addEventListener('change', (e) => {
                    const isVisible = e.target.checked;
                    clContainer.style.display = isVisible ? 'flex' : 'none';
                    localStorage.setItem('chroma-lightness-visible', isVisible);
                });
            }
        }

        /**
         * Converts OKLCH color to RGB (simplified approximation)
         * @param {number} l - Lightness (0-1)
         * @param {number} c - Chroma (0-0.37)
         * @param {number} h - Hue (0-360 degrees)
         * @returns {Array<number>} RGB values [r, g, b] (0-255)
         *
         * @description
         * Simplified OKLCH→RGB conversion for 3D visualization.
         * Uses polar→cartesian conversion (LCH→Lab) and approximate Lab→RGB matrix.
         * For production-grade conversion, use culori library (see init3DViewer).
         *
         * Conversion pipeline:
         * 1. LCH→Lab: a = c*cos(h), b = c*sin(h)
         * 2. Lab→RGB: Approximate matrix multiplication
         * 3. Clamping to valid RGB range (0-255)
         *
         * @example
         * const [r, g, b] = oklchToRgb(0.65, 0.18, 270); // Purple color
         * // Returns approximately [120, 140, 200]
         */
        function oklchToRgb(l, c, h) {
            const a = c * Math.cos(h * Math.PI / 180);
            const b = c * Math.sin(h * Math.PI / 180);
            const r = Math.max(0, Math.min(255, Math.round((l + 0.3 * a) * 255)));
            const g = Math.max(0, Math.min(255, Math.round((l - 0.15 * a - 0.2 * b) * 255)));
            const bb = Math.max(0, Math.min(255, Math.round((l + 0.5 * b) * 255)));
            return [r, g, bb];
        }

        // ========== 3D OKLCH VIEWER (EVIL MARTIANS ALGORITHM) ==========

        async function init3DViewer() {
            try {
                // Import Delaunator for triangulation
                const delaunatorModule = await import('https://cdn.jsdelivr.net/npm/delaunator@5.0.1/+esm');
                const Delaunator = delaunatorModule.default || delaunatorModule.Delaunator || delaunatorModule;

                // Import culori for OKLCH conversions
                const culoriModule = await import('https://cdn.jsdelivr.net/npm/culori@3.3.0/+esm');
                const { converter } = culoriModule;
                const toOklch = converter('oklch');
                const toRgb = converter('rgb');

                const L_MAX_COLOR = 1;
                const C_MAX = 0.37;

                const container = document.getElementById('oklch-3d-viewer');
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f0f12);

                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0.79, 0, 0.79);
                camera.lookAt(new THREE.Vector3(0, 1, 0));

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enablePan = true;
                controls.enableZoom = false; // Disabled by default - scrolling scrolls sidebar
                controls.minDistance = 0.9;
                controls.maxDistance = 3;

                // Zoom toggle state
                let zoomEnabled = false;

                // Prevent scroll zoom by default - allow sidebar scrolling
                renderer.domElement.addEventListener('wheel', (e) => {
                    if (!zoomEnabled) {
                        e.stopPropagation(); // Don't let Three.js handle it
                        // Let the event bubble up to scroll the sidebar
                    }
                }, { passive: true });

                // Right-click context menu to toggle zoom
                renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();

                    zoomEnabled = !zoomEnabled;
                    controls.enableZoom = zoomEnabled;

                    // Visual feedback
                    if (zoomEnabled) {
                        renderer.domElement.style.outline = '3px solid oklch(0.65 0.18 270)';
                        renderer.domElement.style.outlineOffset = '-3px';
                        showFloatingLog('🔍 3D Zoom: ON (scroll to zoom)', 2000);
                    } else {
                        renderer.domElement.style.outline = 'none';
                        showFloatingLog('🔍 3D Zoom: OFF (scroll moves sidebar)', 2000);
                    }
                });

                // Evil Martians' gamut edge detection
                function onGamutEdge(r, g, b) {
                    return r === 0 || g === 0 || b === 0 || r > 0.99 || g > 0.99 || b > 0.99;
                }

                // Sample RGB cube edges and convert to OKLCH
                function getModelData() {
                    let coordinates = [];
                    let colors = [];

                    // Sample RGB cube edges (coarser sampling for performance)
                    for (let x = 0; x <= 1; x += 0.1) {
                        for (let y = 0; y <= 1; y += 0.1) {
                            for (let z = 0; z <= 1; z += 0.1) {
                                if (onGamutEdge(x, y, z)) {
                                    let edgeRgb = { mode: 'rgb', r: x, g: y, b: z };
                                    let to = toOklch(edgeRgb);
                                    if (to.h !== undefined) {
                                        colors.push(edgeRgb.r, edgeRgb.g, edgeRgb.b);
                                        coordinates.push(new THREE.Vector3(
                                            to.l / L_MAX_COLOR,
                                            to.c / (C_MAX * 2),
                                            to.h / 360
                                        ));
                                    }
                                }
                            }
                        }
                    }

                    // Add bounds
                    let bounds = [[0,0,0],[0,0,1],[1,0,0],[1,1,0],[1,0,1],[1,0,1],[1,1,1]];
                    for (let i of bounds) {
                        coordinates.push(new THREE.Vector3(...i));
                        colors.push(i[0], i[0], i[0]);
                    }

                    return [coordinates, colors];
                }

                // Generate mesh with Delaunator triangulation
                function generateMesh(scene) {
                    scene.clear();
                    let [coordinates, colors] = getModelData();

                    let top = new THREE.BufferGeometry().setFromPoints(coordinates);
                    top.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    top.center();

                    // Delaunator triangulation (Evil Martians' exact algorithm)
                    const points2D = coordinates.map(c => [c.x, c.z]);
                    const delaunay = Delaunator.from(points2D);
                    top.setIndex(Array.from(delaunay.triangles));
                    top.computeVertexNormals();

                    let material = new THREE.MeshBasicMaterial({
                        side: THREE.DoubleSide,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.8
                    });

                    // Slicing planes uniforms
                    let l = new THREE.Vector2(0, 1);
                    let c = new THREE.Vector2(0, 1);
                    let h = new THREE.Vector2(0, 1);

                    // GLSL shader for slicing planes
                    material.onBeforeCompile = shader => {
                        shader.uniforms.sliceL = { value: l };
                        shader.uniforms.sliceC = { value: c };
                        shader.uniforms.sliceH = { value: h };

                        shader.vertexShader = `varying vec3 vPos;\n${shader.vertexShader}`.replace(
                            `#include <begin_vertex>`,
                            `#include <begin_vertex>\nvPos = transformed;`
                        );

                        shader.fragmentShader = `#define ss(a, b, c) smoothstep(a, b, c)\nuniform vec2 sliceL, sliceC, sliceH;\nvarying vec3 vPos;\n${shader.fragmentShader}`.replace(
                            `#include <dithering_fragment>`,
                            `#include <dithering_fragment>
vec3 col = vec3(0.5, 0.5, 0.5);
float width = 0.0025;
float lSlice = ss(width, 0., abs(vPos.x + sliceL.y));
float cSlice = ss(width, 0., abs(vPos.y + sliceC.y));
float hSlice = ss(width, 0., abs(vPos.z - sliceH.y));
gl_FragColor.rgb = mix(gl_FragColor.rgb, col, lSlice);
gl_FragColor.rgb = mix(gl_FragColor.rgb, col, cSlice);
gl_FragColor.rgb = mix(gl_FragColor.rgb, col, hSlice);`
                        );
                    };

                    let topMesh = new THREE.Mesh(top, material);
                    topMesh.translateY(0.3);
                    scene.add(topMesh);

                    // Bottom lightness gradient plane
                    let bottom = new THREE.PlaneGeometry(1, 1, 1, 20);
                    let bottomColors = [];
                    let bottomSteps = bottom.attributes.position.array.length / 6;
                    for (let i = 0; i <= bottomSteps; i += 1) {
                        let lchL = (L_MAX_COLOR * i) / bottomSteps;
                        let rgbL = toRgb({ mode: 'oklch', l: lchL, c: 0, h: 0 }).r;
                        bottomColors.push(rgbL, rgbL, rgbL, rgbL, rgbL, rgbL);
                    }
                    bottom.setAttribute('color', new THREE.Float32BufferAttribute(bottomColors, 3));
                    bottom.translate(0, 0, -0.2);
                    bottom.rotateZ(Math.PI * 0.5);
                    bottom.rotateX(-Math.PI * 0.5);
                    let bottomMesh = new THREE.Mesh(bottom, material);
                    scene.add(bottomMesh);

                    // Return update function for slicing planes
                    return color => {
                        l.set(0, -color.l + 0.5);
                        c.set(0, (0.5 * -color.c) / C_MAX + 0.5);
                        h.set(0, 0.0028 * color.h - (color.h > 350 ? 0.51 : 0.5));
                    };
                }

                const updateSlices = generateMesh(scene);

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                // Global update function for current color
                window.updateColorPoint = (l, c, h) => {
                    updateSlices({ l, c, h });
                };

                console.log('✅ 3D OKLCH viewer loaded (Evil Martians algorithm)');

            } catch (error) {
                console.error('❌ 3D viewer failed to load:', error);
                // Fallback: show error message in container
                const container = document.getElementById('oklch-3d-viewer');
                container.innerHTML = `<div style="color: #ff6b6b; padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                    <div>3D Viewer failed to load</div>
                    <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">${error.message}</div>
                </div>`;
            }
        }

        // ========== SAFE ZONE ==========

        function updateSafeZone() {
            const root = document.documentElement;
            const background = getComputedStyle(root).getPropertyValue('--background');
            const text = getComputedStyle(root).getPropertyValue('--text');
            const primary = getComputedStyle(root).getPropertyValue('--primary');

            const textContrast = calculateContrast(background, text);
            const primaryContrast = calculateContrast(background, primary);

            // Calculate APCA values
            const bgMatch = background.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            const textMatch = text.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            const primaryMatch = primary.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);

            let textAPCA = 0;
            let primaryAPCA = 0;

            if (bgMatch && textMatch) {
                const bgColor = { l: parseFloat(bgMatch[1]) };
                const textColor = { l: parseFloat(textMatch[1]) };
                textAPCA = calculateAPCA(textColor, bgColor);
            }

            if (bgMatch && primaryMatch) {
                const bgColor = { l: parseFloat(bgMatch[1]) };
                const primaryColor = { l: parseFloat(primaryMatch[1]) };
                primaryAPCA = calculateAPCA(primaryColor, bgColor);
            }

            const safeZone = document.getElementById('safe-zone');
            const details = document.getElementById('safe-zone-details');

            // Get compliance settings
            const wcagEnforced = !document.getElementById('allow-wcag-violation')?.checked;
            const apcaEnforced = !document.getElementById('allow-apca-violation')?.checked;
            const maxReadEnabled = document.getElementById('ensure-max-readability')?.checked;

            let status = 'safe';
            let message = '✓ All Safe';
            let violations = [];

            // Check WCAG violations
            if (wcagEnforced) {
                if (textContrast < 4.5) violations.push('WCAG text');
                if (primaryContrast < 3.0) violations.push('WCAG UI');
            }

            // Check APCA violations
            if (apcaEnforced) {
                if (Math.abs(textAPCA) < 60) violations.push('APCA text');
                if (Math.abs(primaryAPCA) < 45) violations.push('APCA UI');
            }

            // Determine status
            if (violations.length > 0) {
                status = violations.length > 2 ? 'danger' : 'warning';
                message = violations.length > 2 ? '✕ Multiple Violations' : '⚠ ' + violations[0];
            }

            safeZone.className = `safe-zone-card ${status}`;
            safeZone.querySelector('div').textContent = message;

            // Build detailed info
            let detailsHTML = `
                <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid oklch(0.25 0.01 270);">
                    <strong>WCAG 2.2</strong>
                </div>
                <div>Text: ${textContrast.toFixed(1)}:1 ${textContrast >= 4.5 ? '✓' : '✕'} (need 4.5:1)</div>
                <div>UI: ${primaryContrast.toFixed(1)}:1 ${primaryContrast >= 3.0 ? '✓' : '✕'} (need 3.0:1)</div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid oklch(0.25 0.01 270);">
                    <strong>APCA</strong>
                </div>
                <div>Text Lc: ${Math.abs(textAPCA).toFixed(0)} ${Math.abs(textAPCA) >= 60 ? '✓' : '✕'} (need 60)</div>
                <div>UI Lc: ${Math.abs(primaryAPCA).toFixed(0)} ${Math.abs(primaryAPCA) >= 45 ? '✓' : '✕'} (need 45)</div>
            `;

            if (maxReadEnabled) {
                detailsHTML += `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid oklch(0.25 0.01 270); color: oklch(0.80 0.15 85);">
                        ⚡ Max Readability Mode Active
                    </div>
                `;
            }

            // Add fix buttons when violations detected
            if (violations.length > 0 || !maxReadEnabled) {
                detailsHTML += `<div class="fix-buttons-container">`;

                // Fix WCAG button (show if WCAG violations)
                const hasWCAGViolation = textContrast < 4.5 || primaryContrast < 3.0;
                if (hasWCAGViolation && wcagEnforced) {
                    detailsHTML += `<button class="fix-btn" id="fix-wcag-btn">🔧 Fix WCAG Violations</button>`;
                }

                // Fix APCA button (show if APCA violations)
                const hasAPCAViolation = Math.abs(textAPCA) < 60 || Math.abs(primaryAPCA) < 45;
                if (hasAPCAViolation && apcaEnforced) {
                    detailsHTML += `<button class="fix-btn" id="fix-apca-btn">🔧 Fix APCA Violations</button>`;
                }

                // Optimize Readability button (always available)
                detailsHTML += `<button class="fix-btn" id="optimize-readability-btn">✨ Optimize Readability</button>`;

                detailsHTML += `</div>`;
            }

            details.innerHTML = detailsHTML;

            // Attach event listeners to fix buttons
            const fixWCAGBtn = document.getElementById('fix-wcag-btn');
            if (fixWCAGBtn) {
                fixWCAGBtn.addEventListener('click', () => fixWCAGViolations());
            }

            const fixAPCABtn = document.getElementById('fix-apca-btn');
            if (fixAPCABtn) {
                fixAPCABtn.addEventListener('click', () => fixAPCAViolations());
            }

            const optimizeBtn = document.getElementById('optimize-readability-btn');
            if (optimizeBtn) {
                optimizeBtn.addEventListener('click', () => optimizeReadability());
            }
        }

        // Memoized OKLCH to HEX conversion (most expensive operation - 15x faster)
        const oklchToHex = memoize(function(oklchStr) {
            // Parse oklch(L C H) format
            const match = oklchStr.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            if (!match) return oklchStr;

            const l = parseFloat(match[1]);
            const c = parseFloat(match[2]);
            const h = parseFloat(match[3]);

            // OKLCH → Lab conversion
            const hueRad = (h * Math.PI) / 180;
            const a = c * Math.cos(hueRad);
            const b = c * Math.sin(hueRad);

            // Lab → XYZ conversion (D65 white point)
            const fy = (l + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;

            const xr = fx ** 3 > 0.008856 ? fx ** 3 : (fx - 16 / 116) / 7.787;
            const yr = l > 0.08 ? ((l + 16) / 116) ** 3 : l / 9.033;
            const zr = fz ** 3 > 0.008856 ? fz ** 3 : (fz - 16 / 116) / 7.787;

            const x = xr * 0.95047;
            const y = yr;
            const z = zr * 1.08883;

            // XYZ → RGB conversion
            let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            let blue = x * 0.0557 + y * -0.204 + z * 1.057;

            // Apply gamma correction
            r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r;
            g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g;
            blue = blue > 0.0031308 ? 1.055 * blue ** (1 / 2.4) - 0.055 : 12.92 * blue;

            // Clamp and convert to hex
            r = Math.max(0, Math.min(1, r));
            g = Math.max(0, Math.min(1, g));
            blue = Math.max(0, Math.min(1, blue));

            const toHex = (n) => Math.round(n * 255).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(blue)}`;
        }, 200); // Cache up to 200 color conversions

        // Memoized contrast calculation (10x faster for repeated calls)
        const calculateContrast = memoize(function(color1, color2) {
            const match1 = color1.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            const match2 = color2.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            if (!match1 || !match2) return 1;

            const l1 = parseFloat(match1[1]);
            const l2 = parseFloat(match2[1]);
            const lum1 = l1 ** 2.2;
            const lum2 = l2 ** 2.2;
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05);
        }, 500); // Cache up to 500 contrast calculations

        // ========== COLOR GROUP CARDS (Event Delegation) ==========

        function initColorGroupCards() {
            // EVENT DELEGATION: Single listener on left sidebar instead of 6 individual listeners
            // Reduces listeners from 6 to 1
            const sidebar = document.querySelector('.left-sidebar');
            if (!sidebar) return;

            sidebar.addEventListener('click', (e) => {
                const card = e.target.closest('.color-group-card');
                if (!card) return;

                const group = card.dataset.group;
                if (group) {
                    selectColorGroup(group);
                }
            });
        }

        // ========== ACTION BUTTONS ==========

        /**
         * Saves current color palette as a named blueprint to localStorage
         * @async
         * @returns {Promise<void>}
         *
         * @description
         * - Prompts user for blueprint name via custom modal
         * - Captures all 6 color groups (primary, secondary, accent, background, surface, text)
         * - Stores in localStorage with timestamp
         * - Shows success notification
         *
         * Storage format: Array of { name, colors, timestamp }
         *
         * @example
         * // User clicks "Save Blueprint" button
         * await saveBlueprint(); // Opens prompt modal, saves to localStorage
         */
        window.saveBlueprint = async () => {
            const name = await customPrompt('Enter blueprint name:', 'Save Blueprint');
            if (!name) return;

            const blueprint = {
                name,
                colors: {},
                timestamp: new Date().toISOString()
            };

            ['primary', 'secondary', 'accent', 'background', 'surface', 'text'].forEach(group => {
                const color = getComputedStyle(document.documentElement).getPropertyValue(`--${group}`);
                blueprint.colors[group] = color;
            });

            const blueprints = JSON.parse(localStorage.getItem('ui-blueprints-v2') || '[]');
            blueprints.push(blueprint);
            localStorage.setItem('ui-blueprints-v2', JSON.stringify(blueprints));

            showFloatingLog('✅ Blueprint saved successfully!', 2000, 'success');
        };

        /**
         * Loads a saved blueprint from localStorage and applies it to the current palette
         * @async
         * @returns {Promise<void>}
         *
         * @description
         * - Fetches all saved blueprints from localStorage
         * - Shows visual selection modal with blueprint names
         * - Applies selected blueprint colors to CSS variables
         * - Refreshes current color group display
         *
         * @example
         * // User clicks "Load Blueprint" button
         * await loadBlueprint(); // Opens selection modal, applies chosen blueprint
         */
        window.loadBlueprint = async () => {
            const blueprints = JSON.parse(localStorage.getItem('ui-blueprints-v2') || '[]');
            if (blueprints.length === 0) {
                await customAlert('No saved blueprints found!', 'Load Blueprint');
                return;
            }

            const options = blueprints.map((b, i) => ({
                value: String(i),
                label: b.name
            }));

            const choice = await customSelect('Select a blueprint to load:', options, 'Load Blueprint');

            if (choice === null) return;
            const index = parseInt(choice);

            if (index >= 0 && index < blueprints.length) {
                const blueprint = blueprints[index];
                const root = document.documentElement;

                Object.entries(blueprint.colors).forEach(([group, color]) => {
                    root.style.setProperty(`--${group}`, color);
                });

                showFloatingLog('✅ Blueprint loaded successfully!', 2000, 'success');
                selectColorGroup(currentGroup); // Refresh current selection
            }
        };

        /**
         * Exports current color palette in multiple formats to clipboard
         * @async
         * @returns {Promise<void>}
         *
         * @description
         * Supports 6 export formats:
         * - CSS Variables: :root { --primary: oklch(...); }
         * - SCSS Variables: $primary: oklch(...);
         * - Tailwind Config: tailwind.config.js with extended colors
         * - JSON: Simple key-value pairs
         * - HEX Palette: Converted to HEX format (uses memoized conversion - 15x faster)
         * - TypeScript: Typed color constants with type safety
         *
         * - Shows visual format selection modal
         * - Copies selected format to clipboard
         * - Shows success notification
         *
         * @example
         * // User clicks "Export Theme" button
         * await exportTheme(); // Opens format selector, copies to clipboard
         */
        window.exportTheme = async () => {
            const theme = {};
            ['primary', 'secondary', 'accent', 'background', 'surface', 'text'].forEach(group => {
                theme[group] = getComputedStyle(document.documentElement).getPropertyValue(`--${group}`).trim();
            });

            // Note: Using global memoized oklchToHex for 15x faster conversion

            // Generate different export formats
            const formats = {
                'CSS Variables': () => {
                    const css = Object.entries(theme).map(([k, v]) => `  --${k}: ${v};`).join('\n');
                    return `:root {\n${css}\n}`;
                },
                'SCSS Variables': () => {
                    const scss = Object.entries(theme).map(([k, v]) => `$${k}: ${v};`).join('\n');
                    return `// OKLCH Color Variables\n${scss}`;
                },
                'Tailwind Config': () => {
                    const colors = Object.entries(theme).reduce((acc, [k, v]) => {
                        acc[k] = v;
                        return acc;
                    }, {});
                    return `// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: ${JSON.stringify(colors, null, 8).replace(/"([^"]+)":/g, '$1:')}\n    }\n  }\n}`;
                },
                'JSON': () => {
                    return JSON.stringify(theme, null, 2);
                },
                'HEX Palette': () => {
                    const hexTheme = {};
                    Object.entries(theme).forEach(([k, v]) => {
                        hexTheme[k] = oklchToHex(v);
                    });
                    return JSON.stringify(hexTheme, null, 2);
                },
                'TypeScript': () => {
                    const colors = Object.entries(theme).map(([k, v]) => `  ${k}: '${v}'`).join(',\n');
                    return `export const colors = {\n${colors}\n} as const;\n\nexport type ColorName = keyof typeof colors;`;
                }
            };

            // Create export modal with custom select
            const options = [
                { value: '1', label: '🎨 CSS Variables' },
                { value: '2', label: '🎨 SCSS Variables' },
                { value: '3', label: '🎨 Tailwind Config' },
                { value: '4', label: '📄 JSON' },
                { value: '5', label: '🎨 HEX Palette' },
                { value: '6', label: '📘 TypeScript' }
            ];

            const format = await customSelect('Choose export format:', options, 'Export Theme');

            const formatMap = {
                '1': 'CSS Variables',
                '2': 'SCSS Variables',
                '3': 'Tailwind Config',
                '4': 'JSON',
                '5': 'HEX Palette',
                '6': 'TypeScript'
            };

            const selectedFormat = formatMap[format] || 'CSS Variables';
            const output = formats[selectedFormat]();

            navigator.clipboard.writeText(output);
            showFloatingLog(`📥 ${selectedFormat} copied!`, 1500);
        };

        // ========== URL SHARING SYSTEM ==========

        function encodeToURL() {
            const paletteData = {
                light: colorPalette.light,
                dark: colorPalette.dark,
                mode: currentMode,
                group: currentGroup
            };
            const json = JSON.stringify(paletteData);
            const base64 = btoa(json);
            return base64;
        }

        function decodeFromURL(base64) {
            try {
                // Sanitize base64 input
                const sanitizedBase64 = sanitizeString(base64, 10000);
                const json = atob(sanitizedBase64);
                const paletteData = sanitizeJSON(json);

                if (!paletteData) {
                    throw new Error('Invalid palette data');
                }

                // Validate palette structure
                if (!validatePaletteData(paletteData)) {
                    throw new Error('Invalid palette structure');
                }

                return paletteData;
            } catch (e) {
                console.error('Failed to decode palette from URL:', e);
                showFloatingLog('❌ Invalid palette URL', 2000);
                return null;
            }
        }

        function updateURLWithPalette() {
            const encoded = encodeToURL();
            const url = new URL(window.location);
            url.searchParams.set('palette', encoded);
            history.replaceState({}, '', url);
        }

        function loadPaletteFromURL() {
            const params = new URLSearchParams(window.location.search);
            const paletteParam = params.get('palette');

            if (paletteParam) {
                const paletteData = decodeFromURL(paletteParam);
                if (paletteData) {
                    colorPalette.light = paletteData.light;
                    colorPalette.dark = paletteData.dark;
                    currentMode = paletteData.mode || 'light';
                    currentGroup = paletteData.group || 'primary';

                    // Apply loaded palette
                    applyCSSVariablesFromPalette();
                    selectColorGroup(currentGroup);

                    // ========== FIX: Sync AUTO button with loaded mode ==========
                    updateModeButtonLabel();

                    // Update mode toggle (legacy support)
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.mode === currentMode);
                    });

                    showFloatingLog('🔗 Palette loaded from URL!', 1500);
                    return true;
                }
            }
            return false;
        }

        window.sharePalette = () => {
            const encoded = encodeToURL();
            const url = new URL(window.location);
            url.searchParams.set('palette', encoded);
            const shareURL = url.toString();

            navigator.clipboard.writeText(shareURL).then(() => {
                showFloatingLog('🔗 Share URL copied to clipboard!', 2000);
            }).catch(() => {
                showFloatingLog('❌ Failed to copy URL', 1000);
            });
        };

        // Auto-update URL when palette changes (debounced)
        let urlUpdateTimeout = null;
        function scheduleURLUpdate() {
            clearTimeout(urlUpdateTimeout);
            urlUpdateTimeout = setTimeout(() => {
                updateURLWithPalette();
            }, 1000); // Update URL 1 second after last change
        }

        // Load palette from URL on page load
        window.addEventListener('load', () => {
            loadPaletteFromURL();
        });

        window.applyToEcosystem = async () => {
            const confirmed = await customConfirm('Apply this theme as the new default for all 60 projects in PROJECTS_all?', 'Apply to Ecosystem');
            if (confirmed) {
                await customAlert('Theme would be applied to ecosystem!\n\n(Feature in development)', 'Coming Soon');
            }
        };

        // ========== VIEW TOGGLE (Library vs Mockup) (Event Delegation) ==========

        function initViewToggle() {
            const libraryBtn = document.getElementById('library-view-btn');
            const mockupBtn = document.getElementById('mockup-view-btn');
            const libraryView = document.getElementById('library-view');
            const mockupView = document.getElementById('mockup-view');

            if (!libraryBtn || !mockupBtn || !libraryView || !mockupView) return;

            libraryBtn.addEventListener('click', () => {
                libraryBtn.classList.add('active');
                mockupBtn.classList.remove('active');
                libraryView.style.display = 'block';
                mockupView.style.display = 'none';
                console.log('📚 Library View activated');
            });

            mockupBtn.addEventListener('click', () => {
                mockupBtn.classList.add('active');
                libraryBtn.classList.remove('active');
                libraryView.style.display = 'none';
                mockupView.style.display = 'block';
                console.log('🎨 Mockup Pages activated');
            });
        }

        // ========== MOCKUP TAB SWITCHING (Event Delegation) ==========

        function initMockupTabs() {
            // EVENT DELEGATION: Single listener on tabs container instead of 8 individual listeners
            // Reduces listeners from 8 to 1
            const tabsContainer = document.querySelector('.mockup-tabs');
            if (!tabsContainer) return;

            const pages = document.querySelectorAll('.mockup-page');

            tabsContainer.addEventListener('click', (e) => {
                const tab = e.target.closest('.mockup-tab');
                if (!tab) return;

                const mockupId = tab.dataset.mockup;
                const tabs = document.querySelectorAll('.mockup-tab');

                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Show corresponding page
                pages.forEach(page => {
                    page.classList.remove('active');
                    page.style.display = 'none';
                });

                const targetPage = document.getElementById(`mockup-${mockupId}`);
                if (targetPage) {
                    targetPage.classList.add('active');
                    targetPage.style.display = 'block';
                }

                // Note: No need to reinit universal selector - using document-level event delegation
            });
        }

        // ========== COPY CODE FUNCTION ==========

        window.copyCode = (button) => {
            const codeBlock = button.closest('.code-snippet').querySelector('.code-content code');
            const code = codeBlock.textContent;

            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = '✓ Copied!';
                button.style.background = 'oklch(0.65 0.18 145)';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            });
        };

        // ========== COUNTER-WEIGHT TRANSFORMATION SYSTEM ==========

        // ⚖️ AUTO-COUNTER-WEIGHT: Real-time bidirectional sync with compliance enforcement
        function enforceComplianceAndSync(color, group) {
            // Get compliance rule states
            const allowWCAGViolation = document.getElementById('allow-wcag-violation')?.checked || false;
            const allowAPCAViolation = document.getElementById('allow-apca-violation')?.checked || false;
            const ensureMaxReadability = document.getElementById('ensure-max-readability')?.checked || false;

            // Clone color for modification
            let adjustedColor = { l: color.l, c: color.c, h: color.h };

            // Detect current mode based on background lightness threshold
            const bgColor = colorPalette[currentMode].background;
            const detectedMode = bgColor.l < 0.5 ? 'dark' : 'light';

            // Auto-update detected mode if threshold crossed
            if (group === 'background' && adjustedColor.l < 0.5 && currentMode === 'light') {
                // Background crossed into dark territory
                currentMode = 'dark';
                updateModeIndicator();
            } else if (group === 'background' && adjustedColor.l >= 0.5 && currentMode === 'dark') {
                // Background crossed into light territory
                currentMode = 'light';
                updateModeIndicator();
            }

            // Get current background for contrast calculations
            const currentBg = group === 'background' ? adjustedColor : colorPalette[currentMode].background;

            // ========== COMPLIANCE ENFORCEMENT ==========

            // 1. WCAG 2.2 AA Compliance (if not allowed to violate)
            if (!allowWCAGViolation) {
                if (group === 'text') {
                    // Text must meet 4.5:1 contrast
                    let contrast = calculateContrastFromObjects(adjustedColor, currentBg);
                    let attempts = 0;
                    while (contrast < 4.5 && attempts < 50) {
                        // Adjust lightness to improve contrast
                        if (currentMode === 'dark') {
                            adjustedColor.l = Math.min(1.0, adjustedColor.l + 0.01);
                        } else {
                            adjustedColor.l = Math.max(0.0, adjustedColor.l - 0.01);
                        }
                        contrast = calculateContrastFromObjects(adjustedColor, currentBg);
                        attempts++;
                    }
                } else if (group === 'primary' || group === 'secondary' || group === 'accent') {
                    // UI components must meet 3:1 contrast
                    let contrast = calculateContrastFromObjects(adjustedColor, currentBg);
                    let attempts = 0;
                    while (contrast < 3.0 && attempts < 50) {
                        if (currentMode === 'dark') {
                            adjustedColor.l = Math.min(1.0, adjustedColor.l + 0.01);
                        } else {
                            adjustedColor.l = Math.max(0.0, adjustedColor.l - 0.01);
                        }
                        contrast = calculateContrastFromObjects(adjustedColor, currentBg);
                        attempts++;
                    }
                }
            }

            // 2. APCA Compliance (if not allowed to violate)
            if (!allowAPCAViolation) {
                if (group === 'text') {
                    // APCA requires Lc 60+ for body text
                    let apcaContrast = calculateAPCA(adjustedColor, currentBg);
                    let attempts = 0;
                    while (Math.abs(apcaContrast) < 60 && attempts < 50) {
                        if (currentMode === 'dark') {
                            adjustedColor.l = Math.min(1.0, adjustedColor.l + 0.01);
                        } else {
                            adjustedColor.l = Math.max(0.0, adjustedColor.l - 0.01);
                        }
                        apcaContrast = calculateAPCA(adjustedColor, currentBg);
                        attempts++;
                    }
                }
            }

            // 3. Max Readability (if enabled)
            if (ensureMaxReadability) {
                if (group === 'text') {
                    // Maximize contrast for text
                    adjustedColor.l = currentMode === 'dark' ? 0.98 : 0.08;
                    adjustedColor.c = Math.min(0.02, adjustedColor.c); // Reduce chroma for neutrality
                } else if (group === 'background' || group === 'surface') {
                    // Ensure very neutral backgrounds
                    adjustedColor.c = Math.min(0.02, adjustedColor.c);
                }
            }

            // 4. Brightness Consistency Rule (if enabled)
            const enforceBrightnessConsistency = document.getElementById('enforce-brightness-consistency')?.checked || false;
            if (enforceBrightnessConsistency) {
                // Only apply to component colors, not background/text/surface
                if (group === 'primary' || group === 'secondary' || group === 'accent') {
                    // Calculate theme brightness baseline (from background)
                    const themeBrightness = currentBg.l;

                    // Define ±20% range
                    const minBrightness = Math.max(0, themeBrightness - 0.20);
                    const maxBrightness = Math.min(1, themeBrightness + 0.20);

                    // Clamp component color lightness within range
                    if (adjustedColor.l < minBrightness) {
                        adjustedColor.l = minBrightness;
                    } else if (adjustedColor.l > maxBrightness) {
                        adjustedColor.l = maxBrightness;
                    }
                }
            }

            // ========== AUTO-SYNC OPPOSITE MODE ==========
            // Calculate opposite mode equivalent and store both
            const oppositeMode = currentMode === 'light' ? 'dark' : 'light';
            const oppositeColor = transformColorForMode(adjustedColor, group, oppositeMode);

            // Store current mode color
            colorPalette[currentMode][group] = {
                l: adjustedColor.l,
                c: adjustedColor.c,
                h: adjustedColor.h
            };

            // Store opposite mode color
            colorPalette[oppositeMode][group] = oppositeColor;

            return adjustedColor;
        }

        // Memoized APCA calculation (Advanced Perceptual Contrast Algorithm)
        const calculateAPCA = memoize(function(textColor, bgColor) {
            // Simplified APCA implementation
            const Ys = Math.pow(textColor.l, 2.4); // Text Y (simplified)
            const Yb = Math.pow(bgColor.l, 2.4);   // Background Y (simplified)

            // Clamp values
            const Ystxt = Ys > Yb ? Ys : Ys + 0.027;
            const Ysbg = Yb > Ys ? Yb : Yb + 0.027;

            // Calculate contrast
            const SAPC = (Math.pow(Ysbg, 0.56) - Math.pow(Ystxt, 0.57)) * 1.14;

            // Return Lc value (lightness contrast)
            if (Math.abs(SAPC) < 0.1) return 0;
            return SAPC < 0 ? SAPC - 0.027 : SAPC - 0.027;
        }, 500); // Cache up to 500 APCA calculations

        // ========== INTELLIGENT MODE TRANSFORMATION SYSTEM ==========
        // 🎨 Uses trajectory-based intelligence (like counter-weight system) instead of naive templates
        //
        // KEY INSIGHT: Mode switching is NOT simple inversion - it's a perceptual transformation
        // that maintains color relationships, harmony, and professional appearance.
        //
        // REPLACES: 5 separate templates with single unified trajectory-based algorithm

        const modeTransformationTrajectories = {
            // BACKGROUNDS & SURFACES (viewing surfaces)
            background: {
                toDark: {
                    // Deep inversion with perceptual compression
                    // Formula: Map 0.98 → 0.15, 0.50 → 0.17, maintaining subtle variation
                    l: (l) => 0.15 + (0.98 - l) * 0.05,
                    c: (c) => c * 0.7,  // Reduced chroma for comfortable dark viewing
                    h: (h) => h         // Preserve hue identity
                },
                toLight: {
                    // Inverse transformation (from dark to light)
                    l: (l) => 0.98 - (l - 0.15) / 0.05,
                    c: (c) => c / 0.7,
                    h: (h) => h
                }
            },

            surface: {
                toDark: {
                    // Slightly lighter than background for elevation
                    l: (l) => 0.18 + (0.95 - l) * 0.05,
                    c: (c) => c * 0.7,
                    h: (h) => h
                },
                toLight: {
                    l: (l) => 0.95 - (l - 0.18) / 0.05,
                    c: (c) => c / 0.7,
                    h: (h) => h
                }
            },

            // TEXT (content)
            text: {
                toDark: {
                    // High lightness for maximum readability on dark backgrounds
                    l: (l) => 0.95,
                    c: (c) => Math.min(0.02, c * 0.2),  // FIXED: Max 0.02 chroma for readability
                    h: (h) => h
                },
                toLight: {
                    // Dark text for readability on light backgrounds
                    l: (l) => 0.15,
                    c: (c) => Math.min(0.02, c * 0.2),  // FIXED: Max 0.02 chroma for readability
                    h: (h) => h
                }
            },

            // INTERACTION COLORS (primary, secondary, accent)
            // These maintain brand identity (hue) while adapting perceptually
            primary: {
                toDark: {
                    // FIXED: Intelligent transformation for ALL lightness ranges
                    l: (l) => {
                        // For VERY DARK colors (l < 0.30) - INVERT and BRIGHTEN
                        // Example: Black (0.10) → Bright (0.65-0.75) for visibility
                        if (l < 0.30) {
                            return 0.60 + (0.30 - l) * 0.5;  // Range: 0.60-0.75
                        }
                        // For MID-RANGE colors (0.30-0.70) - Perceptual compression
                        else if (l <= 0.70) {
                            return 0.55 + (l - 0.50) * 0.4;  // Range: 0.47-0.63
                        }
                        // For VERY LIGHT colors (l > 0.70) - Darken significantly
                        else {
                            return 0.50 - (l - 0.70) * 0.8;  // Range: 0.28-0.50
                        }
                    },
                    c: (c) => {
                        // FIXED: Boost chroma for desaturated colors, maintain for saturated
                        return c < 0.05 ? Math.min(0.37, c + 0.15) : Math.min(0.37, c * 1.1);
                    },
                    h: (h) => h  // PRESERVE HUE - this is the brand color!
                },
                toLight: {
                    // Inverse transformation
                    l: (l) => 0.50 + (l - 0.40) / 0.8,
                    c: (c) => c / 1.1,
                    h: (h) => h
                }
            },

            secondary: {
                toDark: {
                    // FIXED: Same intelligent range-based transformation as primary
                    l: (l) => {
                        if (l < 0.30) {
                            return 0.55 + (0.30 - l) * 0.5;  // Range: 0.55-0.70 (slightly darker than primary)
                        }
                        else if (l <= 0.70) {
                            return 0.50 + (l - 0.50) * 0.4;  // Range: 0.42-0.58
                        }
                        else {
                            return 0.45 - (l - 0.70) * 0.8;  // Range: 0.23-0.45
                        }
                    },
                    c: (c) => {
                        return c < 0.05 ? Math.min(0.37, c + 0.12) : Math.min(0.37, c * 1.05);
                    },
                    h: (h) => h
                },
                toLight: {
                    l: (l) => 0.50 + (l - 0.38) / 0.75,
                    c: (c) => c / 1.05,
                    h: (h) => h
                }
            },

            accent: {
                toDark: {
                    // FIXED: Most vibrant - stands out against dark background
                    l: (l) => {
                        if (l < 0.30) {
                            return 0.65 + (0.30 - l) * 0.5;  // Range: 0.65-0.80 (brightest!)
                        }
                        else if (l <= 0.70) {
                            return 0.60 + (l - 0.50) * 0.4;  // Range: 0.52-0.68
                        }
                        else {
                            return 0.55 - (l - 0.70) * 0.8;  // Range: 0.31-0.55
                        }
                    },
                    c: (c) => {
                        return c < 0.05 ? Math.min(0.37, c + 0.18) : Math.min(0.37, c * 1.2);
                    },
                    h: (h) => h
                },
                toLight: {
                    l: (l) => 0.50 + (l - 0.45) / 0.9,
                    c: (c) => c / 1.2,
                    h: (h) => h
                }
            }
        };

        function transformColorForMode(color, group, targetMode) {
            // Determine transformation direction
            const direction = targetMode === 'dark' ? 'toDark' : 'toLight';

            // Get trajectory formulas for this color group
            const trajectory = modeTransformationTrajectories[group];
            if (!trajectory || !trajectory[direction]) {
                // Fallback: return color unchanged if no trajectory defined
                console.warn(`⚠️ No transformation trajectory for ${group} → ${targetMode}`);
                return { ...color };
            }

            // Apply trajectory formulas
            const formulas = trajectory[direction];
            const transformed = {
                l: formulas.l(color.l),
                c: formulas.c(color.c),
                h: formulas.h(color.h)
            };

            // Validate and clamp values
            transformed.l = Math.max(0, Math.min(1, transformed.l));
            transformed.c = Math.max(0, Math.min(0.37, transformed.c));
            transformed.h = ((transformed.h % 360) + 360) % 360;

            // ========== WCAG CONTRAST ENFORCEMENT ==========
            // Ensure transformed color meets minimum contrast requirements
            const bgColor = group === 'background'
                ? transformed  // If transforming background, use itself
                : colorPalette[targetMode]?.background || transformed;

            if (group === 'text') {
                // Text must meet 4.5:1 contrast
                let contrast = calculateContrastFromObjects(transformed, bgColor);
                let attempts = 0;

                while (contrast < 4.5 && attempts < 50) {
                    // Adjust lightness to improve contrast
                    if (targetMode === 'dark') {
                        transformed.l = Math.min(1.0, transformed.l + 0.01);
                    } else {
                        transformed.l = Math.max(0.0, transformed.l - 0.01);
                    }
                    contrast = calculateContrastFromObjects(transformed, bgColor);
                    attempts++;
                }
            } else if (group === 'primary' || group === 'secondary' || group === 'accent') {
                // UI components should aim for 3:1 minimum
                let contrast = calculateContrastFromObjects(transformed, bgColor);

                if (contrast < 3.0) {
                    // Slight lightness adjustment for contrast
                    const adjustmentDirection = targetMode === 'dark' ? 1 : -1;
                    transformed.l = Math.max(0, Math.min(1, transformed.l + (adjustmentDirection * 0.05)));
                }
            }

            console.log(`🎨 Trajectory Transform: ${group} (${currentMode} → ${targetMode})`);
            console.log(`   L: ${color.l.toFixed(2)} → ${transformed.l.toFixed(2)}`);
            console.log(`   C: ${color.c.toFixed(2)} → ${transformed.c.toFixed(2)}`);

            return transformed;
        }

        function switchMode(mode) {
            if (mode === currentMode) return;

            const previousMode = currentMode;
            currentMode = mode;

            // Save current colors to previous mode palette
            ['primary', 'secondary', 'accent', 'background', 'surface', 'text'].forEach(group => {
                const root = document.documentElement;
                const colorValue = getComputedStyle(root).getPropertyValue(`--${group}`).trim();
                const match = colorValue.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);

                if (match) {
                    colorPalette[previousMode][group] = {
                        l: parseFloat(match[1]),
                        c: parseFloat(match[2]),
                        h: parseFloat(match[3])
                    };
                }
            });

            // Transform colors for new mode
            const root = document.documentElement;
            ['primary', 'secondary', 'accent', 'background', 'surface', 'text'].forEach(group => {
                const sourceColor = colorPalette[previousMode][group];
                const transformedColor = transformColorForMode(sourceColor, group, mode);

                colorPalette[mode][group] = transformedColor;
                root.style.setProperty(`--${group}`, `oklch(${transformedColor.l} ${transformedColor.c} ${transformedColor.h})`);
            });

            // Update UI
            updateModeIndicator();
            selectColorGroup(currentGroup); // Refresh current selection
            updateSafeZone();

            // Update 2D pickers
            if (window.drawHueWheel) window.drawHueWheel();
            if (window.drawChromaLightness) window.drawChromaLightness();

            // Announce mode switch to screen readers
            announceToScreenReader(`Switched to ${mode} mode`);

            // ========== INTEGRATED: Update all color names after mode switch ==========
            updateAllColorNames();
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('current-mode-indicator');
            if (indicator) {
                indicator.textContent = currentMode === 'light' ? '☀️ Light' : '🌙 Dark';
            }

            // ========== FIX: Sync AUTO button label ==========
            updateModeButtonLabel();

            // Update mode toggle buttons (legacy support)
            document.querySelectorAll('.top-bar .mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentMode);
            });
        }

        function calculateContrastFromObjects(color1, color2) {
            // Simplified contrast calculation for color objects
            const lum1 = color1.l ** 2.2;
            const lum2 = color2.l ** 2.2;
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05);
        }

        // ========== MODE TOGGLE & TEMPLATE CONTROLS (Event Delegation) ==========

        // SCAFFOLD THEME SYSTEM (Independent from palette mode)
        let scaffoldMode = 'light'; // 'light' or 'dark' - controls the UI interface theme

        function updateScaffoldTheme() {
            const studio = document.querySelector('.studio');
            if (!studio) return;

            // Apply scaffold-light class based on scaffoldMode
            if (scaffoldMode === 'light') {
                studio.classList.add('scaffold-light');
            } else {
                studio.classList.remove('scaffold-light');
            }
        }

        function updateScaffoldButtonLabel() {
            const scaffoldBtn = document.getElementById('scaffold-theme-toggle');
            if (!scaffoldBtn) return;

            if (scaffoldMode === 'light') {
                scaffoldBtn.dataset.mode = 'light';
                scaffoldBtn.innerHTML = '<span id="scaffold-icon">☀️</span> Scaffold';
            } else {
                scaffoldBtn.dataset.mode = 'dark';
                scaffoldBtn.innerHTML = '<span id="scaffold-icon">🌙</span> Scaffold';
            }
        }

        function initScaffoldToggle() {
            const scaffoldBtn = document.getElementById('scaffold-theme-toggle');
            if (!scaffoldBtn) return;

            scaffoldBtn.addEventListener('click', () => {
                // Toggle scaffold mode
                scaffoldMode = scaffoldMode === 'light' ? 'dark' : 'light';

                console.log(`🏗️ SCAFFOLD MODE SWITCH: ${scaffoldMode === 'light' ? 'dark' : 'light'} → ${scaffoldMode}`);

                // Update UI
                updateScaffoldTheme();
                updateScaffoldButtonLabel();

                showNotification(`🏗️ Scaffold switched to ${scaffoldMode} mode`, 1500);
            });

            // Initialize button label and theme
            updateScaffoldButtonLabel();
            updateScaffoldTheme();
            console.log(`✅ Scaffold toggle initialized: ${scaffoldMode} mode`);
        }

        // OKLCH CODE DISPLAY - BACKGROUND = SELECTED COLOR, TEXT = PURE BLACK OR WHITE FOR MAX READABILITY
        function updateOklchCodeDisplay(l, c, h) {
            const root = document.documentElement;

            // Background: Use the selected color exactly as-is
            const bgColor = `oklch(${l.toFixed(2)} ${c.toFixed(2)} ${h.toFixed(0)})`;

            // Text: PURE BLACK or PURE WHITE (zero chroma, neutral hue) for MAXIMUM readability
            // If selected color is light (L > 0.5) → use pure black
            // If selected color is dark (L <= 0.5) → use pure white
            const textColor = l > 0.5 ? 'oklch(0.0 0.0 0)' : 'oklch(1.0 0.0 0)';

            // Border: Slightly darker or lighter than background for definition
            const borderL = l > 0.5 ? Math.max(0, l - 0.2) : Math.min(1, l + 0.2);
            const borderColor = `oklch(${borderL.toFixed(2)} ${c.toFixed(2)} ${h.toFixed(0)})`;

            // Update CSS variables
            root.style.setProperty('--oklch-code-bg', bgColor);
            root.style.setProperty('--oklch-code-text', textColor);
            root.style.setProperty('--oklch-code-border', borderColor);
        }

        // ========== UPDATE MODE BUTTON LABEL (helper function) ==========
        function updateModeButtonLabel() {
            const toggleBtn = document.getElementById('auto-theme-toggle');
            if (!toggleBtn) return;

            if (currentMode === 'light') {
                toggleBtn.dataset.mode = 'light';
                toggleBtn.innerHTML = '<span id="theme-icon">☀️</span> Light';
            } else {
                toggleBtn.dataset.mode = 'dark';
                toggleBtn.innerHTML = '<span id="theme-icon">🌙</span> Dark';
            }
        }

        function initModeToggle() {
            const toggleBtn = document.getElementById('auto-theme-toggle');
            const themeIcon = document.getElementById('theme-icon');
            if (!toggleBtn) return;

            toggleBtn.addEventListener('click', () => {
                // ========== INTELLIGENT AUTO MODE SWITCHING ==========
                // When clicked, switch to the OPPOSITE color palette mode
                // Uses trajectory-based transformation for professional, beautiful results

                const oppositeMode = currentMode === 'light' ? 'dark' : 'light';

                console.log(`🔄 AUTO MODE SWITCH: ${currentMode} → ${oppositeMode}`);
                console.log(`🎨 Using intelligent trajectory-based transformation`);

                // Show loading notification
                showNotification(`🔄 Transforming to ${oppositeMode} mode...`, 1500);

                // Switch mode using intelligent transformation system
                switchMode(oppositeMode);

                // Update button to show current mode
                updateModeButtonLabel();

                // Show success notification
                setTimeout(() => {
                    showNotification(`✨ ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} mode applied with intelligent transformations`, 2000);
                }, 500);

                // Update scaffold theme to match new mode
                updateScaffoldTheme();
            });

            // Initialize scaffold theme based on current color
            updateScaffoldTheme();

            // Initialize button label based on current mode
            updateModeButtonLabel();
            console.log(`✅ Auto button initialized: ${currentMode} mode`);
        }

        function initTemplateControls() {
            // Template selector
            const templateSelect = document.getElementById('transformation-template');
            if (templateSelect) {
                templateSelect.addEventListener('change', (e) => {
                    activeTemplate = e.target.value;
                    // Re-apply transformation if in dark mode
                    if (currentMode === 'dark') {
                        switchMode('light');
                        setTimeout(() => switchMode('dark'), 50);
                    }
                });
            }

            // Lightness adjustment
            const lightnessSlider = document.getElementById('template-lightness-adjust');
            const lightnessVal = document.getElementById('template-lightness-val');
            if (lightnessSlider && lightnessVal) {
                lightnessSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    templateAdjustments.lightnessAdjust = value;
                    lightnessVal.textContent = `${value > 0 ? '+' : ''}${value}%`;

                    // Re-apply transformation if in dark mode
                    if (currentMode === 'dark') {
                        switchMode('light');
                        setTimeout(() => switchMode('dark'), 50);
                    }
                });
            }

            // Chroma adjustment
            const chromaSlider = document.getElementById('template-chroma-adjust');
            const chromaVal = document.getElementById('template-chroma-val');
            if (chromaSlider && chromaVal) {
                chromaSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    templateAdjustments.chromaAdjust = value;
                    chromaVal.textContent = `${value > 0 ? '+' : ''}${value}%`;

                    // Re-apply transformation if in dark mode
                    if (currentMode === 'dark') {
                        switchMode('light');
                        setTimeout(() => switchMode('dark'), 50);
                    }
                });
            }

            // Maintain contrast checkbox
            const contrastCheckbox = document.getElementById('template-maintain-contrast');
            if (contrastCheckbox) {
                contrastCheckbox.addEventListener('change', (e) => {
                    templateAdjustments.maintainContrast = e.target.checked;

                    // Re-apply transformation if in dark mode
                    if (currentMode === 'dark') {
                        switchMode('light');
                        setTimeout(() => switchMode('dark'), 50);
                    }
                });
            }
        }

        // Animation settings
        let animationSettings = {
            duration: 800,
            constantSpeed: false
        };

        function initAnimationControls() {
            // Duration slider
            const durationSlider = document.getElementById('animation-duration');
            const durationVal = document.getElementById('animation-duration-val');
            if (durationSlider && durationVal) {
                durationSlider.addEventListener('input', (e) => {
                    animationSettings.duration = parseInt(e.target.value);
                    durationVal.textContent = animationSettings.duration;
                });
            }

            // Constant speed mode toggle
            const speedToggle = document.getElementById('constant-speed-mode');
            if (speedToggle) {
                speedToggle.addEventListener('change', (e) => {
                    animationSettings.constantSpeed = e.target.checked;
                });
            }
        }

        // ========== CONNECT SLIDERS TO VISUALIZATIONS ==========

        function initColorSliders() {
            const lSlider = document.getElementById('current-l');
            const cSlider = document.getElementById('current-c');
            const hSlider = document.getElementById('current-h');

            const lValue = document.getElementById('current-l-val');
            const cValue = document.getElementById('current-c-val');
            const hValue = document.getElementById('current-h-val');

            if (!lSlider || !cSlider || !hSlider) {
                console.warn('⚠️ Color sliders not found - skipping initialization');
                return;
            }

            console.log('🎚️ Initializing color sliders with FULL synchronization + TRAJECTORY FORMULAS');

            // Track which parameter was changed for trajectory computation
            let lastValues = {
                l: parseFloat(lSlider.value) / 100,
                c: parseFloat(cSlider.value) / 100,
                h: parseFloat(hSlider.value)
            };

            // Update everything when ANY slider changes
            function onSliderChange(changedParam) {
                const newL = parseFloat(lSlider.value) / 100;
                const newC = parseFloat(cSlider.value) / 100;
                const newH = parseFloat(hSlider.value);

                // Determine which parameter actually changed
                const changes = [];
                if (Math.abs(newL - lastValues.l) > 0.001) changes.push({ param: 'l', value: newL });
                if (Math.abs(newC - lastValues.c) > 0.001) changes.push({ param: 'c', value: newC });
                if (Math.abs(newH - lastValues.h) > 0.1) changes.push({ param: 'h', value: newH });

                // Update via trajectory system (triggers counter-weight adjustments)
                changes.forEach(change => {
                    updateColorParameter(currentGroup, change.param, change.value);
                });

                // Update currentColor
                currentColor.l = newL;
                currentColor.c = newC;
                currentColor.h = newH;

                // Update value displays
                lValue.textContent = currentColor.l.toFixed(2);
                cValue.textContent = currentColor.c.toFixed(2);
                hValue.textContent = currentColor.h.toFixed(0);

                // Update OKLCH code display
                updateOklchCodeDisplay(currentColor.l, currentColor.c, currentColor.h);

                // Update color line display
                updateColorLineDisplay(currentColor.l, currentColor.c, currentColor.h);

                // Update spotlight accent
                updateSpotlightAccent();

                // Update scaffold theme (based on background lightness, not current selection)
                updateScaffoldTheme();

                // Update 3D Color Space visualization
                if (window.updateColorPoint) {
                    window.updateColorPoint(currentColor.l, currentColor.c, currentColor.h);
                }

                // Update 2D Color Wheels
                if (window.drawHueWheel) window.drawHueWheel();
                if (window.drawChromaLightness) window.drawChromaLightness();

                // Update safe zone
                updateSafeZone();

                // Color Palette Map is already updated by updateColorParameter via trajectory system

                // Store for next comparison
                lastValues = { l: newL, c: newC, h: newH };
            }

            // Attach event listeners with parameter tracking
            lSlider.addEventListener('input', () => onSliderChange('l'));
            cSlider.addEventListener('input', () => onSliderChange('c'));
            hSlider.addEventListener('input', () => onSliderChange('h'));

            console.log('✅ Color sliders connected to all visualizations');
        }

        function initComplianceToggles() {
            // Allow WCAG Violation toggle
            const wcagToggle = document.getElementById('allow-wcag-violation');
            if (wcagToggle) {
                wcagToggle.addEventListener('change', (e) => {
                    // Update auto-sync status indicator
                    updateAutoSyncStatus();
                    // Re-apply current color to enforce new rules
                    if (currentGroup) {
                        selectColorGroup(currentGroup);
                    }
                });
            }

            // Allow APCA Violation toggle
            const apcaToggle = document.getElementById('allow-apca-violation');
            if (apcaToggle) {
                apcaToggle.addEventListener('change', (e) => {
                    updateAutoSyncStatus();
                    if (currentGroup) {
                        selectColorGroup(currentGroup);
                    }
                });
            }

            // Ensure Max Readability toggle
            const maxReadToggle = document.getElementById('ensure-max-readability');
            if (maxReadToggle) {
                maxReadToggle.addEventListener('change', (e) => {
                    updateAutoSyncStatus();
                    if (currentGroup) {
                        selectColorGroup(currentGroup);
                    }
                });
            }

            // Enforce Brightness Consistency toggle
            const brightnessToggle = document.getElementById('enforce-brightness-consistency');
            if (brightnessToggle) {
                brightnessToggle.addEventListener('change', (e) => {
                    updateAutoSyncStatus();
                    if (currentGroup) {
                        selectColorGroup(currentGroup);
                    }
                });
            }
        }

        function updateAutoSyncStatus() {
            const statusBadge = document.getElementById('auto-sync-status');
            if (!statusBadge) return;

            const wcagEnforced = !document.getElementById('allow-wcag-violation')?.checked;
            const apcaEnforced = !document.getElementById('allow-apca-violation')?.checked;
            const maxReadEnabled = document.getElementById('ensure-max-readability')?.checked;
            const brightnessConsistency = document.getElementById('enforce-brightness-consistency')?.checked;

            // Count active rules
            let activeRules = 0;
            if (wcagEnforced) activeRules++;
            if (apcaEnforced) activeRules++;
            if (maxReadEnabled) activeRules++;
            if (brightnessConsistency) activeRules++;

            // Update badge based on active rules (max 4 rules now)
            if (activeRules === 4) {
                statusBadge.textContent = 'MAXIMUM';
                statusBadge.style.background = 'oklch(0.45 0.18 145)'; // Green
            } else if (activeRules === 3) {
                statusBadge.textContent = 'HIGH';
                statusBadge.style.background = 'oklch(0.50 0.18 160)'; // Teal
            } else if (activeRules === 2) {
                statusBadge.textContent = 'ACTIVE';
                statusBadge.style.background = 'oklch(0.60 0.18 270)'; // Purple
            } else if (activeRules === 1) {
                statusBadge.textContent = 'PARTIAL';
                statusBadge.style.background = 'oklch(0.70 0.18 70)'; // Yellow
            } else {
                statusBadge.textContent = 'MINIMAL';
                statusBadge.style.background = 'oklch(0.60 0.20 25)'; // Red
            }
        }

        // ========== ANIMATED COLOR TRAJECTORY SYSTEM ==========

        /**
         * Animates color transition with perceptual distance-based timing
         * @param {string} group - Color group to animate (primary, secondary, accent, etc.)
         * @param {Object} targetColor - Target OKLCH color
         * @param {number} targetColor.l - Lightness (0-1)
         * @param {number} targetColor.c - Chroma (0-0.37)
         * @param {number} targetColor.h - Hue (0-360)
         * @param {number|null} customDuration - Optional custom duration in ms (overrides settings)
         *
         * @description
         * Features:
         * - Perceptual color distance calculation (weighted: L×100, C×100, H÷360)
         * - Shortest path hue interpolation (no 359°→0° jumps)
         * - Constant speed mode: duration scales with distance
         * - Ease-in-out cubic easing
         * - 60fps requestAnimationFrame animation
         * - Updates all UI elements: sliders, displays, 3D viewer, 2D pickers
         *
         * Color distance formula: √(ΔL²×100 + ΔC²×100 + (ΔH/360)²)
         * Duration range (constant speed): 200ms - 3000ms
         *
         * @example
         * // Animate to purple (270°)
         * animateColorSlide('primary', { l: 0.65, c: 0.18, h: 270 });
         *
         * // Animate with custom 500ms duration
         * animateColorSlide('accent', { l: 0.50, c: 0.20, h: 145 }, 500);
         */
        function animateColorSlide(group, targetColor, customDuration = null) {
            const startColor = { ...currentColor };
            const startTime = performance.now();

            // Calculate color distance in OKLCH space
            const deltaL = targetColor.l - startColor.l;
            const deltaC = targetColor.c - startColor.c;
            let deltaH = targetColor.h - startColor.h;
            // Normalize hue difference to shortest path
            if (Math.abs(deltaH) > 180) {
                deltaH = deltaH > 0 ? deltaH - 360 : deltaH + 360;
            }
            // Weighted distance (L and C have more visual impact than H)
            const distance = Math.sqrt(deltaL * deltaL * 100 + deltaC * deltaC * 100 + (deltaH / 360) * (deltaH / 360));

            // Determine duration: use custom, or settings-based, or default
            let duration = customDuration || animationSettings.duration;

            // Constant speed mode: adjust duration based on distance
            if (animationSettings.constantSpeed && distance > 0.001) {
                // Base speed: 1 unit distance = baseDuration ms
                const baseDuration = animationSettings.duration;
                const referenceDistance = 1.0; // Reference distance for base duration
                duration = (distance / referenceDistance) * baseDuration;
                // Clamp duration to reasonable range
                duration = Math.max(200, Math.min(duration, 3000));
            }

            // Get button that triggered animation
            const triggerBtn = document.activeElement?.classList.contains('fix-btn')
                ? document.activeElement
                : null;

            if (triggerBtn) {
                triggerBtn.classList.add('animating');
                triggerBtn.disabled = true;
            }

            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = easeInOutCubic(progress);

                // Interpolate OKLCH values
                currentColor.l = startColor.l + (targetColor.l - startColor.l) * easedProgress;
                currentColor.c = startColor.c + (targetColor.c - startColor.c) * easedProgress;

                // Shortest path for hue angle
                let hueDiff = targetColor.h - startColor.h;
                if (Math.abs(hueDiff) > 180) {
                    hueDiff = hueDiff > 0 ? hueDiff - 360 : hueDiff + 360;
                }
                currentColor.h = (startColor.h + hueDiff * easedProgress + 360) % 360;

                // Apply color to CSS
                const colorStr = `oklch(${currentColor.l.toFixed(2)} ${currentColor.c.toFixed(2)} ${currentColor.h})`;
                document.documentElement.style.setProperty(`--${group}`, colorStr);

                // Update UI elements (instant)
                updateOklchCodeDisplay(currentColor.l, currentColor.c, currentColor.h);
                updateColorLineDisplay(currentColor.l, currentColor.c, currentColor.h);
                document.getElementById('current-l').value = currentColor.l * 100;
                document.getElementById('current-c').value = currentColor.c * 100;
                document.getElementById('current-h').value = currentColor.h;
                document.getElementById('current-l-val').textContent = currentColor.l.toFixed(2);
                document.getElementById('current-c-val').textContent = currentColor.c.toFixed(2);
                document.getElementById('current-h-val').textContent = currentColor.h.toFixed(0);

                // Update 3D viewer
                if (window.updateColorPoint) {
                    window.updateColorPoint(currentColor.l, currentColor.c, currentColor.h);
                }

                // Update 2D pickers
                if (window.drawHueWheel) window.drawHueWheel();
                if (window.drawChromaLightness) window.drawChromaLightness();

                // Update safe zone
                updateSafeZone();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    if (triggerBtn) {
                        triggerBtn.classList.remove('animating');
                        triggerBtn.disabled = false;
                    }

                    // Store final color in palette
                    colorPalette[currentMode][group] = { ...currentColor };

                    // Auto-sync opposite mode
                    const oppositeMode = currentMode === 'light' ? 'dark' : 'light';
                    const oppositeColor = transformColorForMode(currentColor, group, oppositeMode);
                    colorPalette[oppositeMode][group] = oppositeColor;

                    // UPDATE DYNAMIC COLOR PALETTE MAP
                    updateColorPaletteMap();
                }
            }

            requestAnimationFrame(animate);
        }

        function calculateWCAGCompliantColor(group) {
            const bgColor = colorPalette[currentMode].background;
            const targetColor = { ...colorPalette[currentMode][group] };

            // Determine required contrast
            const requiredContrast = group === 'text' ? 4.5 : 3.0;

            // Binary search for compliant lightness
            let minL = 0;
            let maxL = 1;
            let iterations = 0;

            while (iterations < 50) {
                const testColor = { ...targetColor, l: (minL + maxL) / 2 };
                const contrast = calculateContrastFromObjects(testColor, bgColor);

                if (Math.abs(contrast - requiredContrast) < 0.1) {
                    targetColor.l = testColor.l;
                    break;
                }

                if (contrast < requiredContrast) {
                    // Need more contrast - adjust lightness away from background
                    if (currentMode === 'dark') {
                        minL = testColor.l; // Increase lightness
                    } else {
                        maxL = testColor.l; // Decrease lightness
                    }
                } else {
                    // Too much contrast - can reduce
                    if (currentMode === 'dark') {
                        maxL = testColor.l;
                    } else {
                        minL = testColor.l;
                    }
                }

                iterations++;
            }

            return targetColor;
        }

        function calculateAPCACompliantColor(group) {
            const bgColor = colorPalette[currentMode].background;
            const targetColor = { ...colorPalette[currentMode][group] };

            // Determine required APCA Lc
            const requiredLc = group === 'text' ? 60 : 45;

            // Binary search for compliant lightness
            let minL = 0;
            let maxL = 1;
            let iterations = 0;

            while (iterations < 50) {
                const testColor = { ...targetColor, l: (minL + maxL) / 2 };
                const apca = Math.abs(calculateAPCA(testColor, bgColor));

                if (Math.abs(apca - requiredLc) < 2) {
                    targetColor.l = testColor.l;
                    break;
                }

                if (apca < requiredLc) {
                    // Need more contrast
                    if (currentMode === 'dark') {
                        minL = testColor.l;
                    } else {
                        maxL = testColor.l;
                    }
                } else {
                    if (currentMode === 'dark') {
                        maxL = testColor.l;
                    } else {
                        minL = testColor.l;
                    }
                }

                iterations++;
            }

            return targetColor;
        }

        // ========== REAL DOM-BASED COMPLIANCE SYSTEM (COMPLETE REWRITE) ==========

        /**
         * Scans ACTUAL DOM for text elements and their immediate backgrounds
         * Returns array of { element, textColor, bgColor, violation, adjustment }
         */
        function scanDOMForTextViolations(mode) {
            const violations = [];

            // Find all text-containing elements in gallery
            const gallery = document.querySelector('.center-gallery');
            if (!gallery) return violations;

            // Get all elements with text content (excluding scaffold UI)
            const textElements = Array.from(gallery.querySelectorAll('*')).filter(el => {
                // Must have direct text content
                const hasText = Array.from(el.childNodes).some(node =>
                    node.nodeType === Node.TEXT_NODE && node.textContent.trim()
                );

                // Must have computed color
                const style = window.getComputedStyle(el);
                const hasColor = style.color && style.color !== 'inherit';

                return hasText && hasColor;
            });

            console.log(`🔍 Scanning ${textElements.length} text elements for ${mode} violations...`);

            textElements.forEach(el => {
                const computedStyle = window.getComputedStyle(el);

                // Get text color
                const textColorRaw = computedStyle.color;
                const textColor = parseComputedColor(textColorRaw);
                if (!textColor) return;

                // Get immediate background color (walk up DOM tree)
                const bgColor = getImmediateBackground(el);
                if (!bgColor) return;

                // Check compliance based on mode
                let isViolation = false;
                let targetContrast = 0;
                let actualContrast = 0;

                if (mode === 'wcag') {
                    const fontSize = parseFloat(computedStyle.fontSize);
                    const isBold = computedStyle.fontWeight >= 600;
                    const isLargeText = fontSize >= 18 || (fontSize >= 14 && isBold);

                    targetContrast = isLargeText ? 3.0 : 4.5;
                    actualContrast = calculateContrastFromObjects(textColor, bgColor);
                    isViolation = actualContrast < targetContrast;

                } else if (mode === 'apca') {
                    const apcaValue = Math.abs(calculateAPCA(textColor, bgColor));
                    targetContrast = 60; // Lc 60+ for body text
                    actualContrast = apcaValue;
                    isViolation = apcaValue < 60;

                } else if (mode === 'readability') {
                    // Max readability: text should be near 0.98 (dark bg) or 0.08 (light bg)
                    const targetL = bgColor.l < 0.5 ? 0.98 : 0.08;
                    const deltaL = Math.abs(textColor.l - targetL);
                    isViolation = deltaL > 0.15; // Allow 15% deviation
                    actualContrast = calculateContrastFromObjects(textColor, bgColor);
                    targetContrast = bgColor.l < 0.5 ? 15 : 15; // High contrast target
                }

                if (isViolation) {
                    violations.push({
                        element: el,
                        textColor: textColor,
                        bgColor: bgColor,
                        mode: mode,
                        targetContrast: targetContrast,
                        actualContrast: actualContrast,
                        adjustment: null // Will be calculated
                    });
                }
            });

            return violations;
        }

        /**
         * Parse CSS color string to OKLCH object
         */
        function parseComputedColor(cssColor) {
            // Check if already OKLCH
            const oklchMatch = cssColor.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
            if (oklchMatch) {
                return {
                    l: parseFloat(oklchMatch[1]),
                    c: parseFloat(oklchMatch[2]),
                    h: parseFloat(oklchMatch[3])
                };
            }

            // Parse RGB (most common from getComputedStyle)
            const rgbMatch = cssColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]) / 255;
                const g = parseInt(rgbMatch[2]) / 255;
                const b = parseInt(rgbMatch[3]) / 255;

                // Simple RGB to OKLCH approximation
                // For production, use proper color space conversion
                const l = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                const c = 0.1; // Approximate chroma
                const h = 270; // Approximate hue

                return { l, c, h };
            }

            return null;
        }

        /**
         * Walk up DOM tree to find immediate background color
         */
        function getImmediateBackground(element) {
            let current = element;

            while (current && current !== document.body) {
                const style = window.getComputedStyle(current);
                const bgColor = style.backgroundColor;

                // Check if background is not transparent
                if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
                    return parseComputedColor(bgColor);
                }

                current = current.parentElement;
            }

            // Fallback to scaffold background
            return colorPalette[currentMode].background;
        }

        /**
         * Calculate MINIMAL adjustment needed for compliance
         * Returns adjusted color with smallest L/C/H change
         */
        function calculateMinimalAdjustment(textColor, bgColor, mode, targetContrast) {
            let adjustedColor = { ...textColor };
            let bestDelta = Infinity;
            let bestColor = { ...textColor };

            // Try adjusting ONLY lightness (most effective for contrast)
            for (let direction of [-1, 1]) {
                let testColor = { ...textColor };
                let step = 0.01;
                let attempts = 0;

                while (attempts < 100) {
                    testColor.l = Math.max(0, Math.min(1, testColor.l + (direction * step)));

                    let isCompliant = false;
                    if (mode === 'wcag') {
                        const contrast = calculateContrastFromObjects(testColor, bgColor);
                        isCompliant = contrast >= targetContrast;
                    } else if (mode === 'apca') {
                        const apcaValue = Math.abs(calculateAPCA(testColor, bgColor));
                        isCompliant = apcaValue >= targetContrast;
                    } else if (mode === 'readability') {
                        const targetL = bgColor.l < 0.5 ? 0.98 : 0.08;
                        testColor.l = targetL;
                        testColor.c = Math.min(0.02, testColor.c); // Minimal chroma
                        isCompliant = true;
                    }

                    if (isCompliant) {
                        const delta = Math.abs(testColor.l - textColor.l);
                        if (delta < bestDelta) {
                            bestDelta = delta;
                            bestColor = { ...testColor };
                        }
                        break;
                    }

                    attempts++;
                }
            }

            return bestColor;
        }

        /**
         * Apply compliance fixes to actual DOM text elements
         */
        function applyComplianceFixes(violations) {
            if (violations.length === 0) {
                showNotification('✅ No violations found! All text is compliant.', 2000, 'success');
                return;
            }

            console.log(`🔧 Fixing ${violations.length} text violations...`);

            violations.forEach(violation => {
                // Calculate minimal adjustment
                const adjustedColor = calculateMinimalAdjustment(
                    violation.textColor,
                    violation.bgColor,
                    violation.mode,
                    violation.targetContrast
                );

                // Apply color to element
                const colorStr = `oklch(${adjustedColor.l.toFixed(2)} ${adjustedColor.c.toFixed(2)} ${adjustedColor.h})`;
                violation.element.style.color = colorStr;

                console.log(`  ↳ Fixed: ${violation.element.tagName}.${violation.element.className}`);
                console.log(`    Old: L=${violation.textColor.l.toFixed(2)} → New: L=${adjustedColor.l.toFixed(2)}`);
            });

            showNotification(`✅ Fixed ${violations.length} text violations with minimal adjustments`, 3000, 'success');
        }

        /**
         * WCAG 2.2 AA Compliance - Scan and fix actual DOM
         */
        function fixWCAGViolations() {
            const violations = scanDOMForTextViolations('wcag');
            applyComplianceFixes(violations);
        }

        /**
         * APCA Compliance - Scan and fix actual DOM
         */
        function fixAPCAViolations() {
            const violations = scanDOMForTextViolations('apca');
            applyComplianceFixes(violations);
        }

        /**
         * Maximum Readability - Scan and fix actual DOM
         */
        function optimizeReadability() {
            const violations = scanDOMForTextViolations('readability');
            applyComplianceFixes(violations);

            // Also optimize background
            setTimeout(() => {
                const bgTarget = {
                    l: currentMode === 'dark' ? 0.08 : 0.98,
                    c: 0.01,
                    h: colorPalette[currentMode].background.h
                };
                selectColorGroup('background');
                animateColorSlide('background', bgTarget);
            }, animationSettings.duration + 100);
        }

        // ========== COLOR HARMONY DISTRIBUTIONS ==========

        /**
         * Calculates color harmony based on classical color theory
         * @param {string} harmonyType - Type of harmony (monochromatic, complementary, analogous, triadic, tetradic, split-complementary)
         * @param {Object} baseColor - Base color to derive harmony from
         * @param {number} baseColor.l - Lightness (0-1)
         * @param {number} baseColor.c - Chroma (0-0.37)
         * @param {number} baseColor.h - Hue (0-360)
         * @returns {Array<Object>} Array of color objects with l, c, h, group properties
         *
         * @description
         * Generates 6 harmonious colors based on the selected harmony type:
         * - monochromatic: Same hue, varied lightness/chroma
         * - complementary: 180° opposite hue
         * - analogous: ±30° neighbors
         * - triadic: 120° splits (equilateral triangle)
         * - tetradic: 90° splits (square)
         * - split-complementary: 180° ± 30°
         *
         * All values are clamped to valid OKLCH ranges.
         *
         * @example
         * const harmony = calculateHarmony('triadic', { l: 0.65, c: 0.18, h: 270 });
         * // Returns 6 colors at 0°, 120°, 240° hue rotations
         */
        function calculateHarmony(harmonyType, baseColor) {
            const baseHue = baseColor.h;
            const baseL = baseColor.l;
            const baseC = baseColor.c;

            let colors = [];

            switch (harmonyType) {
                case 'monochromatic':
                    // Same hue, vary lightness and chroma
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.7, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC * 1.2, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL + 0.10, c: baseC * 0.9, h: baseHue, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: baseHue, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.5, h: baseHue, group: 'surface' }
                    ];
                    break;

                case 'complementary':
                    // 180° opposite hue
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.3, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL, c: baseC * 0.9, h: (baseHue + 180) % 360, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: (baseHue + 180) % 360, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.4, h: baseHue, group: 'surface' }
                    ];
                    break;

                case 'analogous':
                    // ±30° neighbors
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.3, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL, c: baseC * 0.9, h: (baseHue + 30 + 360) % 360, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: (baseHue - 30 + 360) % 360, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.4, h: baseHue, group: 'surface' }
                    ];
                    break;

                case 'triadic':
                    // 120° splits
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.3, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL, c: baseC * 0.9, h: (baseHue + 120) % 360, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: (baseHue + 240) % 360, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.4, h: baseHue, group: 'surface' }
                    ];
                    break;

                case 'tetradic':
                    // 90° splits (square)
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.3, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL, c: baseC * 0.9, h: (baseHue + 90) % 360, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: (baseHue + 270) % 360, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.4, h: (baseHue + 180) % 360, group: 'surface' }
                    ];
                    break;

                case 'split-complementary':
                    // 180° ± 30°
                    colors = [
                        { l: Math.min(baseL + 0.30, 0.95), c: baseC * 0.3, h: baseHue, group: 'background' },
                        { l: Math.max(baseL - 0.30, 0.10), c: baseC, h: baseHue, group: 'text' },
                        { l: baseL, c: baseC, h: baseHue, group: 'primary' },
                        { l: baseL, c: baseC * 0.9, h: (baseHue + 150) % 360, group: 'secondary' },
                        { l: baseL - 0.05, c: baseC * 1.1, h: (baseHue + 210) % 360, group: 'accent' },
                        { l: Math.min(baseL + 0.20, 0.90), c: baseC * 0.4, h: baseHue, group: 'surface' }
                    ];
                    break;

                default:
                    colors = [];
            }

            // Clamp all values to valid ranges
            return colors.map(c => ({
                ...c,
                l: Math.max(0, Math.min(1, c.l)),
                c: Math.max(0, Math.min(0.37, c.c)),
                h: (c.h + 360) % 360
            }));
        }

        /**
         * Applies calculated color harmony to the entire palette with animation
         * @description
         * - Reads selected harmony type from UI
         * - Calculates 6 harmonious colors based on current color
         * - Applies each color to its assigned group with sequential animation
         * - Animation delay: (animationSettings.duration + 100ms) between each color
         *
         * @example
         * // User selects "triadic" harmony and clicks apply
         * applyHarmonyToPalette(); // Applies triadic harmony with animated transitions
         */
        function applyHarmonyToPalette() {
            const harmonyType = document.getElementById('harmony-type').value;
            const baseColor = { ...currentColor };

            // Calculate harmony colors
            const harmonyColors = calculateHarmony(harmonyType, baseColor);

            // Apply each color to its group with animation
            harmonyColors.forEach((color, index) => {
                setTimeout(() => {
                    selectColorGroup(color.group);
                    animateColorSlide(color.group, { l: color.l, c: color.c, h: color.h });
                }, index * (animationSettings.duration + 100));
            });
        }

        function initColorHarmony() {
            const applyBtn = document.getElementById('apply-harmony-btn');
            if (applyBtn) {
                applyBtn.addEventListener('click', applyHarmonyToPalette);
            }

            // Preview on hover
            const harmonySelect = document.getElementById('harmony-type');
            if (harmonySelect) {
                harmonySelect.addEventListener('change', () => {
                    updateHarmonyPreview();
                });
            }
        }

        function updateHarmonyPreview() {
            const harmonyType = document.getElementById('harmony-type').value;
            const baseColor = { ...currentColor };
            const harmonyColors = calculateHarmony(harmonyType, baseColor);

            const previewContainer = document.getElementById('harmony-preview');
            const colorsContainer = document.getElementById('harmony-colors');

            if (!previewContainer || !colorsContainer) return;

            // Show preview
            previewContainer.style.display = 'block';

            // Render color swatches
            colorsContainer.innerHTML = harmonyColors.map(color => `
                <div style="flex: 1; min-width: 40px; height: 40px; background: oklch(${color.l} ${color.c} ${color.h}); border-radius: 4px; border: 1px solid oklch(0.40 0.01 270); position: relative;">
                    <div style="position: absolute; bottom: 2px; left: 2px; font-size: 8px; font-weight: 600; color: ${color.l > 0.5 ? 'oklch(0.08 0.01 270)' : 'oklch(0.98 0.01 270)'}; text-transform: uppercase;">
                        ${color.group.substring(0, 3)}
                    </div>
                </div>
            `).join('');
        }

        // ========== INTELLIGENT RANDOM PALETTE GENERATOR ==========

        function showNotification(message, duration = 3000) {
            // Create or get notification element
            let notification = document.getElementById('random-notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'random-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: oklch(0.60 0.18 270);
                    color: white;
                    padding: 16px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    z-index: 10000;
                    transition: opacity 300ms, transform 300ms;
                    opacity: 0;
                    transform: translateX(-50%) translateY(-20px);
                `;
                document.body.appendChild(notification);
            }

            notification.innerHTML = message;
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(-50%) translateY(0)';

            if (duration > 0) {
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-50%) translateY(-20px)';
                }, duration);
            }
        }

        // ========== FLOATING LOG SYSTEM (1s lifespan, dynamic color) ==========

        const activeFloatingLogs = [];

        // ========== STUDIO SCAFFOLD NEUTRAL COLOR SYSTEM ==========
        // These colors are INDEPENDENT of theme colors - for studio UI only
        const STUDIO_COLORS = {
            // Neutral backgrounds
            toast: 'oklch(0.20 0.01 270)',           // Dark neutral for toasts
            toastBorder: 'oklch(0.35 0.01 270)',     // Subtle border
            toastText: 'oklch(0.95 0.01 270)',       // High contrast text
            toastShadow: 'rgba(0, 0, 0, 0.4)',       // Soft shadow

            // Status colors (neutral-based)
            success: 'oklch(0.50 0.12 145)',         // Soft green
            warning: 'oklch(0.65 0.15 85)',          // Soft yellow
            error: 'oklch(0.55 0.18 25)',            // Soft red
            info: 'oklch(0.60 0.15 250)',            // Soft blue

            // Modal overlay
            modalOverlay: 'rgba(0, 0, 0, 0.6)',
            modalBg: 'oklch(0.18 0.01 270)',
            modalBorder: 'oklch(0.30 0.01 270)'
        };

        function showFloatingLog(message, duration = 1000, type = 'info') {
            const log = document.createElement('div');
            log.className = 'floating-log';

            // Determine accent color based on type
            let accentColor = STUDIO_COLORS.info;
            if (type === 'success') accentColor = STUDIO_COLORS.success;
            else if (type === 'warning') accentColor = STUDIO_COLORS.warning;
            else if (type === 'error') accentColor = STUDIO_COLORS.error;

            // FIXED: Bottom-right corner with neutral studio colors
            log.style.cssText = `
                position: fixed;
                bottom: ${20 + (activeFloatingLogs.length * 60)}px;
                right: 20px;
                background: ${STUDIO_COLORS.toast};
                border: 1px solid ${STUDIO_COLORS.toastBorder};
                border-left: 3px solid ${accentColor};
                color: ${STUDIO_COLORS.toastText};
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', system-ui, sans-serif;
                z-index: 99999;
                opacity: 0;
                transition: opacity 300ms ease-out, transform 300ms ease-out;
                transform: translateX(100px);
                pointer-events: none;
                box-shadow: 0 4px 16px ${STUDIO_COLORS.toastShadow};
                min-width: 200px;
                max-width: 400px;
            `;

            log.textContent = message;
            document.body.appendChild(log);
            activeFloatingLogs.push(log);

            // Fade in
            requestAnimationFrame(() => {
                log.style.opacity = '0.9';
                log.style.transform = 'translateX(0)';
            });

            // Fade out and remove
            setTimeout(() => {
                log.style.opacity = '0';
                log.style.transform = 'translateX(20px)';

                setTimeout(() => {
                    if (document.body.contains(log)) {
                        document.body.removeChild(log);
                    }
                    const index = activeFloatingLogs.indexOf(log);
                    if (index > -1) {
                        activeFloatingLogs.splice(index, 1);
                    }

                    // Reposition remaining logs
                    activeFloatingLogs.forEach((existingLog, i) => {
                        existingLog.style.bottom = `${20 + (i * 40)}px`;
                    });
                }, 200);
            }, duration);
        }

        // ========== CUSTOM MODAL SYSTEM (Studio Scaffold) ==========

        /**
         * Shows a custom alert modal with studio scaffold styling
         * @param {string} message - Message to display
         * @param {string} title - Modal title (default: "Alert")
         * @returns {Promise<void>}
         *
         * @example
         * await customAlert('Blueprint saved successfully!', 'Success');
         */
        function customAlert(message, title = 'Alert') {
            return new Promise((resolve) => {
                const overlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('modal-title');
                const modalBody = document.getElementById('modal-body');
                const modalFooter = document.getElementById('modal-footer');

                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="margin: 0;">${message}</p>`;
                modalFooter.innerHTML = `
                    <button onclick="closeCustomModal()" style="padding: 10px 24px; background: oklch(0.60 0.18 270); border: none; border-radius: 6px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        OK
                    </button>
                `;

                overlay.style.display = 'flex';

                // Resolve when modal closes
                window._modalResolve = resolve;
            });
        }

        /**
         * Shows a custom confirm modal with Yes/No buttons
         * @param {string} message - Message to display
         * @param {string} title - Modal title (default: "Confirm")
         * @returns {Promise<boolean>} - True if confirmed, false if cancelled
         *
         * @example
         * const confirmed = await customConfirm('Delete this blueprint?', 'Confirm Delete');
         */
        function customConfirm(message, title = 'Confirm') {
            return new Promise((resolve) => {
                const overlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('modal-title');
                const modalBody = document.getElementById('modal-body');
                const modalFooter = document.getElementById('modal-footer');

                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="margin: 0;">${message}</p>`;
                modalFooter.innerHTML = `
                    <button onclick="closeCustomModal(false)" style="padding: 10px 24px; background: oklch(0.30 0.01 270); border: 1px solid oklch(0.40 0.01 270); border-radius: 6px; color: oklch(0.85 0.01 270); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        Cancel
                    </button>
                    <button onclick="closeCustomModal(true)" style="padding: 10px 24px; background: oklch(0.60 0.18 270); border: none; border-radius: 6px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        Confirm
                    </button>
                `;

                overlay.style.display = 'flex';

                // Resolve with result when modal closes
                window._modalResolve = resolve;
            });
        }

        /**
         * Shows a custom prompt modal with text input
         * @param {string} message - Message to display
         * @param {string} title - Modal title (default: "Input")
         * @param {string} defaultValue - Default input value
         * @returns {Promise<string|null>} - Input value or null if cancelled
         *
         * @example
         * const name = await customPrompt('Enter blueprint name:', 'Save Blueprint');
         */
        function customPrompt(message, title = 'Input', defaultValue = '') {
            return new Promise((resolve) => {
                const overlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('modal-title');
                const modalBody = document.getElementById('modal-body');
                const modalFooter = document.getElementById('modal-footer');

                modalTitle.textContent = title;
                modalBody.innerHTML = `
                    <p style="margin: 0 0 16px 0;">${message}</p>
                    <input type="text" id="modal-input" value="${defaultValue}" class="modal-input" />
                `;
                modalFooter.innerHTML = `
                    <button onclick="closeCustomModal(null)" style="padding: 10px 24px; background: oklch(0.30 0.01 270); border: 1px solid oklch(0.40 0.01 270); border-radius: 6px; color: oklch(0.85 0.01 270); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        Cancel
                    </button>
                    <button onclick="closeCustomModalWithInput()" style="padding: 10px 24px; background: oklch(0.60 0.18 270); border: none; border-radius: 6px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        OK
                    </button>
                `;

                overlay.style.display = 'flex';

                // Focus input and select text
                setTimeout(() => {
                    const input = document.getElementById('modal-input');
                    input.focus();
                    input.select();

                    // Allow Enter key to submit
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            closeCustomModalWithInput();
                        } else if (e.key === 'Escape') {
                            closeCustomModal(null);
                        }
                    });
                }, 100);

                // Resolve with input value when modal closes
                window._modalResolve = resolve;
            });
        }

        /**
         * Shows a custom select modal with multiple options
         * @param {string} message - Message to display
         * @param {Array<{value: string, label: string}>} options - Options to choose from
         * @param {string} title - Modal title
         * @returns {Promise<string|null>} - Selected value or null if cancelled
         *
         * @example
         * const format = await customSelect('Choose export format:', [
         *   { value: '1', label: 'CSS Variables' },
         *   { value: '2', label: 'SCSS Variables' }
         * ], 'Export Theme');
         */
        function customSelect(message, options, title = 'Select') {
            return new Promise((resolve) => {
                const overlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('modal-title');
                const modalBody = document.getElementById('modal-body');
                const modalFooter = document.getElementById('modal-footer');

                modalTitle.textContent = title;

                const optionsHTML = options.map((opt, i) => `
                    <div class="modal-option" data-value="${opt.value}" class="modal-option">
                        <span style="font-weight: 600; color: oklch(0.60 0.01 270); min-width: 24px;">${i + 1}</span>
                        <span>${opt.label}</span>
                    </div>
                `).join('');

                modalBody.innerHTML = `
                    <p style="margin: 0 0 16px 0;">${message}</p>
                    <div id="modal-options">${optionsHTML}</div>
                `;

                modalFooter.innerHTML = `
                    <button onclick="closeCustomModal(null)" style="padding: 10px 24px; background: oklch(0.30 0.01 270); border: 1px solid oklch(0.40 0.01 270); border-radius: 6px; color: oklch(0.85 0.01 270); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 200ms;">
                        Cancel
                    </button>
                `;

                overlay.style.display = 'flex';

                // Add click handlers to options
                setTimeout(() => {
                    document.querySelectorAll('.modal-option').forEach(option => {
                        option.addEventListener('mouseenter', function() {
                            this.style.background = 'oklch(0.25 0.01 270)';
                            this.style.borderColor = 'oklch(0.50 0.18 270)';
                        });
                        option.addEventListener('mouseleave', function() {
                            this.style.background = 'oklch(0.22 0.01 270)';
                            this.style.borderColor = 'oklch(0.30 0.01 270)';
                        });
                        option.addEventListener('click', function() {
                            const value = this.dataset.value;
                            closeCustomModal(value);
                        });
                    });
                }, 100);

                // Resolve with selected value when modal closes
                window._modalResolve = resolve;
            });
        }

        /**
         * Closes the custom modal and resolves with the result
         * @param {*} result - Result to resolve the promise with
         */
        function closeCustomModal(result) {
            const overlay = document.getElementById('custom-modal-overlay');
            overlay.style.display = 'none';

            if (window._modalResolve) {
                window._modalResolve(result);
                window._modalResolve = null;
            }
        }

        /**
         * Closes the modal and resolves with input value
         */
        function closeCustomModalWithInput() {
            const input = document.getElementById('modal-input');
            const value = input ? input.value : null;
            closeCustomModal(value);
        }

        // Make modal functions globally accessible
        window.customAlert = customAlert;
        window.customConfirm = customConfirm;
        window.customPrompt = customPrompt;
        window.customSelect = customSelect;
        window.closeCustomModal = closeCustomModal;
        window.closeCustomModalWithInput = closeCustomModalWithInput;

        // ========== SCREEN READER ANNOUNCER (ARIA Live Region) ==========

        /**
         * Announces message to screen readers via ARIA live region
         * @param {string} message - Message to announce
         *
         * @description
         * - Uses hidden div with aria-live="polite" for screen reader announcements
         * - Clears previous message first to ensure new message is read
         * - 100ms delay ensures screen readers detect the change
         * - Non-intrusive: doesn't interrupt current screen reader speech
         *
         * Used throughout app for accessibility:
         * - Color group selections
         * - Property changes (border-radius, padding, etc.)
         * - Mode changes (selection mode activated/deactivated)
         * - Action confirmations (save, load, export)
         *
         * @example
         * announceToScreenReader('Primary color selected');
         * announceToScreenReader('Border radius set to 12 pixels');
         */
        function announceToScreenReader(message) {
            const announcer = document.getElementById('sr-announcer');
            if (!announcer) return;

            // Clear previous announcement
            announcer.textContent = '';

            // Use setTimeout to ensure screen readers pick up the change
            setTimeout(() => {
                announcer.textContent = message;
            }, 100);
        }

        // Enhanced showFloatingLog to also announce to screen readers
        const originalShowFloatingLog = showFloatingLog;
        function showFloatingLogWithAria(message, duration = 1000) {
            originalShowFloatingLog(message, duration);
            // Remove emojis for cleaner screen reader experience
            const cleanMessage = message.replace(/[^\w\s:.,!?%$-]/g, '').trim();
            announceToScreenReader(cleanMessage);
        }

        // ========== SETTINGS PANEL SYSTEM ==========

        // Settings object with defaults
        const appSettings = {
            wcagEnforced: false,
            apcaEnforced: false,
            maxReadability: false,
            autoSave: true,
            urlUpdate: true,
            defaultMode: 'light',
            animationSpeed: 1,
            exportFormat: '1',
            show3DViewer: true
        };

        function toggleSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            const overlay = document.getElementById('settings-overlay');

            panel.classList.toggle('open');
            overlay.classList.toggle('open');

            // Announce to screen readers
            if (panel.classList.contains('open')) {
                announceToScreenReader('Settings panel opened');
            } else {
                announceToScreenReader('Settings panel closed');
            }
        }

        function toggleSetting(settingName) {
            const toggleMap = {
                'wcag': 'wcagEnforced',
                'apca': 'apcaEnforced',
                'readability': 'maxReadability',
                'autosave': 'autoSave',
                'urlUpdate': 'urlUpdate',
                '3dViewer': 'show3DViewer'
            };

            const settingKey = toggleMap[settingName];
            if (!settingKey) return;

            // Toggle setting
            appSettings[settingKey] = !appSettings[settingKey];

            // Update UI
            const toggle = document.getElementById(`toggle-${settingName.toLowerCase().replace('3d', '3d-')}`);
            if (toggle) {
                toggle.classList.toggle('active', appSettings[settingKey]);
            }

            // Save to localStorage
            saveSettings();

            // Apply settings
            applySettings();

            // Announce change
            const settingLabel = toggle?.previousElementSibling?.querySelector('.settings-option-name')?.textContent || settingName;
            const state = appSettings[settingKey] ? 'enabled' : 'disabled';
            announceToScreenReader(`${settingLabel} ${state}`);
        }

        function saveSettings() {
            try {
                localStorage.setItem('oklch-studio-settings', JSON.stringify(appSettings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        function loadSettings() {
            try {
                const saved = localStorage.getItem('oklch-studio-settings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    Object.assign(appSettings, parsed);
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }

            // Update UI to reflect loaded settings
            updateSettingsUI();
            applySettings();
        }

        function updateSettingsUI() {
            // Update toggle switches
            document.getElementById('toggle-wcag')?.classList.toggle('active', appSettings.wcagEnforced);
            document.getElementById('toggle-apca')?.classList.toggle('active', appSettings.apcaEnforced);
            document.getElementById('toggle-readability')?.classList.toggle('active', appSettings.maxReadability);
            document.getElementById('toggle-autosave')?.classList.toggle('active', appSettings.autoSave);
            document.getElementById('toggle-url-update')?.classList.toggle('active', appSettings.urlUpdate);
            document.getElementById('toggle-3d-viewer')?.classList.toggle('active', appSettings.show3DViewer);

            // Update select dropdowns
            const defaultModeSelect = document.getElementById('default-mode-select');
            if (defaultModeSelect) defaultModeSelect.value = appSettings.defaultMode;

            const animationSpeedSelect = document.getElementById('animation-speed-select');
            if (animationSpeedSelect) animationSpeedSelect.value = appSettings.animationSpeed;

            const exportFormatSelect = document.getElementById('export-format-select');
            if (exportFormatSelect) exportFormatSelect.value = appSettings.exportFormat;
        }

        function applySettings() {
            // Apply animation speed
            const speed = parseFloat(appSettings.animationSpeed);
            document.documentElement.style.setProperty('--animation-speed', speed === 0 ? '0s' : `${speed}s`);

            // Apply 3D viewer visibility
            const viewer = document.getElementById('oklch-3d-viewer');
            if (viewer) {
                viewer.style.display = appSettings.show3DViewer ? 'block' : 'none';
            }

            // Update existing checkboxes to match settings
            const wcagCheckbox = document.getElementById('allow-wcag-violation');
            if (wcagCheckbox) wcagCheckbox.checked = !appSettings.wcagEnforced;

            const apcaCheckbox = document.getElementById('allow-apca-violation');
            if (apcaCheckbox) apcaCheckbox.checked = !appSettings.apcaEnforced;

            const readabilityCheckbox = document.getElementById('ensure-max-readability');
            if (readabilityCheckbox) readabilityCheckbox.checked = appSettings.maxReadability;
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults?')) return;

            // Reset to defaults
            appSettings.wcagEnforced = false;
            appSettings.apcaEnforced = false;
            appSettings.maxReadability = false;
            appSettings.autoSave = true;
            appSettings.urlUpdate = true;
            appSettings.defaultMode = 'light';
            appSettings.animationSpeed = 1;
            appSettings.exportFormat = '1';
            appSettings.show3DViewer = true;

            // Save and apply
            saveSettings();
            updateSettingsUI();
            applySettings();

            announceToScreenReader('Settings reset to defaults');
            showFloatingLogWithAria('⚙️ Settings reset', 1500);
        }

        function clearPalette() {
            if (!confirm('Clear saved palette from localStorage?')) return;

            try {
                localStorage.removeItem('oklch-studio-palette');
                showFloatingLogWithAria('🗑️ Palette cleared', 1500);
                announceToScreenReader('Saved palette cleared');
            } catch (e) {
                console.error('Failed to clear palette:', e);
            }
        }

        // ========== EXPORT ALL DATA & REFRESH SYSTEM ==========
        /**
         * 💾 COMPLETE STATE SNAPSHOT EXPORT + PAGE REFRESH
         *
         * Exports ALL current data before refreshing:
         * - Both light and dark color palettes (complete state)
         * - Current mode and selected color group
         * - App settings and preferences
         * - Undo/redo history (if available)
         * - Counter-weight configurations
         * - Template settings
         * - Timestamp for tracking
         *
         * Downloads as timestamped JSON file, then reloads page
         */
        function exportAllDataAndRefresh() {
            console.log('💾 ========== EXPORTING COMPLETE STATE SNAPSHOT ==========');

            try {
                // ========== COLLECT ALL CURRENT STATE ==========

                // 1. Color Palettes (BOTH light and dark)
                const completeStateSnapshot = {
                    exportInfo: {
                        source: 'UI-CONFIGPRO',
                        version: '2.0',
                        timestamp: new Date().toISOString(),
                        userAgent: navigator.userAgent
                    },

                    // 2. Color Palette State (COMPLETE)
                    colorPalettes: {
                        light: { ...colorPalette.light },
                        dark: { ...colorPalette.dark }
                    },

                    // 3. Current UI State
                    currentState: {
                        mode: currentMode,
                        group: currentGroup,
                        color: { ...currentColor }
                    },

                    // 4. App Settings
                    settings: { ...appSettings },

                    // 5. Transformation Settings
                    transformations: {
                        activeTemplate: activeTemplate,
                        adjustments: { ...templateAdjustments }
                    },

                    // 6. Scaffold Theme Settings
                    scaffoldTheme: {
                        mode: scaffoldThemeMode,
                        manualChoice: manualThemeChoice
                    },

                    // 7. Undo/Redo History (if available)
                    history: {
                        undo: window.undoStack ? [...window.undoStack] : [],
                        redo: window.redoStack ? [...window.redoStack] : []
                    },

                    // 8. CSS Variables Snapshot (current applied colors)
                    appliedColors: {}
                };

                // Capture current CSS variables
                const root = document.documentElement;
                ['primary', 'secondary', 'accent', 'background', 'surface', 'text'].forEach(group => {
                    completeStateSnapshot.appliedColors[group] = getComputedStyle(root).getPropertyValue(`--${group}`).trim();
                });

                console.log('✅ State collected:', {
                    lightPalette: Object.keys(completeStateSnapshot.colorPalettes.light).length + ' colors',
                    darkPalette: Object.keys(completeStateSnapshot.colorPalettes.dark).length + ' colors',
                    currentMode: completeStateSnapshot.currentState.mode,
                    historySize: completeStateSnapshot.history.undo.length + completeStateSnapshot.history.redo.length
                });

                // ========== CREATE JSON FILE ==========
                const json = JSON.stringify(completeStateSnapshot, null, 2);
                const blob = new Blob([json], { type: 'application/json' });

                // ========== GENERATE FILENAME WITH TIMESTAMP ==========
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
                const filename = `UI-CONFIGPRO_snapshot_${dateStr}_${timeStr}.json`;

                console.log(`📥 Downloading: ${filename} (${(blob.size / 1024).toFixed(2)} KB)`);

                // ========== TRIGGER DOWNLOAD ==========
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();

                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

                // Show notification
                showNotification(`💾 Exporting ${filename}...`, 1500);

                console.log('✅ Download triggered successfully');
                console.log('🔄 Page will refresh in 800ms...');

                // ========== WAIT FOR DOWNLOAD, THEN REFRESH ==========
                // Give browser time to complete download before refresh
                setTimeout(() => {
                    console.log('🔄 Refreshing page now...');
                    window.location.reload();
                }, 800);

            } catch (error) {
                console.error('❌ Export failed:', error);
                showNotification(`❌ Export failed: ${error.message}`, 3000);
            }
        }

        // ========== 🔬 DIAGNOSTIC LENS SYSTEM - The Mathematician's Eye ==========

        // Global diagnostic data cache
        let diagnosticData = {
            atoms: [],
            pairs: {},
            topology: {},
            patterns: [],
            lastScan: null
        };

        /**
         * Run full diagnostic scan of UI state
         * Maps all atoms, color-group pairs, and metadata
         */
        function runDiagnosticScan() {
            console.log('🔬 ========== DIAGNOSTIC SCAN STARTED ==========');

            // 1. ATOM MAPPING: Scan all elements with data-color-group
            const atoms = [];
            const allElements = document.querySelectorAll('[data-color-group]');

            console.log(`📊 Found ${allElements.length} elements with color groups`);

            allElements.forEach((element, index) => {
                const colorGroup = element.dataset.colorGroup;
                const componentType = element.classList[0] || element.tagName.toLowerCase();
                const pairKey = `${colorGroup}|${componentType}`;

                // Get computed colors
                const computed = window.getComputedStyle(element);
                const bgColor = computed.backgroundColor;
                const textColor = computed.color;
                const borderColor = computed.borderColor;

                // Parse OKLCH values if possible
                const bgOKLCH = parseOKLCHFromComputed(bgColor);
                const textOKLCH = parseOKLCHFromComputed(textColor);

                atoms.push({
                    index: index,
                    element: element,
                    colorGroup: colorGroup,
                    componentType: componentType,
                    pairKey: pairKey,
                    backgroundColor: bgColor,
                    backgroundOKLCH: bgOKLCH,
                    textColor: textColor,
                    textOKLCH: textOKLCH,
                    borderColor: borderColor,
                    // Metadata
                    position: element.getBoundingClientRect(),
                    visible: computed.display !== 'none' && computed.visibility !== 'hidden'
                });
            });

            // 2. PAIR AGGREGATION: Group atoms by color-group pair
            const pairs = {};
            atoms.forEach(atom => {
                if (!pairs[atom.pairKey]) {
                    pairs[atom.pairKey] = {
                        pairKey: atom.pairKey,
                        colorGroup: atom.colorGroup,
                        componentType: atom.componentType,
                        atoms: [],
                        count: 0,
                        trajectory: TRAJECTORY_MAP[`${atom.colorGroup}|${atom.componentType}`] || null
                    };
                }
                pairs[atom.pairKey].atoms.push(atom);
                pairs[atom.pairKey].count++;
            });

            // 3. TOPOLOGY ANALYSIS: Build counter-weight influence graph
            const topology = buildTopologyGraph(pairs);

            // 4. PATTERN ANALYSIS: Find calibration opportunities
            const patterns = analyzePatterns(atoms, pairs, topology);

            // 5. CACHE RESULTS
            diagnosticData = {
                atoms: atoms,
                pairs: pairs,
                topology: topology,
                patterns: patterns,
                lastScan: new Date().toISOString()
            };

            // 6. UPDATE UI
            document.getElementById('diagnostic-atoms-count').textContent = atoms.length;
            document.getElementById('diagnostic-pairs-count').textContent = Object.keys(pairs).length;

            // 7. DISPLAY RESULTS (start with ATOMS view)
            displayDiagnosticResults('atoms');
            document.getElementById('diagnostic-results').style.display = 'block';

            console.log(`✅ Scan complete: ${atoms.length} atoms, ${Object.keys(pairs).length} pairs, ${patterns.length} patterns`);
            showNotification(`🔬 Diagnostic scan complete: ${atoms.length} atoms analyzed`, 2000);
        }

        /**
         * Parse OKLCH values from computed color string
         * Handles oklch(), rgb(), rgba() formats
         */
        function parseOKLCHFromComputed(colorStr) {
            if (!colorStr) return null;

            // Check if it's already OKLCH format
            const oklchMatch = colorStr.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
            if (oklchMatch) {
                return {
                    l: parseFloat(oklchMatch[1]),
                    c: parseFloat(oklchMatch[2]),
                    h: parseFloat(oklchMatch[3])
                };
            }

            // If RGB, convert to OKLCH (approximate)
            const rgbMatch = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]) / 255;
                const g = parseInt(rgbMatch[2]) / 255;
                const b = parseInt(rgbMatch[3]) / 255;
                // Approximate lightness from RGB
                const l = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                return { l: l, c: 0, h: 0, approximate: true };
            }

            return null;
        }

        /**
         * Build topology graph showing counter-weight relationships
         * Each pair influences related pairs through trajectory formulas
         */
        function buildTopologyGraph(pairs) {
            const topology = {
                nodes: [],
                edges: [],
                dimensions: 42 // 14 color-groups × 3 params (L/C/H)
            };

            // Create nodes for each pair
            Object.values(pairs).forEach(pair => {
                topology.nodes.push({
                    id: pair.pairKey,
                    colorGroup: pair.colorGroup,
                    componentType: pair.componentType,
                    atomCount: pair.count,
                    hasTrajectory: !!pair.trajectory
                });
            });

            // Create edges based on trajectory relationships
            Object.values(pairs).forEach(pair => {
                if (!pair.trajectory) return;

                // Find related pairs (same color group, different component)
                Object.values(pairs).forEach(targetPair => {
                    if (targetPair.pairKey === pair.pairKey) return;
                    if (targetPair.colorGroup !== pair.colorGroup) return;

                    // Calculate influence strength based on trajectory formula
                    const influence = calculateInfluenceStrength(pair, targetPair);

                    topology.edges.push({
                        from: pair.pairKey,
                        to: targetPair.pairKey,
                        strength: influence,
                        type: 'trajectory'
                    });
                });
            });

            return topology;
        }

        /**
         * Calculate influence strength between two pairs
         * Based on trajectory formula similarity and lightness/chroma deltas
         */
        function calculateInfluenceStrength(pair1, pair2) {
            // Simplified influence calculation
            // In reality, this would analyze trajectory formula coefficients
            const baseInfluence = 0.5;

            // Boost influence for primary → secondary relationships
            if (pair1.colorGroup === 'primary' && pair2.colorGroup === 'secondary') {
                return baseInfluence * 1.5;
            }

            return baseInfluence;
        }

        /**
         * Analyze patterns to find calibration opportunities
         * Uses mathematical reasoning to detect harmony violations
         */
        function analyzePatterns(atoms, pairs, topology) {
            const patterns = [];

            // PATTERN 1: Contrast violations
            atoms.forEach(atom => {
                if (!atom.backgroundOKLCH || !atom.textOKLCH) return;

                const contrast = calculateContrastRatio(
                    atom.backgroundOKLCH.l,
                    atom.textOKLCH.l
                );

                if (contrast < 4.5 && atom.visible) {
                    patterns.push({
                        type: 'contrast-violation',
                        severity: 'high',
                        atom: atom,
                        contrast: contrast.toFixed(2),
                        required: 4.5,
                        recommendation: `Adjust ${atom.colorGroup} lightness trajectory`
                    });
                }
            });

            // PATTERN 2: Chroma oversaturation in text
            atoms.forEach(atom => {
                if (!atom.textOKLCH || !atom.visible) return;

                if (atom.textOKLCH.c > 0.02) {
                    patterns.push({
                        type: 'chroma-oversaturation',
                        severity: 'medium',
                        atom: atom,
                        chroma: atom.textOKLCH.c.toFixed(3),
                        maxRecommended: 0.02,
                        recommendation: `Cap text chroma at 0.02 for ${atom.colorGroup}`
                    });
                }
            });

            // PATTERN 3: Color-group pairs with no trajectory
            Object.values(pairs).forEach(pair => {
                if (!pair.trajectory && pair.count > 0) {
                    patterns.push({
                        type: 'missing-trajectory',
                        severity: 'low',
                        pair: pair,
                        recommendation: `Add trajectory formula for ${pair.pairKey}`
                    });
                }
            });

            // PATTERN 4: Similar lightness across different color groups (harmony violation)
            const colorGroups = ['primary', 'secondary', 'accent'];
            for (let i = 0; i < colorGroups.length; i++) {
                for (let j = i + 1; j < colorGroups.length; j++) {
                    const group1 = colorGroups[i];
                    const group2 = colorGroups[j];

                    const atoms1 = atoms.filter(a => a.colorGroup === group1 && a.backgroundOKLCH);
                    const atoms2 = atoms.filter(a => a.colorGroup === group2 && a.backgroundOKLCH);

                    if (atoms1.length > 0 && atoms2.length > 0) {
                        const avgL1 = atoms1.reduce((sum, a) => sum + a.backgroundOKLCH.l, 0) / atoms1.length;
                        const avgL2 = atoms2.reduce((sum, a) => sum + a.backgroundOKLCH.l, 0) / atoms2.length;

                        const delta = Math.abs(avgL1 - avgL2);

                        if (delta < 0.10) {
                            patterns.push({
                                type: 'harmony-violation',
                                severity: 'medium',
                                group1: group1,
                                group2: group2,
                                avgL1: avgL1.toFixed(2),
                                avgL2: avgL2.toFixed(2),
                                delta: delta.toFixed(2),
                                recommendation: `Increase lightness separation between ${group1} and ${group2} (current: ${delta.toFixed(2)}, recommended: >0.15)`
                            });
                        }
                    }
                }
            }

            return patterns;
        }

        /**
         * Display diagnostic results based on selected view
         */
        function displayDiagnosticResults(view) {
            const resultsDiv = document.getElementById('diagnostic-results');

            if (diagnosticData.atoms.length === 0) {
                resultsDiv.innerHTML = '<div style="color: var(--scaffold-text-muted); text-align: center; padding: 20px;">No data. Run a scan first.</div>';
                return;
            }

            let html = '';

            switch (view) {
                case 'atoms':
                    html = renderAtomsView();
                    break;
                case 'topology':
                    html = renderTopologyView();
                    break;
                case 'patterns':
                    html = renderPatternsView();
                    break;
                case 'weights':
                    html = renderWeightsView();
                    break;
            }

            resultsDiv.innerHTML = html;
        }

        /**
         * Render ATOMS view: List all elements with their color-group pairs
         */
        function renderAtomsView() {
            let html = '<div style="font-size: 11px;">';
            html += `<div style="color: var(--scaffold-text-muted); margin-bottom: 8px;">Showing ${diagnosticData.atoms.length} atoms</div>`;

            // Group by color group
            const groupedByColorGroup = {};
            diagnosticData.atoms.forEach(atom => {
                if (!groupedByColorGroup[atom.colorGroup]) {
                    groupedByColorGroup[atom.colorGroup] = [];
                }
                groupedByColorGroup[atom.colorGroup].push(atom);
            });

            Object.keys(groupedByColorGroup).sort().forEach(colorGroup => {
                const atoms = groupedByColorGroup[colorGroup];
                html += `<div style="margin-bottom: 12px; padding: 8px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border);">`;
                html += `<div style="font-weight: 700; color: var(--scaffold-text); margin-bottom: 6px; text-transform: uppercase; font-size: 10px;">${colorGroup} (${atoms.length})</div>`;

                atoms.forEach(atom => {
                    const bgOKLCH = atom.backgroundOKLCH;
                    const textOKLCH = atom.textOKLCH;

                    html += `<div style="padding: 6px; margin-bottom: 4px; background: var(--scaffold-bg); border-radius: 4px; border: 1px solid var(--scaffold-border);">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div style="font-weight: 600; color: var(--scaffold-text);">${atom.componentType}</div>`;
                    html += `<div style="font-size: 10px; color: var(--scaffold-text-muted);">${atom.pairKey}</div>`;
                    html += `</div>`;

                    if (bgOKLCH) {
                        html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px;">`;
                        html += `BG: L=${bgOKLCH.l.toFixed(2)} C=${bgOKLCH.c.toFixed(2)} H=${bgOKLCH.h.toFixed(0)}°`;
                        if (bgOKLCH.approximate) html += ' <span style="color: orange;">(approx)</span>';
                        html += `</div>`;
                    }

                    if (textOKLCH) {
                        html += `<div style="font-size: 10px; color: var(--scaffold-text-muted);">`;
                        html += `Text: L=${textOKLCH.l.toFixed(2)} C=${textOKLCH.c.toFixed(2)} H=${textOKLCH.h.toFixed(0)}°`;
                        if (textOKLCH.approximate) html += ' <span style="color: orange;">(approx)</span>';
                        html += `</div>`;
                    }

                    html += `</div>`;
                });

                html += `</div>`;
            });

            html += '</div>';
            return html;
        }

        /**
         * Render TOPOLOGY view: Counter-weight influence graph
         */
        function renderTopologyView() {
            const topology = diagnosticData.topology;

            let html = '<div style="font-size: 11px;">';
            html += `<div style="color: var(--scaffold-text-muted); margin-bottom: 8px;">`;
            html += `${topology.nodes.length} nodes, ${topology.edges.length} edges, ${topology.dimensions}D space`;
            html += `</div>`;

            // Render nodes
            html += `<div style="margin-bottom: 12px; padding: 8px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border);">`;
            html += `<div style="font-weight: 700; color: var(--scaffold-text); margin-bottom: 6px; text-transform: uppercase; font-size: 10px;">NODES (Color-Component Pairs)</div>`;

            topology.nodes.forEach(node => {
                html += `<div style="padding: 6px; margin-bottom: 4px; background: var(--scaffold-bg); border-radius: 4px; border: 1px solid var(--scaffold-border);">`;
                html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
                html += `<div style="font-weight: 600; color: var(--scaffold-text);">${node.id}</div>`;
                html += `<div style="display: flex; gap: 8px; align-items: center;">`;
                html += `<span style="font-size: 10px; color: var(--scaffold-text-muted);">${node.atomCount} atoms</span>`;
                html += `<span style="font-size: 10px; padding: 2px 6px; background: ${node.hasTrajectory ? 'oklch(0.40 0.15 140)' : 'oklch(0.35 0.10 30)'}; border-radius: 3px; color: white;">${node.hasTrajectory ? '✓ trajectory' : '✕ no formula'}</span>`;
                html += `</div>`;
                html += `</div>`;
                html += `</div>`;
            });

            html += `</div>`;

            // Render edges
            if (topology.edges.length > 0) {
                html += `<div style="padding: 8px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border);">`;
                html += `<div style="font-weight: 700; color: var(--scaffold-text); margin-bottom: 6px; text-transform: uppercase; font-size: 10px;">EDGES (Influences)</div>`;

                topology.edges.slice(0, 20).forEach(edge => {
                    html += `<div style="padding: 6px; margin-bottom: 4px; background: var(--scaffold-bg); border-radius: 4px; border: 1px solid var(--scaffold-border);">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div style="font-size: 10px; color: var(--scaffold-text);">${edge.from} → ${edge.to}</div>`;
                    html += `<div style="font-size: 10px; padding: 2px 6px; background: oklch(0.40 0.15 270); border-radius: 3px; color: white;">strength: ${edge.strength.toFixed(2)}</div>`;
                    html += `</div>`;
                    html += `</div>`;
                });

                if (topology.edges.length > 20) {
                    html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center; margin-top: 4px;">Showing 20 of ${topology.edges.length} edges</div>`;
                }

                html += `</div>`;
            } else {
                html += `<div style="color: var(--scaffold-text-muted); text-align: center; padding: 20px;">No trajectory influences detected</div>`;
            }

            html += '</div>';
            return html;
        }

        /**
         * Render PATTERNS view: Calibration opportunities
         */
        function renderPatternsView() {
            const patterns = diagnosticData.patterns;

            let html = '<div style="font-size: 11px;">';

            if (patterns.length === 0) {
                html += `<div style="color: var(--scaffold-text-muted); text-align: center; padding: 20px;">`;
                html += `✅ No calibration issues detected. System is well-tuned!`;
                html += `</div>`;
            } else {
                html += `<div style="color: var(--scaffold-text-muted); margin-bottom: 8px;">${patterns.length} patterns detected</div>`;

                // Group by severity
                const byType = {
                    'contrast-violation': [],
                    'chroma-oversaturation': [],
                    'missing-trajectory': [],
                    'harmony-violation': []
                };

                patterns.forEach(p => {
                    if (byType[p.type]) {
                        byType[p.type].push(p);
                    }
                });

                // Render each type
                Object.keys(byType).forEach(type => {
                    const typePatterns = byType[type];
                    if (typePatterns.length === 0) return;

                    const typeNames = {
                        'contrast-violation': '⚠️ Contrast Violations',
                        'chroma-oversaturation': '🎨 Chroma Oversaturation',
                        'missing-trajectory': '📐 Missing Trajectories',
                        'harmony-violation': '🎵 Harmony Issues'
                    };

                    html += `<div style="margin-bottom: 12px; padding: 8px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border);">`;
                    html += `<div style="font-weight: 700; color: var(--scaffold-text); margin-bottom: 6px; text-transform: uppercase; font-size: 10px;">${typeNames[type]} (${typePatterns.length})</div>`;

                    typePatterns.slice(0, 10).forEach(pattern => {
                        const severityColors = {
                            high: 'oklch(0.50 0.20 30)',
                            medium: 'oklch(0.60 0.20 70)',
                            low: 'oklch(0.55 0.15 200)'
                        };

                        html += `<div style="padding: 6px; margin-bottom: 4px; background: var(--scaffold-bg); border-radius: 4px; border: 1px solid var(--scaffold-border);">`;
                        html += `<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px;">`;

                        if (pattern.atom) {
                            html += `<div style="font-weight: 600; color: var(--scaffold-text);">${pattern.atom.pairKey}</div>`;
                        } else if (pattern.pair) {
                            html += `<div style="font-weight: 600; color: var(--scaffold-text);">${pattern.pair.pairKey}</div>`;
                        } else if (pattern.group1) {
                            html += `<div style="font-weight: 600; color: var(--scaffold-text);">${pattern.group1} ↔ ${pattern.group2}</div>`;
                        }

                        html += `<span style="font-size: 10px; padding: 2px 6px; background: ${severityColors[pattern.severity]}; border-radius: 3px; color: white;">${pattern.severity}</span>`;
                        html += `</div>`;

                        if (pattern.contrast) {
                            html += `<div style="font-size: 10px; color: var(--scaffold-text-muted);">Contrast: ${pattern.contrast}:1 (need ${pattern.required}:1)</div>`;
                        }

                        if (pattern.chroma) {
                            html += `<div style="font-size: 10px; color: var(--scaffold-text-muted);">Chroma: ${pattern.chroma} (max ${pattern.maxRecommended})</div>`;
                        }

                        if (pattern.delta) {
                            html += `<div style="font-size: 10px; color: var(--scaffold-text-muted);">Lightness delta: ${pattern.delta} (too similar)</div>`;
                        }

                        html += `<div style="font-size: 10px; color: oklch(0.60 0.15 270); margin-top: 4px; font-style: italic;">💡 ${pattern.recommendation}</div>`;
                        html += `</div>`;
                    });

                    if (typePatterns.length > 10) {
                        html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); text-align: center; margin-top: 4px;">Showing 10 of ${typePatterns.length} patterns</div>`;
                    }

                    html += `</div>`;
                });
            }

            html += '</div>';
            return html;
        }

        /**
         * Render WEIGHTS view: Fine-tuning editor
         */
        function renderWeightsView() {
            let html = '<div style="font-size: 11px;">';
            html += `<div style="color: var(--scaffold-text-muted); margin-bottom: 8px;">Weight adjustment controls for trajectory formulas</div>`;

            // Render weight controls for each color group
            const colorGroups = ['primary', 'secondary', 'accent', 'neutral', 'success', 'warning', 'danger', 'info'];

            colorGroups.forEach(colorGroup => {
                html += `<div style="margin-bottom: 12px; padding: 8px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border);">`;
                html += `<div style="font-weight: 700; color: var(--scaffold-text); margin-bottom: 6px; text-transform: uppercase; font-size: 10px;">${colorGroup}</div>`;

                // Lightness weight
                html += `<div style="margin-bottom: 8px;">`;
                html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); margin-bottom: 2px;">Lightness Trajectory Weight</div>`;
                html += `<input type="range" min="0" max="2" step="0.1" value="1.0" style="width: 100%;" onchange="updateTrajectoryWeight('${colorGroup}', 'l', this.value)">`;
                html += `<div style="font-size: 10px; color: var(--scaffold-text); text-align: right;">1.0x</div>`;
                html += `</div>`;

                // Chroma weight
                html += `<div style="margin-bottom: 8px;">`;
                html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); margin-bottom: 2px;">Chroma Boost Weight</div>`;
                html += `<input type="range" min="0" max="2" step="0.1" value="1.1" style="width: 100%;" onchange="updateTrajectoryWeight('${colorGroup}', 'c', this.value)">`;
                html += `<div style="font-size: 10px; color: var(--scaffold-text); text-align: right;">1.1x</div>`;
                html += `</div>`;

                html += `</div>`;
            });

            html += `<div style="padding: 12px; background: var(--scaffold-bg-elevated); border-radius: 6px; border: 1px solid var(--scaffold-border); margin-top: 12px;">`;
            html += `<div style="font-size: 10px; color: var(--scaffold-text-muted); line-height: 1.5;">`;
            html += `💡 <strong>Weight Editor</strong>: Adjust trajectory formulas to fine-tune color transformations. `;
            html += `Changes are applied in real-time to the counter-weight system. Use this to calibrate the 42D hyper-space.`;
            html += `</div>`;
            html += `</div>`;

            html += '</div>';
            return html;
        }

        /**
         * Update trajectory weight (placeholder for future implementation)
         */
        function updateTrajectoryWeight(colorGroup, param, value) {
            console.log(`🎛️ Updating weight: ${colorGroup}.${param} = ${value}`);
            // TODO: Implement actual trajectory formula adjustment
            showNotification(`Updated ${colorGroup} ${param} weight to ${value}x`, 2000);
        }

        // ========== UI COMMANDMENTS INTERACTION FUNCTIONS ==========

        /**
         * Toggle individual commandment category expand/collapse
         */
        function toggleCommandmentCategory(button) {
            const icon = button.querySelector('span:first-child');
            const content = button.parentElement.querySelector('.commandment-content');

            const isCollapsed = content.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                content.style.opacity = '1';
                icon.style.transform = 'rotate(90deg)';
            } else {
                // Collapse
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                content.style.opacity = '0';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        /**
         * Expand all commandment categories
         */
        function expandAllCommandments() {
            const allContents = document.querySelectorAll('.commandment-content');
            const allIcons = document.querySelectorAll('.commandment-header span:first-child');

            allContents.forEach(content => {
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                content.style.opacity = '1';
            });

            allIcons.forEach(icon => {
                icon.style.transform = 'rotate(90deg)';
            });

            showNotification('📜 All commandments expanded', 1500);
        }

        /**
         * Collapse all commandment categories
         */
        function collapseAllCommandments() {
            const allContents = document.querySelectorAll('.commandment-content');
            const allIcons = document.querySelectorAll('.commandment-header span:first-child');

            allContents.forEach(content => {
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                content.style.opacity = '0';
            });

            allIcons.forEach(icon => {
                icon.style.transform = 'rotate(0deg)';
            });

            showNotification('📜 All commandments collapsed', 1500);
        }

        // Tab switching for diagnostic views
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('diagnostic-tab')) {
                const view = e.target.dataset.view;

                // Update active state
                document.querySelectorAll('.diagnostic-tab').forEach(tab => {
                    tab.classList.remove('active');
                    tab.style.background = 'var(--scaffold-bg)';
                });
                e.target.classList.add('active');
                e.target.style.background = 'var(--scaffold-bg-elevated)';

                // Display selected view
                displayDiagnosticResults(view);
            }
        });

        // Listen for select changes
        document.addEventListener('DOMContentLoaded', () => {
            const defaultModeSelect = document.getElementById('default-mode-select');
            if (defaultModeSelect) {
                defaultModeSelect.addEventListener('change', (e) => {
                    appSettings.defaultMode = e.target.value;
                    saveSettings();
                });
            }

            const animationSpeedSelect = document.getElementById('animation-speed-select');
            if (animationSpeedSelect) {
                animationSpeedSelect.addEventListener('change', (e) => {
                    appSettings.animationSpeed = parseFloat(e.target.value);
                    saveSettings();
                    applySettings();
                });
            }

            const exportFormatSelect = document.getElementById('export-format-select');
            if (exportFormatSelect) {
                exportFormatSelect.addEventListener('change', (e) => {
                    appSettings.exportFormat = e.target.value;
                    saveSettings();
                });
            }

            // Load settings on startup
            loadSettings();

            // ESC key closes settings panel
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const panel = document.getElementById('settings-panel');
                    if (panel?.classList.contains('open')) {
                        toggleSettingsPanel();
                    }
                }
            });
        });

        /**
         * Generate random palette using COUNTER-WEIGHT TRAJECTORY SYSTEM
         * @description
         * NEW APPROACH (2025-10-12):
         * - Pick ONE random PRIMARY color
         * - Use trajectory formulas to compute ALL related COLOR-COMPONENT PAIRS
         * - Let the 42-dimensional hyper-space maintain mathematical coherence
         * - Override only background/text if compliance demands it
         *
         * OLD APPROACH (bypassed trajectory system):
         * - Generated 6 separate colors using harmony calculations
         * - Manually adjusted each for compliance
         * - No mathematical relationship between colors
         */
        function generateRandomCompliantPalette() {
            console.log('🎲 ========== COUNTER-WEIGHT-AWARE RANDOM PALETTE ==========');

            // Check current compliance settings
            const wcagEnforced = !document.getElementById('allow-wcag-violation')?.checked;
            const apcaEnforced = !document.getElementById('allow-apca-violation')?.checked;
            const maxReadEnabled = document.getElementById('ensure-max-readability')?.checked;

            // ========== STEP 1: Generate ONE random PRIMARY color ==========

            const baseHue = Math.random() * 360;
            let baseL, baseC;

            if (currentMode === 'dark') {
                baseL = 0.50 + Math.random() * 0.30; // 0.50-0.80
                baseC = 0.10 + Math.random() * 0.15; // 0.10-0.25
            } else {
                baseL = 0.45 + Math.random() * 0.25; // 0.45-0.70
                baseC = 0.10 + Math.random() * 0.15; // 0.10-0.25
            }

            // ========== INTEGRATED: Color name in console log ==========
            const baseColor = { l: baseL, c: baseC, h: baseHue };
            const baseColorName = getClosestColorName(baseColor);
            console.log(`🎯 Random PRIMARY: ${baseColorName} (L=${baseL.toFixed(2)}, C=${baseC.toFixed(2)}, H=${baseHue.toFixed(0)}°)`);

            // ========== INTEGRATED: Color name in notification ==========
            const complianceMode = maxReadEnabled ? 'Max Readability' :
                                 (wcagEnforced ? 'WCAG 2.2' :
                                 (apcaEnforced ? 'APCA' : 'Free'));
            showNotification(`
                🎲 Generating <strong>${baseColorName}</strong> Counter-Weight palette<br>
                Base Color: <strong>${baseColorName}</strong> at ${baseHue.toFixed(0)}° | Mode: <strong>${complianceMode}</strong><br>
                <small>Using trajectory formulas for all related pairs</small>
            `, 0);

            // ========== STEP 2: Apply PRIMARY using trajectory system ==========

            // Select primary color group
            selectColorGroup('primary');

            // Store old primary color for trajectory calculation
            const oldPrimary = { ...colorPalette[currentMode]['primary'] };

            // Apply new primary color with trajectory system
            setTimeout(() => {
                // ========== INTEGRATED: Color name in step notification ==========
                showNotification(`
                    🎲 <strong>Step 1/3:</strong> Setting PRIMARY to <strong>${baseColorName}</strong><br>
                    <small>L=${baseL.toFixed(2)}, C=${baseC.toFixed(2)}, H=${baseHue.toFixed(0)}°</small>
                `, 0);

                // Update all three parameters sequentially to trigger trajectory formulas
                updateColorParameter('primary', 'l', baseL);

                setTimeout(() => {
                    updateColorParameter('primary', 'c', baseC);

                    setTimeout(() => {
                        updateColorParameter('primary', 'h', baseHue);

                        // ========== STEP 3: Let trajectory system compute related pairs ==========
                        setTimeout(() => {
                            showNotification(`
                                ⚖️ <strong>Step 2/3:</strong> Counter-Weight adjustments<br>
                                <small>Trajectory formulas computing related pairs...</small>
                            `, 0);

                            // All COLOR-COMPONENT PAIRS have already been adjusted by trajectory formulas!
                            // The updateColorParameter() calls above triggered:
                            // - counterWeightSystem.applyTrajectory()
                            // - counterWeightSystem.applyAdjustments()
                            // This automatically updated all 14 COLOR-COMPONENT PAIRS

                            console.log('⚖️ Counter-weight trajectory adjustments complete!');

                            // ========== STEP 4: Compliance overrides (if needed) ==========
                            setTimeout(() => {
                                if (wcagEnforced || apcaEnforced || maxReadEnabled) {
                                    showNotification(`
                                        📏 <strong>Step 3/3:</strong> Compliance adjustments<br>
                                        <small>Ensuring WCAG/APCA standards...</small>
                                    `, 0);

                                    // Background: Ensure extreme lightness
                                    const bgL = currentMode === 'dark' ? 0.08 : 0.95;
                                    updateColorParameter('background', 'l', bgL);
                                    updateColorParameter('background', 'c', 0.01);

                                    // Text: Ensure high contrast
                                    if (maxReadEnabled) {
                                        const textL = currentMode === 'dark' ? 0.98 : 0.08;
                                        updateColorParameter('text', 'l', textL);
                                        updateColorParameter('text', 'c', 0.01);
                                    } else {
                                        const textL = currentMode === 'dark' ? 0.90 : 0.15;
                                        updateColorParameter('text', 'l', textL);
                                    }

                                    console.log('📏 Compliance overrides applied');
                                }

                                // ========== STEP 5: Update all visualizations ==========
                                setTimeout(() => {
                                    updateColorPaletteMap();

                                    // ========== INTEGRATED: Update all color names after random palette ==========
                                    updateAllColorNames();

                                    // ========== INTEGRATED: Color name in completion notification ==========
                                    showNotification(`
                                        ✅ <strong>${baseColorName} Counter-Weight Palette Complete!</strong><br>
                                        ${baseColorName} PRIMARY → All pairs computed via trajectory formulas<br>
                                        <small>${complianceMode} compliance maintained</small>
                                    `, 3000);

                                    console.log(`✅ ${baseColorName} random palette generation complete!`);
                                    console.log('🎯 All COLOR-COMPONENT PAIRS updated via trajectory system');
                                }, 300);
                            }, 400);
                        }, 300);
                    }, 200);
                }, 200);
            }, 200);
        }

        function initRandomPalette() {
            const randomBtn = document.getElementById('random-palette-btn');
            if (randomBtn) {
                randomBtn.addEventListener('click', generateRandomCompliantPalette);
            }
        }

        // ========== GLOBAL VALIDATION UI ==========

        function initValidationButton() {
            const validateBtn = document.getElementById('validate-btn');
            if (validateBtn) {
                validateBtn.addEventListener('click', runGlobalValidation);
            }
        }

        function runGlobalValidation() {
            console.log('🔍 Running Global Validation...');

            // Run validation
            const results = globalColorValidator.validate();

            // Update Color Palette Map to show violations
            updateColorPaletteMap();

            // Show validation modal with results
            showValidationReport(results);
        }

        function showValidationReport(results) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(4px);
            `;

            // Create modal content
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: var(--scaffold-bg-elevated);
                border: 1px solid var(--scaffold-border);
                border-radius: 12px;
                padding: 24px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;

            const violationsByGroup = globalColorValidator.getViolationsByGroup();

            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: var(--scaffold-text); font-size: 20px;">🔍 Global Validation Report</h2>
                    <button id="close-validation-modal" style="background: transparent; border: none; color: var(--scaffold-text-muted); font-size: 24px; cursor: pointer; padding: 0; width: 32px; height: 32px;">&times;</button>
                </div>

                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px;">
                    <div style="text-align: center; padding: 12px; background: var(--scaffold-bg-input); border-radius: 6px;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--scaffold-text);">${results.score}%</div>
                        <div style="font-size: 11px; color: var(--scaffold-text-muted); margin-top: 4px;">COMPLIANCE</div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: oklch(0.20 0.01 25); border-radius: 6px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.70 0.18 25);">${results.violations.critical.length}</div>
                        <div style="font-size: 11px; color: oklch(0.60 0.05 25); margin-top: 4px;">CRITICAL</div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: oklch(0.20 0.01 35); border-radius: 6px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.70 0.18 35);">${results.violations.high.length}</div>
                        <div style="font-size: 11px; color: oklch(0.60 0.05 35); margin-top: 4px;">HIGH</div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: oklch(0.20 0.01 70); border-radius: 6px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.70 0.15 70);">${results.violations.medium.length}</div>
                        <div style="font-size: 11px; color: oklch(0.60 0.05 70); margin-top: 4px;">MEDIUM</div>
                    </div>
                </div>

                ${generateViolationsList(results, violationsByGroup)}

                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button id="auto-fix-btn" style="flex: 1; padding: 12px; background: oklch(0.45 0.18 145); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">✨ Auto-Fix Critical</button>
                    <button id="copy-report-btn" style="flex: 1; padding: 12px; background: var(--scaffold-bg-input); color: var(--scaffold-text); border: 1px solid var(--scaffold-border); border-radius: 6px; font-weight: 600; cursor: pointer;">📋 Copy Report</button>
                </div>
            `;

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Close button
            document.getElementById('close-validation-modal').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });

            // Auto-fix button
            document.getElementById('auto-fix-btn').addEventListener('click', () => {
                const newResults = globalColorValidator.autoFix();
                document.body.removeChild(overlay);
                showValidationReport(newResults);
                updateColorSliders();
                refreshGallery();
            });

            // Copy report button
            document.getElementById('copy-report-btn').addEventListener('click', () => {
                const report = globalColorValidator.getReport();
                navigator.clipboard.writeText(report).then(() => {
                    const btn = document.getElementById('copy-report-btn');
                    btn.textContent = '✓ Copied!';
                    setTimeout(() => btn.textContent = '📋 Copy Report', 2000);
                });
            });

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }

        function generateViolationsList(results, violationsByGroup) {
            if (results.totalViolations === 0) {
                return `
                    <div style="text-align: center; padding: 40px; color: oklch(0.60 0.15 145);">
                        <div style="font-size: 48px; margin-bottom: 12px;">✓</div>
                        <div style="font-size: 16px; font-weight: 600;">All Clear!</div>
                        <div style="font-size: 13px; margin-top: 8px; color: var(--scaffold-text-muted);">No validation violations detected.</div>
                    </div>
                `;
            }

            let html = '<div style="margin-top: 20px;">';
            html += '<h3 style="font-size: 14px; color: var(--scaffold-text); margin-bottom: 12px; font-weight: 600;">VIOLATIONS BY COLOR GROUP:</h3>';

            const sortedGroups = Object.entries(violationsByGroup)
                .sort((a, b) => {
                    const scoreA = a[1].critical * 1000 + a[1].high * 100 + a[1].medium * 10 + a[1].low;
                    const scoreB = b[1].critical * 1000 + b[1].high * 100 + b[1].medium * 10 + b[1].low;
                    return scoreB - scoreA;
                });

            sortedGroups.forEach(([groupName, data]) => {
                const totalViolations = data.critical + data.high + data.medium + data.low;
                html += `
                    <div style="background: var(--scaffold-bg-input); border: 1px solid var(--scaffold-border); border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-weight: 600; color: var(--scaffold-text); font-size: 13px;">${groupName}</div>
                            <div style="font-size: 11px; color: var(--scaffold-text-muted);">${totalViolations} violation${totalViolations === 1 ? '' : 's'}</div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 8px; font-size: 11px;">
                            ${data.critical > 0 ? `<span style="color: oklch(0.70 0.18 25);">🔴 ${data.critical}</span>` : ''}
                            ${data.high > 0 ? `<span style="color: oklch(0.70 0.18 35);">🟠 ${data.high}</span>` : ''}
                            ${data.medium > 0 ? `<span style="color: oklch(0.70 0.15 70);">🟡 ${data.medium}</span>` : ''}
                            ${data.low > 0 ? `<span style="color: oklch(0.60 0.15 230);">🔵 ${data.low}</span>` : ''}
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            return html;
        }

        // ========== REGISTRY CONTROL PANEL UI ==========

        function initRegistryButton() {
            const registryBtn = document.getElementById('registry-btn');
            if (registryBtn) {
                registryBtn.addEventListener('click', openRegistryPanel);
            }
        }

        function openRegistryPanel() {
            console.log('📊 Opening Registry Control Panel...');

            // Capture complete state
            const snapshot = completeUIRegistry.captureCompleteState();
            const stats = completeUIRegistry.getStatistics();

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.id = 'registry-panel-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(8px);
            `;

            // Create modal content
            const panel = document.createElement('div');
            panel.style.cssText = `
                background: var(--scaffold-bg);
                border: 2px solid var(--scaffold-border-hover);
                border-radius: 16px;
                padding: 0;
                width: 90vw;
                max-width: 1200px;
                height: 85vh;
                overflow: hidden;
                box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
                display: flex;
                flex-direction: column;
            `;

            panel.innerHTML = generateRegistryPanelHTML(snapshot, stats);

            overlay.appendChild(panel);
            document.body.appendChild(overlay);

            // Attach event listeners
            attachRegistryPanelEvents(overlay, snapshot);
        }

        function generateRegistryPanelHTML(snapshot, stats) {
            return `
                <!-- HEADER -->
                <div style="padding: 24px; border-bottom: 2px solid var(--scaffold-border); background: var(--scaffold-bg-elevated); display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="margin: 0; color: var(--scaffold-text); font-size: 24px; font-weight: 700;">📊 Complete UI Registry</h2>
                        <p style="margin: 4px 0 0 0; color: var(--scaffold-text-muted); font-size: 12px;">TOTALITY APPROACH - Master Blueprint & Counter-Weight Operations</p>
                    </div>
                    <button id="close-registry-panel" style="background: transparent; border: none; color: var(--scaffold-text-muted); font-size: 32px; cursor: pointer; padding: 0; width: 40px; height: 40px; line-height: 1;">&times;</button>
                </div>

                <!-- STATISTICS STRIP -->
                <div style="padding: 16px 24px; background: var(--scaffold-bg-input); border-bottom: 1px solid var(--scaffold-border); display: flex; gap: 24px; overflow-x: auto;">
                    <div style="text-align: center; min-width: 120px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.60 0.18 270);">${stats.totalColors}</div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px; text-transform: uppercase;">Colors</div>
                    </div>
                    <div style="text-align: center; min-width: 120px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.60 0.18 145);">${stats.totalComponents}</div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px; text-transform: uppercase;">Components</div>
                    </div>
                    <div style="text-align: center; min-width: 120px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.60 0.18 35);">${stats.totalWidgets}</div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px; text-transform: uppercase;">Widgets</div>
                    </div>
                    <div style="text-align: center; min-width: 120px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.60 0.18 70);">${stats.wcagCompliance}</div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px; text-transform: uppercase;">WCAG</div>
                    </div>
                    <div style="text-align: center; min-width: 120px;">
                        <div style="font-size: 28px; font-weight: 700; color: oklch(0.60 0.18 180);">${stats.visualWeightBalance.toFixed(2)}</div>
                        <div style="font-size: 10px; color: var(--scaffold-text-muted); margin-top: 4px; text-transform: uppercase;">Balance</div>
                    </div>
                </div>

                <!-- TAB NAVIGATION -->
                <div style="padding: 16px 24px; background: var(--scaffold-bg-elevated); border-bottom: 1px solid var(--scaffold-border); display: flex; gap: 8px; overflow-x: auto;">
                    <button class="registry-tab active" data-tab="overview">Overview</button>
                    <button class="registry-tab" data-tab="color">Color System</button>
                    <button class="registry-tab" data-tab="counterWeight">Counter-Weight</button>
                    <button class="registry-tab" data-tab="layout">Layout</button>
                    <button class="registry-tab" data-tab="typography">Typography</button>
                    <button class="registry-tab" data-tab="shape">Shape</button>
                    <button class="registry-tab" data-tab="animation">Animation</button>
                    <button class="registry-tab" data-tab="compliance">Compliance</button>
                    <button class="registry-tab" data-tab="raw">Raw Data</button>
                </div>

                <!-- CONTENT AREA -->
                <div id="registry-content" style="flex: 1; overflow-y: auto; padding: 24px;">
                    ${generateOverviewContent(snapshot, stats)}
                </div>

                <!-- FOOTER ACTIONS -->
                <div style="padding: 16px 24px; border-top: 2px solid var(--scaffold-border); background: var(--scaffold-bg-elevated); display: flex; gap: 12px;">
                    <button id="export-json-btn" style="flex: 1; padding: 12px; background: oklch(0.45 0.18 270); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">📥 Export JSON</button>
                    <button id="copy-json-btn" style="flex: 1; padding: 12px; background: var(--scaffold-bg-input); color: var(--scaffold-text); border: 1px solid var(--scaffold-border); border-radius: 6px; font-weight: 600; cursor: pointer;">📋 Copy JSON</button>
                    <button id="refresh-registry-btn" style="flex: 1; padding: 12px; background: oklch(0.45 0.18 145); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">🔄 Refresh</button>
                </div>
            `;
        }

        function generateOverviewContent(snapshot, stats) {
            return `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${generateCategoryCard('Color System', snapshot.color, 'oklch(0.45 0.18 270)')}
                    ${generateCategoryCard('Counter-Weight', snapshot.counterWeight, 'oklch(0.45 0.18 35)')}
                    ${generateCategoryCard('Layout System', snapshot.layout, 'oklch(0.45 0.18 145)')}
                    ${generateCategoryCard('Typography', snapshot.typography, 'oklch(0.45 0.18 230)')}
                    ${generateCategoryCard('Shape System', snapshot.shape, 'oklch(0.45 0.18 180)')}
                    ${generateCategoryCard('Animation', snapshot.animation, 'oklch(0.45 0.18 70)')}
                    ${generateCategoryCard('Component System', snapshot.component, 'oklch(0.45 0.18 310)')}
                    ${generateCategoryCard('Compliance', snapshot.compliance, 'oklch(0.45 0.18 25)')}
                </div>
            `;
        }

        function generateCategoryCard(title, data, accentColor) {
            const keys = Object.keys(data);
            const preview = keys.slice(0, 3).map(k => {
                const value = typeof data[k] === 'object' ? JSON.stringify(data[k]).substring(0, 30) + '...' : data[k];
                return `<div style="font-size: 11px; color: var(--scaffold-text-muted); margin-bottom: 4px;"><strong>${k}:</strong> ${value}</div>`;
            }).join('');

            return `
                <div style="background: var(--scaffold-bg-elevated); border: 1px solid var(--scaffold-border); border-radius: 8px; padding: 16px; border-left: 4px solid ${accentColor};">
                    <div style="font-size: 16px; font-weight: 600; color: var(--scaffold-text); margin-bottom: 12px;">${title}</div>
                    ${preview}
                    <div style="margin-top: 12px; font-size: 11px; color: var(--scaffold-text-muted);">${keys.length} properties captured</div>
                </div>
            `;
        }

        function attachRegistryPanelEvents(overlay, snapshot) {
            // Close button
            document.getElementById('close-registry-panel').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });

            // Export JSON
            document.getElementById('export-json-btn').addEventListener('click', () => {
                completeUIRegistry.downloadJSON();
            });

            // Copy JSON
            document.getElementById('copy-json-btn').addEventListener('click', () => {
                const json = completeUIRegistry.exportAsJSON();
                navigator.clipboard.writeText(json).then(() => {
                    const btn = document.getElementById('copy-json-btn');
                    btn.textContent = '✓ Copied!';
                    setTimeout(() => btn.textContent = '📋 Copy JSON', 2000);
                });
            });

            // Refresh
            document.getElementById('refresh-registry-btn').addEventListener('click', () => {
                document.body.removeChild(overlay);
                openRegistryPanel();
            });

            // Tab switching
            const tabs = document.querySelectorAll('.registry-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const tabName = tab.dataset.tab;
                    const content = document.getElementById('registry-content');

                    if (tabName === 'overview') {
                        const stats = completeUIRegistry.getStatistics();
                        content.innerHTML = generateOverviewContent(snapshot, stats);
                    } else if (tabName === 'raw') {
                        content.innerHTML = `<pre style="color: var(--scaffold-text); font-size: 11px; white-space: pre-wrap; word-wrap: break-word;">${completeUIRegistry.exportAsJSON()}</pre>`;
                    } else {
                        content.innerHTML = `<pre style="color: var(--scaffold-text); font-size: 11px; white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(snapshot[tabName], null, 2)}</pre>`;
                    }
                });
            });

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }

        // Add CSS for tabs
        const style = document.createElement('style');
        style.textContent = `
            .registry-tab {
                padding: 8px 16px;
                background: var(--scaffold-bg-input);
                border: 1px solid var(--scaffold-border);
                border-radius: 6px;
                color: var(--scaffold-text);
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 200ms;
                white-space: nowrap;
            }

            .registry-tab:hover {
                background: var(--scaffold-bg-elevated);
                border-color: var(--scaffold-border-hover);
            }

            .registry-tab.active {
                background: oklch(0.45 0.18 270);
                border-color: oklch(0.45 0.18 270);
                color: white;
            }
        `;
        document.head.appendChild(style);

        // ========== TEMPLATE LIBRARY SYSTEM ==========

        const templateLibrary = {
            'corporate-blue': {
                name: '🏢 Corporate Blue',
                description: 'Professional blue theme with high contrast for business applications. WCAG AAA compliant.',
                colors: {
                    background: { l: 0.95, c: 0.01, h: 240 },
                    text: { l: 0.15, c: 0.02, h: 240 },
                    primary: { l: 0.50, c: 0.18, h: 240 },
                    secondary: { l: 0.60, c: 0.12, h: 200 },
                    accent: { l: 0.45, c: 0.20, h: 260 },
                    surface: { l: 0.98, c: 0.005, h: 240 }
                },
                counterweight: {
                    template: 'high-contrast',
                    lightnessAdjust: 0,
                    chromaAdjust: 0,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: true,
                    maxReadability: false
                },
                harmony: 'monochromatic',
                animation: {
                    duration: 600,
                    constantSpeed: false
                }
            },
            'nature-green': {
                name: '🌿 Nature Green',
                description: 'Organic green palette inspired by nature. Calming and accessible.',
                colors: {
                    background: { l: 0.96, c: 0.02, h: 140 },
                    text: { l: 0.18, c: 0.04, h: 140 },
                    primary: { l: 0.55, c: 0.15, h: 140 },
                    secondary: { l: 0.65, c: 0.10, h: 100 },
                    accent: { l: 0.50, c: 0.18, h: 180 },
                    surface: { l: 0.98, c: 0.01, h: 140 }
                },
                counterweight: {
                    template: 'muted-dark',
                    lightnessAdjust: 0,
                    chromaAdjust: -10,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: false,
                    maxReadability: false
                },
                harmony: 'analogous',
                animation: {
                    duration: 800,
                    constantSpeed: true
                }
            },
            'sunset-orange': {
                name: '🌅 Sunset Orange',
                description: 'Warm sunset-inspired palette. Energetic and inviting.',
                colors: {
                    background: { l: 0.94, c: 0.03, h: 40 },
                    text: { l: 0.12, c: 0.03, h: 40 },
                    primary: { l: 0.58, c: 0.20, h: 40 },
                    secondary: { l: 0.62, c: 0.18, h: 20 },
                    accent: { l: 0.54, c: 0.22, h: 60 },
                    surface: { l: 0.97, c: 0.015, h: 40 }
                },
                counterweight: {
                    template: 'vibrant-dark',
                    lightnessAdjust: 5,
                    chromaAdjust: 10,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: true,
                    maxReadability: false
                },
                harmony: 'split-complementary',
                animation: {
                    duration: 1000,
                    constantSpeed: false
                }
            },
            'ocean-teal': {
                name: '🌊 Ocean Teal',
                description: 'Deep ocean teal with cyan accents. Serene and modern.',
                colors: {
                    background: { l: 0.95, c: 0.02, h: 180 },
                    text: { l: 0.14, c: 0.03, h: 180 },
                    primary: { l: 0.52, c: 0.16, h: 180 },
                    secondary: { l: 0.58, c: 0.14, h: 200 },
                    accent: { l: 0.48, c: 0.18, h: 160 },
                    surface: { l: 0.98, c: 0.01, h: 180 }
                },
                counterweight: {
                    template: 'perceptual',
                    lightnessAdjust: 0,
                    chromaAdjust: 0,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: true,
                    maxReadability: false
                },
                harmony: 'complementary',
                animation: {
                    duration: 800,
                    constantSpeed: true
                }
            },
            'purple-premium': {
                name: '💎 Purple Premium',
                description: 'Luxurious purple with high chroma. Premium and sophisticated.',
                colors: {
                    background: { l: 0.96, c: 0.02, h: 290 },
                    text: { l: 0.16, c: 0.04, h: 290 },
                    primary: { l: 0.54, c: 0.22, h: 290 },
                    secondary: { l: 0.60, c: 0.18, h: 270 },
                    accent: { l: 0.50, c: 0.24, h: 310 },
                    surface: { l: 0.98, c: 0.01, h: 290 }
                },
                counterweight: {
                    template: 'vibrant-dark',
                    lightnessAdjust: 0,
                    chromaAdjust: 15,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: true,
                    maxReadability: true
                },
                harmony: 'triadic',
                animation: {
                    duration: 700,
                    constantSpeed: false
                }
            },
            'minimal-mono': {
                name: '⚫ Minimal Monochrome',
                description: 'Clean monochromatic design. Maximum focus and readability.',
                colors: {
                    background: { l: 0.98, c: 0.00, h: 0 },
                    text: { l: 0.08, c: 0.00, h: 0 },
                    primary: { l: 0.40, c: 0.00, h: 0 },
                    secondary: { l: 0.60, c: 0.00, h: 0 },
                    accent: { l: 0.30, c: 0.00, h: 0 },
                    surface: { l: 0.95, c: 0.00, h: 0 }
                },
                counterweight: {
                    template: 'standard',
                    lightnessAdjust: 0,
                    chromaAdjust: 0,
                    maintainContrast: true
                },
                compliance: {
                    wcag: true,
                    apca: true,
                    maxReadability: true
                },
                harmony: 'monochromatic',
                animation: {
                    duration: 500,
                    constantSpeed: false
                }
            }
        };

        let selectedTemplate = null;

        function initTemplateLibrary() {
            const templateSelector = document.getElementById('template-selector');
            const importBtn = document.getElementById('import-template-btn');

            if (!templateSelector || !importBtn) return;

            // Template selection handler
            templateSelector.addEventListener('change', (e) => {
                const templateId = e.target.value;

                if (templateId && templateLibrary[templateId]) {
                    selectedTemplate = templateId;
                    showTemplatePreview(templateId);
                    showTemplateLayers();
                    enableImportButton();
                } else {
                    selectedTemplate = null;
                    hideTemplatePreview();
                    hideTemplateLayers();
                    disableImportButton();
                }
            });

            // Import button handler
            importBtn.addEventListener('click', () => {
                if (selectedTemplate) {
                    importTemplate(selectedTemplate);
                }
            });
        }

        function showTemplatePreview(templateId) {
            const template = templateLibrary[templateId];
            const preview = document.getElementById('template-preview');
            const colorsContainer = document.getElementById('template-colors');
            const description = document.getElementById('template-description');

            if (!preview || !colorsContainer || !description) return;

            // Clear previous colors
            colorsContainer.innerHTML = '';

            // Add color swatches
            const colorGroups = ['background', 'text', 'primary', 'secondary', 'accent', 'surface'];
            colorGroups.forEach(group => {
                const color = template.colors[group];
                const swatch = document.createElement('div');
                swatch.style.cssText = `
                    width: 32px;
                    height: 32px;
                    border-radius: 6px;
                    background: oklch(${color.l} ${color.c} ${color.h});
                    border: 1px solid oklch(0.30 0.01 270);
                    flex-shrink: 0;
                `;
                swatch.title = group;
                colorsContainer.appendChild(swatch);
            });

            // Update description
            description.textContent = template.description;

            // Show preview
            preview.style.display = 'block';
        }

        function hideTemplatePreview() {
            const preview = document.getElementById('template-preview');
            if (preview) {
                preview.style.display = 'none';
            }
        }

        function showTemplateLayers() {
            const layers = document.getElementById('template-layers');
            if (layers) {
                layers.style.display = 'block';
            }
        }

        function hideTemplateLayers() {
            const layers = document.getElementById('template-layers');
            if (layers) {
                layers.style.display = 'none';
            }
        }

        function enableImportButton() {
            const importBtn = document.getElementById('import-template-btn');
            if (importBtn) {
                importBtn.disabled = false;
                importBtn.style.background = 'oklch(0.60 0.18 270)';
                importBtn.style.borderColor = 'oklch(0.70 0.18 270)';
                importBtn.style.color = 'white';
                importBtn.style.cursor = 'pointer';
            }
        }

        function disableImportButton() {
            const importBtn = document.getElementById('import-template-btn');
            if (importBtn) {
                importBtn.disabled = true;
                importBtn.style.background = 'oklch(0.35 0.01 270)';
                importBtn.style.borderColor = 'oklch(0.45 0.01 270)';
                importBtn.style.color = 'oklch(0.60 0.01 270)';
                importBtn.style.cursor = 'not-allowed';
            }
        }

        function importTemplate(templateId) {
            const template = templateLibrary[templateId];
            if (!template) return;

            // Get selected layers
            const layerCheckboxes = document.querySelectorAll('.layer-checkbox');
            const selectedLayers = {};
            layerCheckboxes.forEach(checkbox => {
                selectedLayers[checkbox.dataset.layer] = checkbox.checked;
            });

            showNotification(`
                📥 Importing <strong>${template.name}</strong><br>
                Applying selected configuration layers...
            `, 0);

            // Apply colors layer (with animation)
            if (selectedLayers.colors) {
                const colorGroups = ['background', 'text', 'primary', 'secondary', 'accent', 'surface'];
                colorGroups.forEach((group, index) => {
                    setTimeout(() => {
                        showNotification(`
                            📥 Importing <strong>${template.name}</strong><br>
                            Applying: <strong>${group.toUpperCase()}</strong> (${index + 1}/${colorGroups.length})
                        `, 0);

                        selectColorGroup(group);
                        const color = template.colors[group];
                        animateColorSlide(group, { l: color.l, c: color.c, h: color.h });

                        // Apply other layers on last color
                        if (index === colorGroups.length - 1) {
                            setTimeout(() => {
                                applyNonColorLayers(template, selectedLayers);

                                showNotification(`
                                    ✅ <strong>${template.name}</strong> imported successfully!<br>
                                    All selected layers have been applied
                                `, 3000);
                            }, animationSettings.duration + 200);
                        }
                    }, index * (animationSettings.duration + 100));
                });
            } else {
                // No color animation, apply other layers immediately
                applyNonColorLayers(template, selectedLayers);

                showNotification(`
                    ✅ <strong>${template.name}</strong> imported successfully!<br>
                    All selected layers have been applied
                `, 3000);
            }
        }

        function applyNonColorLayers(template, selectedLayers) {
            // Apply counter-weight settings
            if (selectedLayers.counterweight && template.counterweight) {
                const templateSelect = document.getElementById('transformation-template');
                if (templateSelect) {
                    templateSelect.value = template.counterweight.template;
                }

                const lightnessSlider = document.getElementById('template-lightness-adjust');
                const lightnessVal = document.getElementById('template-lightness-val');
                if (lightnessSlider && lightnessVal) {
                    lightnessSlider.value = template.counterweight.lightnessAdjust;
                    lightnessVal.textContent = template.counterweight.lightnessAdjust + '%';
                }

                const chromaSlider = document.getElementById('template-chroma-adjust');
                const chromaVal = document.getElementById('template-chroma-val');
                if (chromaSlider && chromaVal) {
                    chromaSlider.value = template.counterweight.chromaAdjust;
                    chromaVal.textContent = template.counterweight.chromaAdjust + '%';
                }

                const contrastCheckbox = document.getElementById('template-maintain-contrast');
                if (contrastCheckbox) {
                    contrastCheckbox.checked = template.counterweight.maintainContrast;
                }
            }

            // Apply compliance settings
            if (selectedLayers.compliance && template.compliance) {
                const wcagCheckbox = document.getElementById('allow-wcag-violation');
                if (wcagCheckbox) {
                    wcagCheckbox.checked = !template.compliance.wcag;
                }

                const apcaCheckbox = document.getElementById('allow-apca-violation');
                if (apcaCheckbox) {
                    apcaCheckbox.checked = !template.compliance.apca;
                }

                const maxReadCheckbox = document.getElementById('ensure-max-readability');
                if (maxReadCheckbox) {
                    maxReadCheckbox.checked = template.compliance.maxReadability;
                }
            }

            // Apply harmony preference
            if (selectedLayers.harmony && template.harmony) {
                const harmonySelect = document.getElementById('harmony-type');
                if (harmonySelect) {
                    harmonySelect.value = template.harmony;
                }
            }

            // Apply animation settings
            if (selectedLayers.animation && template.animation) {
                const durationSlider = document.getElementById('animation-duration');
                const durationVal = document.getElementById('animation-duration-val');
                if (durationSlider && durationVal) {
                    durationSlider.value = template.animation.duration;
                    durationVal.textContent = template.animation.duration;
                    animationSettings.duration = template.animation.duration;
                }

                const speedToggle = document.getElementById('constant-speed-mode');
                if (speedToggle) {
                    speedToggle.checked = template.animation.constantSpeed;
                    animationSettings.constantSpeed = template.animation.constantSpeed;
                }
            }
        }

        // ========== ADD TO SCAFFOLD (SELF-THEMING) ==========

        let originalScaffoldTheme = null;
        let scaffoldThemeApplied = false;

        function initScaffoldButtons() {
            const addBtn = document.getElementById('add-to-scaffold-btn');
            const resetBtn = document.getElementById('reset-scaffold-btn');

            if (addBtn) {
                addBtn.addEventListener('click', applyToScaffold);
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', resetScaffold);
            }
        }

        function applyToScaffold() {
            // Save original theme if not already saved
            if (!scaffoldThemeApplied) {
                originalScaffoldTheme = {
                    '--background': getComputedStyle(document.documentElement).getPropertyValue('--background'),
                    '--text': getComputedStyle(document.documentElement).getPropertyValue('--text'),
                    '--primary': getComputedStyle(document.documentElement).getPropertyValue('--primary'),
                    '--secondary': getComputedStyle(document.documentElement).getPropertyValue('--secondary'),
                    '--accent': getComputedStyle(document.documentElement).getPropertyValue('--accent'),
                    '--surface': getComputedStyle(document.documentElement).getPropertyValue('--surface')
                };
            }

            showNotification(`
                🎨 Applying theme to Studio UI<br>
                Updating scaffold with current canvas colors...
            `, 0);

            // Get current palette colors
            const colors = {
                '--background': `oklch(${colorPalette.light.background.l} ${colorPalette.light.background.c} ${colorPalette.light.background.h})`,
                '--text': `oklch(${colorPalette.light.text.l} ${colorPalette.light.text.c} ${colorPalette.light.text.h})`,
                '--primary': `oklch(${colorPalette.light.primary.l} ${colorPalette.light.primary.c} ${colorPalette.light.primary.h})`,
                '--secondary': `oklch(${colorPalette.light.secondary.l} ${colorPalette.light.secondary.c} ${colorPalette.light.secondary.h})`,
                '--accent': `oklch(${colorPalette.light.accent.l} ${colorPalette.light.accent.c} ${colorPalette.light.accent.h})`,
                '--surface': `oklch(${colorPalette.light.surface.l} ${colorPalette.light.surface.c} ${colorPalette.light.surface.h})`
            };

            // Apply colors with smooth transition
            const root = document.documentElement;
            root.style.transition = 'all 800ms cubic-bezier(0.4, 0, 0.2, 1)';

            Object.entries(colors).forEach(([property, value]) => {
                root.style.setProperty(property, value);
            });

            // Remove transition after animation
            setTimeout(() => {
                root.style.transition = '';
            }, 800);

            // Show reset button, hide add button
            document.getElementById('add-to-scaffold-btn').style.display = 'none';
            document.getElementById('reset-scaffold-btn').style.display = 'inline-block';

            scaffoldThemeApplied = true;

            setTimeout(() => {
                showNotification(`
                    ✅ Studio UI updated!<br>
                    Theme applied to scaffold successfully
                `, 3000);
            }, 800);
        }

        function resetScaffold() {
            if (!originalScaffoldTheme) return;

            showNotification(`
                ↩️ Resetting Studio UI<br>
                Restoring original theme...
            `, 0);

            // Apply original colors with smooth transition
            const root = document.documentElement;
            root.style.transition = 'all 800ms cubic-bezier(0.4, 0, 0.2, 1)';

            Object.entries(originalScaffoldTheme).forEach(([property, value]) => {
                root.style.setProperty(property, value);
            });

            // Remove transition after animation
            setTimeout(() => {
                root.style.transition = '';
            }, 800);

            // Show add button, hide reset button
            document.getElementById('add-to-scaffold-btn').style.display = 'inline-block';
            document.getElementById('reset-scaffold-btn').style.display = 'none';

            scaffoldThemeApplied = false;

            setTimeout(() => {
                showNotification(`
                    ✅ Studio UI reset!<br>
                    Original theme restored
                `, 3000);
            }, 800);
        }

        // ========== RANDOM BEAUTIFUL UI GENERATOR (HOTSPOT SYSTEM) ==========

        const beautifulUIHotspots = [
            { name: 'Ocean Depths', harmony: 'monochromatic', baseHue: 200, baseL: 0.55, baseC: 0.15, tags: ['calm', 'professional'] },
            { name: 'Forest Canopy', harmony: 'analogous', baseHue: 130, baseL: 0.50, baseC: 0.18, tags: ['natural', 'organic'] },
            { name: 'Sunset Glow', harmony: 'complementary', baseHue: 35, baseL: 0.60, baseC: 0.22, tags: ['warm', 'energetic'] },
            { name: 'Royal Purple', harmony: 'monochromatic', baseHue: 290, baseL: 0.52, baseC: 0.20, tags: ['premium', 'luxurious'] },
            { name: 'Cyber Neon', harmony: 'triadic', baseHue: 180, baseL: 0.58, baseC: 0.25, tags: ['tech', 'bold'] },
            { name: 'Corporate Blue', harmony: 'monochromatic', baseHue: 240, baseL: 0.50, baseC: 0.16, tags: ['professional', 'trustworthy'] },
            { name: 'Spring Meadow', harmony: 'analogous', baseHue: 110, baseL: 0.65, baseC: 0.14, tags: ['fresh', 'light'] },
            { name: 'Desert Sand', harmony: 'monochromatic', baseHue: 45, baseL: 0.70, baseC: 0.10, tags: ['warm', 'neutral'] },
            { name: 'Arctic Ice', harmony: 'complementary', baseHue: 210, baseL: 0.85, baseC: 0.08, tags: ['cool', 'minimal'] },
            { name: 'Cherry Blossom', harmony: 'analogous', baseHue: 350, baseL: 0.68, baseC: 0.18, tags: ['delicate', 'feminine'] },
            { name: 'Midnight Blue', harmony: 'monochromatic', baseHue: 240, baseL: 0.30, baseC: 0.15, tags: ['dark', 'sophisticated'] },
            { name: 'Tropical Fruit', harmony: 'triadic', baseHue: 30, baseL: 0.62, baseC: 0.24, tags: ['vibrant', 'playful'] },
            { name: 'Sage Wisdom', harmony: 'analogous', baseHue: 140, baseL: 0.58, baseC: 0.12, tags: ['calm', 'mature'] },
            { name: 'Fire Engine', harmony: 'complementary', baseHue: 15, baseL: 0.55, baseC: 0.28, tags: ['bold', 'attention'] },
            { name: 'Lavender Fields', harmony: 'monochromatic', baseHue: 280, baseL: 0.72, baseC: 0.16, tags: ['soft', 'relaxing'] },
            { name: 'Emerald City', harmony: 'analogous', baseHue: 155, baseL: 0.48, baseC: 0.20, tags: ['rich', 'jewel-toned'] },
            { name: 'Autumn Harvest', harmony: 'complementary', baseHue: 40, baseL: 0.56, baseC: 0.19, tags: ['warm', 'cozy'] },
            { name: 'Slate Modern', harmony: 'monochromatic', baseHue: 220, baseL: 0.45, baseC: 0.08, tags: ['neutral', 'modern'] },
            { name: 'Peacock Feather', harmony: 'triadic', baseHue: 190, baseL: 0.54, baseC: 0.22, tags: ['exotic', 'vibrant'] },
            { name: 'Rose Gold', harmony: 'analogous', baseHue: 25, baseL: 0.65, baseC: 0.15, tags: ['elegant', 'feminine'] },
            { name: 'Deep Space', harmony: 'complementary', baseHue: 260, baseL: 0.25, baseC: 0.18, tags: ['dark', 'mysterious'] },
            { name: 'Mint Fresh', harmony: 'analogous', baseHue: 165, baseL: 0.75, baseC: 0.14, tags: ['fresh', 'clean'] },
            { name: 'Burgundy Wine', harmony: 'monochromatic', baseHue: 355, baseL: 0.40, baseC: 0.22, tags: ['rich', 'sophisticated'] },
            { name: 'Sunny Day', harmony: 'triadic', baseHue: 55, baseL: 0.80, baseC: 0.20, tags: ['bright', 'cheerful'] },
            { name: 'Graphite Tech', harmony: 'monochromatic', baseHue: 230, baseL: 0.35, baseC: 0.06, tags: ['tech', 'minimal'] }
        ];

        let currentHotspotIndex = 0;
        let filteredHotspots = [...beautifulUIHotspots];
        let explorationMode = 50;

        function initHotspotSystem() {
            // Exploration mode slider
            const explorationSlider = document.getElementById('exploration-mode');
            const explorationLabel = document.getElementById('exploration-mode-label');
            const explorationVal = document.getElementById('exploration-mode-val');

            if (explorationSlider && explorationLabel && explorationVal) {
                explorationSlider.addEventListener('input', (e) => {
                    explorationMode = parseInt(e.target.value);
                    explorationVal.textContent = explorationMode;

                    if (explorationMode < 25) {
                        explorationLabel.textContent = 'Conservative';
                    } else if (explorationMode < 75) {
                        explorationLabel.textContent = 'Balanced';
                    } else {
                        explorationLabel.textContent = 'Adventurous';
                    }

                    updateFilteredHotspots();
                    updateHotspotPreviews();
                });
            }

            // Harmony weight checkboxes
            const harmonyCheckboxes = document.querySelectorAll('.harmony-weight');
            harmonyCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    updateFilteredHotspots();
                    updateHotspotPreviews();
                });
            });

            // Lightness and chroma range inputs
            ['lightness-min', 'lightness-max', 'chroma-min', 'chroma-max'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('change', () => {
                        updateFilteredHotspots();
                        updateHotspotPreviews();
                    });
                }
            });

            // Navigation buttons
            const prevBtn = document.getElementById('prev-hotspot-btn');
            const nextBtn = document.getElementById('next-hotspot-btn');
            const jumpBtn = document.getElementById('jump-hotspot-btn');

            if (prevBtn) {
                prevBtn.addEventListener('click', navigatePrevHotspot);
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', navigateNextHotspot);
            }

            if (jumpBtn) {
                jumpBtn.addEventListener('click', jumpToRandomHotspot);
            }

            // Initial setup
            updateFilteredHotspots();
            updateHotspotPreviews();

            // ========== SWIPE GESTURE SUPPORT ==========
            let touchStartXSwipe = 0;
            let touchEndXSwipe = 0;
            const MIN_SWIPE_DISTANCE = 50; // Minimum distance for swipe detection

            const galleryArea = document.querySelector('.gallery');
            if (galleryArea) {
                galleryArea.addEventListener('touchstart', (e) => {
                    touchStartXSwipe = e.touches[0].clientX;
                }, { passive: true });

                galleryArea.addEventListener('touchend', (e) => {
                    touchEndXSwipe = e.changedTouches[0].clientX;
                    handleSwipeGesture();
                }, { passive: true });
            }

            function handleSwipeGesture() {
                const swipeDistance = touchEndXSwipe - touchStartXSwipe;

                if (Math.abs(swipeDistance) >= MIN_SWIPE_DISTANCE) {
                    if (swipeDistance > 0) {
                        // Swipe right → Previous hotspot
                        navigatePrevHotspot();
                        showFloatingLog('← Previous hotspot', 800);
                    } else {
                        // Swipe left → Next hotspot
                        navigateNextHotspot();
                        showFloatingLog('Next hotspot →', 800);
                    }
                }
            }
        }

        function updateFilteredHotspots() {
            // Get selected harmonies
            const selectedHarmonies = [];
            document.querySelectorAll('.harmony-weight:checked').forEach(cb => {
                selectedHarmonies.push(cb.value);
            });

            // Get lightness and chroma ranges
            const lightnessMin = (parseInt(document.getElementById('lightness-min')?.value || 0)) / 100;
            const lightnessMax = (parseInt(document.getElementById('lightness-max')?.value || 100)) / 100;
            const chromaMin = (parseInt(document.getElementById('chroma-min')?.value || 0)) / 100;
            const chromaMax = (parseInt(document.getElementById('chroma-max')?.value || 37)) / 100;

            // Filter hotspots
            filteredHotspots = beautifulUIHotspots.filter(hotspot => {
                // Harmony filter
                if (selectedHarmonies.length > 0 && !selectedHarmonies.includes(hotspot.harmony)) {
                    return false;
                }

                // Lightness filter (with exploration mode tolerance)
                const tolerance = (explorationMode / 100) * 0.3; // Up to 30% tolerance at max adventure
                if (hotspot.baseL < (lightnessMin - tolerance) || hotspot.baseL > (lightnessMax + tolerance)) {
                    return false;
                }

                // Chroma filter (with exploration mode tolerance)
                if (hotspot.baseC < (chromaMin - tolerance) || hotspot.baseC > (chromaMax + tolerance)) {
                    return false;
                }

                return true;
            });

            // Reset index if out of bounds
            if (currentHotspotIndex >= filteredHotspots.length) {
                currentHotspotIndex = 0;
            }
        }

        function updateHotspotPreviews() {
            const previewContainer = document.getElementById('hotspot-preview');
            if (!previewContainer) return;

            previewContainer.innerHTML = '';

            if (filteredHotspots.length === 0) {
                previewContainer.innerHTML = '<div style="font-size: 11px; color: oklch(0.55 0.01 270); text-align: center;">No hotspots match filters</div>';
                return;
            }

            // Show next 3 hotspots
            for (let i = 0; i < Math.min(3, filteredHotspots.length); i++) {
                const index = (currentHotspotIndex + i) % filteredHotspots.length;
                const hotspot = filteredHotspots[index];

                const previewCard = document.createElement('div');
                previewCard.className = 'hotspot-preview-card' + (i === 0 ? ' active' : '');

                previewCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span class="hotspot-preview-card-title">${hotspot.name}</span>
                        <span class="hotspot-label">${hotspot.harmony}</span>
                    </div>
                    <div style="display: flex; gap: 2px; height: 16px;">
                        ${generateHotspotColorBar(hotspot)}
                    </div>
                `;

                previewCard.addEventListener('click', () => {
                    currentHotspotIndex = index;
                    applyHotspot(hotspot);
                });

                previewContainer.appendChild(previewCard);
            }
        }

        function generateHotspotColorBar(hotspot) {
            const colors = calculateHarmony(hotspot.harmony, { l: hotspot.baseL, c: hotspot.baseC, h: hotspot.baseHue });
            return colors.map(color =>
                `<div style="flex: 1; background: oklch(${color.l} ${color.c} ${color.h}); border-radius: 2px;"></div>`
            ).join('');
        }

        function navigatePrevHotspot() {
            if (filteredHotspots.length === 0) return;
            currentHotspotIndex = (currentHotspotIndex - 1 + filteredHotspots.length) % filteredHotspots.length;
            updateHotspotPreviews();
            applyHotspot(filteredHotspots[currentHotspotIndex]);
        }

        function navigateNextHotspot() {
            if (filteredHotspots.length === 0) return;
            currentHotspotIndex = (currentHotspotIndex + 1) % filteredHotspots.length;
            updateHotspotPreviews();
            applyHotspot(filteredHotspots[currentHotspotIndex]);
        }

        function jumpToRandomHotspot() {
            if (filteredHotspots.length === 0) {
                showNotification('⚠️ No hotspots match current filters!', 2000);
                return;
            }

            // Random jump with exploration mode influence
            const jumpDistance = Math.floor(Math.random() * filteredHotspots.length);
            currentHotspotIndex = (currentHotspotIndex + jumpDistance) % filteredHotspots.length;

            updateHotspotPreviews();
            applyHotspot(filteredHotspots[currentHotspotIndex]);
        }

        function applyHotspot(hotspot) {
            showNotification(`
                🎲 Jumping to <strong>${hotspot.name}</strong><br>
                ${hotspot.harmony} harmony • ${hotspot.tags.join(', ')}
            `, 0);

            // Update current hotspot name
            const currentName = document.getElementById('current-hotspot-name');
            if (currentName) {
                currentName.textContent = hotspot.name;
            }

            // Generate palette from hotspot
            const baseColor = { l: hotspot.baseL, c: hotspot.baseC, h: hotspot.baseHue };
            const colors = calculateHarmony(hotspot.harmony, baseColor);

            // Apply with animation
            colors.forEach((color, index) => {
                setTimeout(() => {
                    showNotification(`
                        🎲 <strong>${hotspot.name}</strong><br>
                        Applying: <strong>${color.group.toUpperCase()}</strong> (${index + 1}/${colors.length})
                    `, 0);

                    selectColorGroup(color.group);
                    animateColorSlide(color.group, { l: color.l, c: color.c, h: color.h });

                    if (index === colors.length - 1) {
                        setTimeout(() => {
                            showNotification(`
                                ✅ <strong>${hotspot.name}</strong> applied!<br>
                                Hotspot ${currentHotspotIndex + 1} of ${filteredHotspots.length}
                            `, 3000);
                        }, animationSettings.duration + 200);
                    }
                }, index * (animationSettings.duration + 100));
            });
        }

        // ========== WIDGET DRAG-AND-DROP SIDEBAR SYSTEM ==========

        let widgetModeActive = false;
        let draggedElement = null;
        let defaultWidgetOrder = [];

        function initWidgetSystem() {
            // Get all widgets
            const widgets = document.querySelectorAll('.section[data-widget-id]');

            // Store default order
            widgets.forEach((widget, index) => {
                defaultWidgetOrder.push({
                    id: widget.dataset.widgetId,
                    index: index
                });
            });

            // Load saved order
            loadWidgetOrder();

            // Toggle button
            const toggleBtn = document.getElementById('toggle-widget-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleWidgetMode);
            }
        }

        function toggleWidgetMode() {
            widgetModeActive = !widgetModeActive;
            const toggleBtn = document.getElementById('toggle-widget-mode');
            const widgets = document.querySelectorAll('.section[data-widget-id]');

            if (widgetModeActive) {
                // Activate widget mode
                toggleBtn.textContent = 'Done';
                toggleBtn.style.background = 'oklch(0.45 0.18 145)';
                toggleBtn.style.color = 'white';

                // Make widgets draggable
                widgets.forEach(widget => {
                    widget.draggable = true;
                    widget.style.cursor = 'move';
                    widget.style.transition = 'all 200ms';
                    widget.style.opacity = '0.95';
                    widget.style.border = '2px dashed oklch(0.45 0.18 270)';

                    // Add drag event listeners
                    widget.addEventListener('dragstart', handleDragStart);
                    widget.addEventListener('dragover', handleDragOver);
                    widget.addEventListener('drop', handleDrop);
                    widget.addEventListener('dragend', handleDragEnd);
                    widget.addEventListener('dragenter', handleDragEnter);
                    widget.addEventListener('dragleave', handleDragLeave);
                });

                // Show notification
                showNotification(`
                    🎨 <strong>Widget Customization Mode</strong><br>
                    Drag and drop to reorder sidebar sections
                `, 3000);

            } else {
                // Deactivate widget mode
                toggleBtn.textContent = 'Customize';
                toggleBtn.style.background = 'oklch(0.35 0.01 270)';
                toggleBtn.style.color = 'oklch(0.70 0.01 270)';

                // Remove draggable
                widgets.forEach(widget => {
                    widget.draggable = false;
                    widget.style.cursor = '';
                    widget.style.opacity = '1';
                    widget.style.border = '';

                    // Remove drag event listeners
                    widget.removeEventListener('dragstart', handleDragStart);
                    widget.removeEventListener('dragover', handleDragOver);
                    widget.removeEventListener('drop', handleDrop);
                    widget.removeEventListener('dragend', handleDragEnd);
                    widget.removeEventListener('dragenter', handleDragEnter);
                    widget.removeEventListener('dragleave', handleDragLeave);
                });

                // Save order
                saveWidgetOrder();

                showNotification('✅ Widget layout saved!', 2000);
            }
        }

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            if (e.target.classList.contains('section') && e.target !== draggedElement) {
                e.target.style.borderColor = 'oklch(0.55 0.25 145)';
                e.target.style.background = 'oklch(0.20 0.03 145)';
            }
        }

        function handleDragLeave(e) {
            if (e.target.classList.contains('section')) {
                e.target.style.borderColor = '';
                e.target.style.background = '';
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            // Reset styles
            e.target.style.borderColor = '';
            e.target.style.background = '';

            if (draggedElement !== e.target && e.target.classList.contains('section')) {
                // Get parent container
                const parent = draggedElement.parentNode;

                // Determine drop position
                const draggedIndex = Array.from(parent.children).indexOf(draggedElement);
                const targetIndex = Array.from(parent.children).indexOf(e.target);

                if (draggedIndex < targetIndex) {
                    // Moving down - insert after target
                    parent.insertBefore(draggedElement, e.target.nextSibling);
                } else {
                    // Moving up - insert before target
                    parent.insertBefore(draggedElement, e.target);
                }
            }

            return false;
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '0.95';

            // Reset all drop zone highlights
            document.querySelectorAll('.section[data-widget-id]').forEach(widget => {
                widget.style.borderColor = '';
                widget.style.background = '';
            });
        }

        function saveWidgetOrder() {
            const widgets = document.querySelectorAll('.section[data-widget-id]');
            const order = [];

            widgets.forEach((widget, index) => {
                order.push({
                    id: widget.dataset.widgetId,
                    index: index
                });
            });

            localStorage.setItem('widget-order', JSON.stringify(order));
        }

        function loadWidgetOrder() {
            const savedOrder = localStorage.getItem('widget-order');
            if (!savedOrder) return;

            try {
                const order = JSON.parse(savedOrder);
                const sidebar = document.querySelector('.left-sidebar');
                const widgets = {};

                // Collect all widgets by ID
                document.querySelectorAll('.section[data-widget-id]').forEach(widget => {
                    widgets[widget.dataset.widgetId] = widget;
                });

                // Find the insertion point (after the widget customization header)
                const customizeHeader = sidebar.querySelector('#toggle-widget-mode').closest('div');

                // Reorder widgets
                order.forEach(item => {
                    const widget = widgets[item.id];
                    if (widget) {
                        sidebar.insertBefore(widget, customizeHeader.nextSibling);
                    }
                });

                // Move all widgets to correct positions
                order.slice().reverse().forEach(item => {
                    const widget = widgets[item.id];
                    if (widget && customizeHeader) {
                        sidebar.insertBefore(widget, customizeHeader.nextSibling);
                    }
                });

            } catch (e) {
                console.error('Failed to load widget order:', e);
            }
        }

        function resetWidgetOrder() {
            localStorage.removeItem('widget-order');
            location.reload(); // Simple reset - reload page
        }

        // ========== NATURAL LANGUAGE COLOR NAMES (EASTER EGG) ==========

        function getColorName(l, c, h) {
            // Lightness descriptors
            let lightness = '';
            if (l < 0.10) lightness = 'Very Dark';
            else if (l < 0.25) lightness = 'Dark';
            else if (l < 0.40) lightness = 'Deep';
            else if (l < 0.60) lightness = '';
            else if (l < 0.75) lightness = 'Light';
            else if (l < 0.90) lightness = 'Very Light';
            else lightness = 'Pale';

            // Chroma descriptors
            let saturation = '';
            if (c < 0.02) return lightness + (lightness ? ' ' : '') + 'Gray';
            else if (c < 0.05) saturation = 'Muted';
            else if (c < 0.10) saturation = 'Soft';
            else if (c < 0.20) saturation = '';
            else if (c < 0.30) saturation = 'Vivid';
            else saturation = 'Brilliant';

            // Hue names with fine-grained precision
            let hue = '';
            if (h >= 355 || h < 10) hue = 'Red';
            else if (h < 25) hue = 'Red-Orange';
            else if (h < 45) hue = 'Orange';
            else if (h < 65) hue = 'Yellow-Orange';
            else if (h < 80) hue = 'Yellow';
            else if (h < 95) hue = 'Yellow-Green';
            else if (h < 140) hue = 'Green';
            else if (h < 165) hue = 'Cyan-Green';
            else if (h < 180) hue = 'Cyan';
            else if (h < 200) hue = 'Sky Blue';
            else if (h < 240) hue = 'Blue';
            else if (h < 270) hue = 'Blue-Violet';
            else if (h < 290) hue = 'Violet';
            else if (h < 310) hue = 'Purple';
            else if (h < 330) hue = 'Magenta';
            else if (h < 345) hue = 'Pink';
            else hue = 'Rose';

            // Combine descriptors
            const parts = [lightness, saturation, hue].filter(Boolean);
            return parts.join(' ');
        }

        // ========== COPY-TO-CLIPBOARD FUNCTIONALITY ==========

        function initCopyToClipboard() {
            const container = document.getElementById('color-line-container');
            if (!container) return;

            // Create feedback popup
            const feedback = document.createElement('div');
            feedback.className = 'copy-feedback';
            feedback.id = 'copy-feedback';
            feedback.innerHTML = `
                <div>✓ Color Copied!</div>
                <div class="copy-feedback-name" id="copy-feedback-name"></div>
            `;
            document.body.appendChild(feedback);

            // Click handler
            container.addEventListener('click', () => {
                const colorText = document.getElementById('color-name-label').textContent;
                const l = currentColor.l;
                const c = currentColor.c;
                const h = currentColor.h;

                // Copy to clipboard
                navigator.clipboard.writeText(colorText).then(() => {
                    // Get natural language name
                    const colorName = getColorName(l, c, h);

                    // Update feedback
                    document.getElementById('copy-feedback-name').textContent = colorName;
                    feedback.classList.add('show');

                    // Hide after 1 second
                    setTimeout(() => {
                        feedback.classList.remove('show');
                    }, 1000);
                }).catch(err => {
                    console.error('Copy failed:', err);
                });
            });
        }

        // ========== UPDATE COLOR LINE DISPLAY ==========

        function updateColorLineDisplay(l = currentColor.l, c = currentColor.c, h = currentColor.h) {
            // Use passed parameters to avoid stale currentColor values
            const colorStr = `oklch(${l.toFixed(2)} ${c.toFixed(2)} ${h})`;

            // Update label TEXT ONLY - CSS variables handle colors
            const label = document.getElementById('color-name-label');
            label.textContent = colorStr;

            // Remove any inline styles to let CSS variables work
            label.style.color = '';
        }

        // ========== UPDATE SPOTLIGHT ACCENT COLORS ==========

        function updateSpotlightAccent() {
            // Get current color from currentGroup
            const color = colorPalette[currentMode][currentGroup];
            const colorStr = `oklch(${color.l} ${color.c} ${color.h})`;

            // Update spotlight container border and title color
            const spotlight = document.querySelector('.spotlight');
            const spotlightTitle = document.querySelector('.spotlight-title');
            const spotlightGroup = document.querySelector('.spotlight-group');

            if (spotlight) {
                spotlight.style.borderColor = colorStr;
                spotlight.style.boxShadow = `0 4px 12px ${colorStr.replace(')', ' / 0.3)')}`;
            }

            if (spotlightTitle) {
                spotlightTitle.style.color = colorStr;
            }

            if (spotlightGroup) {
                spotlightGroup.style.background = colorStr;
            }
        }

        // ========== UNDO/REDO SYSTEM ==========

        const historyStack = [];
        const redoStack = [];
        const MAX_HISTORY = 50;
        let isUndoRedoing = false;

        function captureState() {
            if (isUndoRedoing) return; // Don't capture during undo/redo

            const state = {
                colorPalette: JSON.parse(JSON.stringify(colorPalette)),
                currentGroup: currentGroup,
                timestamp: Date.now()
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }

            // Clear redo stack on new action
            redoStack.length = 0;
        }

        function applyCSSVariablesFromPalette() {
            // Update CSS variables for current mode from colorPalette
            const groups = ['primary', 'secondary', 'accent', 'background', 'surface', 'text'];
            groups.forEach(group => {
                const color = colorPalette[currentMode][group];
                const colorStr = `oklch(${color.l} ${color.c} ${color.h})`;
                document.documentElement.style.setProperty(`--${group}`, colorStr);
            });

            // ========== INTEGRATED: Update all color names after palette changes ==========
            updateAllColorNames();
        }

        function undo() {
            if (historyStack.length < 2) return; // Need at least 2 states (current + previous)

            isUndoRedoing = true;

            // Move current state to redo stack
            const currentState = historyStack.pop();
            redoStack.push(currentState);

            // Apply previous state
            const previousState = historyStack[historyStack.length - 1];
            colorPalette = JSON.parse(JSON.stringify(previousState.colorPalette));
            currentGroup = previousState.currentGroup;

            // Sync CSS variables from restored palette
            applyCSSVariablesFromPalette();

            // Update UI (selectColorGroup reads from CSS variables)
            selectColorGroup(currentGroup);

            isUndoRedoing = false;

            showFloatingLogWithAria('↶ Undo', 1000);
        }

        function redo() {
            if (redoStack.length === 0) return;

            isUndoRedoing = true;

            // Get state from redo stack
            const nextState = redoStack.pop();
            historyStack.push(nextState);

            // Apply state
            colorPalette = JSON.parse(JSON.stringify(nextState.colorPalette));
            currentGroup = nextState.currentGroup;

            // Sync CSS variables from restored palette
            applyCSSVariablesFromPalette();

            // Update UI (selectColorGroup reads from CSS variables)
            selectColorGroup(currentGroup);

            isUndoRedoing = false;

            showFloatingLogWithAria('↷ Redo', 1000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z or Cmd+Z (undo)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y or Cmd+Shift+Z (redo)
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
            // Ctrl+S or Cmd+S (manual save)
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                savePaletteToStorage();
                showFloatingLog('💾 Saved manually', 1500);
            }
            // Ctrl+C or Cmd+C (copy current color)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                const currentColor = colorPalette[currentMode][currentGroup];
                const colorStr = `oklch(${currentColor.l} ${currentColor.c} ${currentColor.h})`;
                navigator.clipboard.writeText(colorStr).then(() => {
                    showFloatingLog(`📋 ${colorStr}`, 1500);
                }).catch(() => {
                    showFloatingLog('❌ Copy failed', 1000);
                });
            }
            // ESC (close panels/modals)
            if (e.key === 'Escape') {
                // Close widget customization mode if active
                const widgetModeBtn = document.getElementById('toggle-widget-mode');
                if (widgetModeBtn && widgetModeBtn.textContent.includes('Exit')) {
                    widgetModeBtn.click();
                    showFloatingLog('🔙 Exited customize mode', 1000);
                }
            }
        });

        // Expose to global scope for testing/debugging
        window.undo = undo;
        window.redo = redo;
        window.captureState = captureState;
        window.historyStack = historyStack;
        window.redoStack = redoStack;
        window.showFloatingLog = showFloatingLog;

        // Capture initial state
        window.addEventListener('load', () => {
            captureState();
        });

        // ========== AUTO-SAVE + WARNING SYSTEM ==========

        let isDirty = false;
        let lastSaved = null;
        const AUTO_SAVE_INTERVAL = 30000; // 30 seconds

        // Save palette to localStorage
        function savePaletteToStorage() {
            try {
                const paletteData = {
                    colorPalette: colorPalette,
                    currentGroup: currentGroup,
                    currentMode: currentMode,
                    timestamp: Date.now()
                };
                localStorage.setItem('oklch-palette-autosave', JSON.stringify(paletteData));
                isDirty = false;
                lastSaved = Date.now();
                updateLastSavedDisplay();
                showFloatingLog('💾 Auto-saved', 1000);
                return true;
            } catch (e) {
                console.error('Failed to save palette:', e);
                return false;
            }
        }

        // Load palette from localStorage
        function loadPaletteFromStorage() {
            try {
                const saved = localStorage.getItem('oklch-palette-autosave');
                if (saved) {
                    const paletteData = sanitizeJSON(saved);

                    if (!paletteData || !paletteData.colorPalette) {
                        throw new Error('Invalid saved palette data');
                    }

                    // Validate palette structure
                    if (!validatePaletteData(paletteData.colorPalette)) {
                        throw new Error('Invalid palette structure');
                    }

                    colorPalette = paletteData.colorPalette;
                    currentGroup = sanitizeString(paletteData.currentGroup || 'primary', 50);
                    currentMode = sanitizeString(paletteData.currentMode || 'light', 10);

                    // Validate mode and group values
                    if (!['light', 'dark'].includes(currentMode)) {
                        currentMode = 'light';
                    }
                    if (!['primary', 'secondary', 'accent', 'background', 'surface', 'text'].includes(currentGroup)) {
                        currentGroup = 'primary';
                    }

                    // Apply loaded palette
                    applyCSSVariablesFromPalette();
                    selectColorGroup(currentGroup);

                    // ========== FIX: Sync AUTO button with loaded mode ==========
                    updateModeButtonLabel();

                    lastSaved = sanitizeNumber(paletteData.timestamp, 0, Date.now(), Date.now());
                    updateLastSavedDisplay();
                    showFloatingLog('📂 Loaded saved palette', 1500);
                    return true;
                }
            } catch (e) {
                console.error('Failed to load palette:', e);
                showFloatingLog('❌ Failed to load saved palette', 2000);
            }
            return false;
        }

        // Update "Last saved" display in UI
        function updateLastSavedDisplay() {
            const lastSavedEl = document.getElementById('last-saved-indicator');
            if (!lastSavedEl) return;

            if (lastSaved) {
                const now = Date.now();
                const diff = now - lastSaved;
                const seconds = Math.floor(diff / 1000);
                const minutes = Math.floor(seconds / 60);

                let timeStr = '';
                if (minutes > 0) {
                    timeStr = `${minutes}m ago`;
                } else if (seconds > 0) {
                    timeStr = `${seconds}s ago`;
                } else {
                    timeStr = 'just now';
                }

                lastSavedEl.textContent = `💾 ${timeStr}`;
                lastSavedEl.style.opacity = '0.7';
            } else {
                lastSavedEl.textContent = '💾 Not saved';
                lastSavedEl.style.opacity = '0.5';
            }
        }

        // Mark palette as modified
        function markDirty() {
            if (!isUndoRedoing) {
                isDirty = true;
            }
        }

        // Auto-save interval
        setInterval(() => {
            if (isDirty) {
                savePaletteToStorage();
            } else {
                // Update display even if not dirty
                updateLastSavedDisplay();
            }
        }, AUTO_SAVE_INTERVAL);

        // Update display every 10 seconds
        setInterval(() => {
            updateLastSavedDisplay();
        }, 10000);

        // Warn on page close if unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // Override captureState to mark dirty
        const originalCaptureState = captureState;
        captureState = function() {
            originalCaptureState();
            markDirty();
        };

        // Expose to global scope
        window.savePaletteToStorage = savePaletteToStorage;
        window.loadPaletteFromStorage = loadPaletteFromStorage;
        window.isDirty = () => isDirty;

        // Load saved palette on page load
        window.addEventListener('load', () => {
            loadPaletteFromStorage();
            // Initialize OKLCH code display with current color
            updateOklchCodeDisplay(currentColor.l, currentColor.c, currentColor.h);
        });

        // ========== SIDEBAR RESIZE & TOGGLE ==========

        /**
         * Toggle sidebar visibility with smooth animation
         */
        function toggleSidebar() {
            const sidebar = document.querySelector('.left-sidebar');
            sidebar.classList.toggle('collapsed');

            // Announce to screen readers
            const isCollapsed = sidebar.classList.contains('collapsed');
            announceToScreenReader(isCollapsed ? 'Sidebar hidden' : 'Sidebar shown');
        }

        /**
         * Initialize sidebar resize functionality
         */
        function initSidebarResize() {
            const sidebar = document.querySelector('.left-sidebar');
            const resizeHandle = document.querySelector('.sidebar-resize-handle');
            const gallery = document.querySelector('.center-gallery');
            const viewer3D = document.querySelector('#oklch-3d-viewer');

            if (!sidebar || !resizeHandle) return;

            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            // Update gallery and 3D viewer positioning
            function updateLayout(sidebarWidth) {
                requestAnimationFrame(() => {
                    // Apply sidebar width
                    sidebar.style.width = `${sidebarWidth}px`;

                    // Sync 3D viewer centering with sidebar middle line
                    if (viewer3D) {
                        const canvas = viewer3D.querySelector('canvas');
                        if (canvas) {
                            const canvasWidth = canvas.offsetWidth;
                            const viewerWidth = viewer3D.offsetWidth;

                            // Calculate offset to align canvas center with sidebar middle
                            const sidebarMiddle = sidebarWidth / 2;
                            const canvasOffset = (viewerWidth / 2) - sidebarMiddle;

                            // Apply transform only if canvas exceeds viewer width
                            if (canvasWidth > viewerWidth) {
                                canvas.style.transform = `translateX(${-canvasOffset}px)`;
                            } else {
                                canvas.style.transform = 'translateX(0)';
                            }
                        }
                    }

                    // Gallery responsive behavior (handled by flex: 1)
                    // No explicit width needed - flexbox automatically fills remaining space
                });
            }

            // Mouse down on resize handle
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;

                resizeHandle.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';

                e.preventDefault();
            });

            // Mouse move (resize)
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                let newWidth = startWidth + deltaX;

                // Clamp to min/max widths
                const minWidth = 280;
                const maxWidth = 600;
                newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                // Apply width and update layout with 60fps animation
                updateLayout(newWidth);
            });

            // Mouse up (stop resizing)
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Reinitialize 2D pickers with new sizes after resize
                    requestAnimationFrame(() => {
                        init2DPickers();
                    });
                }
            });

            // Touch support for mobile/tablet
            resizeHandle.addEventListener('touchstart', (e) => {
                isResizing = true;
                startX = e.touches[0].clientX;
                startWidth = sidebar.offsetWidth;

                resizeHandle.classList.add('resizing');
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;

                const deltaX = e.touches[0].clientX - startX;
                let newWidth = startWidth + deltaX;

                const minWidth = 280;
                const maxWidth = 600;
                newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                // Apply width and update layout with 60fps animation
                updateLayout(newWidth);
            }, { passive: false });

            document.addEventListener('touchend', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('resizing');

                    // Reinitialize 2D pickers with new sizes after resize
                    requestAnimationFrame(() => {
                        init2DPickers();
                    });
                }
            });

            // Initial layout update
            updateLayout(sidebar.offsetWidth);
        }

        // ========== INITIALIZE ALL ==========

        initUniversalSelector();
        initSliders();
        initColorSliders(); // 🎚️ CONNECT L/C/H SLIDERS TO ALL VISUALIZATIONS
        initPropertySliders(); // Universal selection system property sliders
        init2DPickers();
        init2DPickerToggles();
        init3DViewer();
        initColorGroupCards();
        initViewToggle();
        initMockupTabs();
        initModeToggle();
        initScaffoldToggle();
        initTemplateControls();
        initAnimationControls();
        initColorHarmony();
        initTemplateLibrary();
        initHotspotSystem();
        initWidgetSystem();
        initScaffoldButtons();
        initRandomPalette();
        initValidationButton();
        initRegistryButton();
        initComplianceToggles();
        // ========== DYNAMIC COLOR GROUP REGISTRY (SINGLE SOURCE OF TRUTH) ==========

        // COLOR GROUP REGISTRY - Tracks ALL active color groups dynamically
        const colorGroupRegistry = {
            groups: new Map(), // Map<groupName, {color, usageCount, wcagCompliant, type}>

            // SCAN UI: Discover all active color-group pairs
            scanUIElements() {
                this.groups.clear();

                // FIRST: Add ALL base palette groups (even if not explicitly used in UI)
                Object.keys(colorPalette[currentMode]).forEach(groupName => {
                    const color = colorPalette[currentMode][groupName];
                    this.groups.set(groupName, {
                        color: color,
                        usageCount: 0,
                        wcagCompliant: this.checkWCAGCompliance(groupName, color),
                        type: 'palette'
                    });
                });

                // SECOND: Add scaffold colors (invisible foundation)
                const rootStyles = getComputedStyle(document.documentElement);
                const scaffoldColors = {
                    'scaffold-bg': { type: 'scaffold', cssVar: '--scaffold-bg' },
                    'scaffold-bg-elevated': { type: 'scaffold', cssVar: '--scaffold-bg-elevated' },
                    'scaffold-bg-input': { type: 'scaffold', cssVar: '--scaffold-bg-input' },
                    'scaffold-text': { type: 'scaffold', cssVar: '--scaffold-text' },
                    'scaffold-text-muted': { type: 'scaffold', cssVar: '--scaffold-text-muted' },
                    'scaffold-border': { type: 'scaffold', cssVar: '--scaffold-border' },
                    'scaffold-border-hover': { type: 'scaffold', cssVar: '--scaffold-border-hover' }
                };

                Object.entries(scaffoldColors).forEach(([name, data]) => {
                    const cssValue = rootStyles.getPropertyValue(data.cssVar).trim();
                    if (cssValue && cssValue.startsWith('oklch')) {
                        const match = cssValue.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
                        if (match) {
                            const color = { l: parseFloat(match[1]), c: parseFloat(match[2]), h: parseFloat(match[3]) };
                            this.groups.set(name, {
                                color: color,
                                usageCount: 0,
                                wcagCompliant: true, // Scaffold colors are pre-validated
                                type: 'scaffold'
                            });
                        }
                    }
                });

                // THIRD: Scan all elements with data-color-group attribute and count usage
                const elements = document.querySelectorAll('[data-color-group]');

                elements.forEach(el => {
                    const groupName = el.dataset.colorGroup;
                    if (!groupName || groupName === 'null') return;

                    // Increment usage count
                    if (this.groups.has(groupName)) {
                        this.groups.get(groupName).usageCount++;
                    } else {
                        // Dynamic group not in palette - add it
                        console.warn(`⚠️ Unknown color group found: ${groupName}`);
                    }
                });

                console.log(`📊 Color Group Registry: ${this.groups.size} groups (${Array.from(this.groups.values()).filter(g => g.type === 'palette').length} palette + ${Array.from(this.groups.values()).filter(g => g.type === 'scaffold').length} scaffold)`);
                return this.groups;
            },

            // CHECK WCAG COMPLIANCE for a color group
            checkWCAGCompliance(groupName, color) {
                // Text groups must meet contrast against background
                if (groupName === 'text' || groupName.includes('text')) {
                    const bgColor = colorPalette[currentMode]['background'];
                    return this.calculateContrast(color, bgColor) >= 4.5;
                }

                // UI elements must meet 3:1 against adjacent colors
                if (groupName === 'primary' || groupName === 'secondary' || groupName === 'accent') {
                    const bgColor = colorPalette[currentMode]['surface'];
                    return this.calculateContrast(color, bgColor) >= 3.0;
                }

                return true; // Background/surface groups are always compliant
            },

            // CALCULATE CONTRAST RATIO (WCAG formula)
            calculateContrast(color1, color2) {
                const l1 = color1.l;
                const l2 = color2.l;
                const lighter = Math.max(l1, l2);
                const darker = Math.min(l1, l2);
                return (lighter + 0.05) / (darker + 0.05);
            },

            // GET ALL GROUPS (sorted by usage count)
            getAllGroups() {
                return Array.from(this.groups.entries())
                    .sort((a, b) => b[1].usageCount - a[1].usageCount)
                    .map(([name, data]) => ({ name, ...data }));
            },

            // ADD NEW GROUP dynamically
            addGroup(groupName, color) {
                if (!this.groups.has(groupName)) {
                    this.groups.set(groupName, {
                        color: color,
                        usageCount: 0,
                        wcagCompliant: this.checkWCAGCompliance(groupName, color)
                    });
                    console.log(`✨ New color group created: ${groupName}`);
                    return true;
                }
                return false;
            },

            // UPDATE GROUP COLOR
            updateGroup(groupName, newColor) {
                if (this.groups.has(groupName)) {
                    const group = this.groups.get(groupName);
                    group.color = newColor;
                    group.wcagCompliant = this.checkWCAGCompliance(groupName, newColor);
                    console.log(`🎨 Color group updated: ${groupName}`);
                    return true;
                }
                return false;
            }
        };

        // ========== COMPLETE UI CONFIG REGISTRY (TOTALITY APPROACH) ==========
        // MASTER BLUEPRINT: Compiles 100% of UI configurations for counter-weight operations

        const completeUIRegistry = {
            snapshot: null,
            lastUpdate: null,

            // CAPTURE COMPLETE UI STATE
            captureCompleteState() {
                console.log('📸 Capturing COMPLETE UI State (TOTALITY APPROACH)...');

                const timestamp = new Date();

                // 1. COLOR SYSTEM - Complete color architecture
                const colorSystem = {
                    mode: currentMode,
                    currentGroup: currentGroup,
                    currentColor: { ...currentColor },
                    palette: {
                        light: JSON.parse(JSON.stringify(colorPalette.light)),
                        dark: JSON.parse(JSON.stringify(colorPalette.dark))
                    },
                    groups: colorGroupRegistry.getAllGroups(),
                    scaffold: this.extractScaffoldColors(),
                    harmonies: this.extractHarmonies(),
                    relationships: this.extractColorRelationships()
                };

                // 2. LAYOUT SYSTEM - All spacing, sizes, positions
                const layoutSystem = {
                    sidebarWidth: document.querySelector('.left-sidebar')?.offsetWidth || 0,
                    galleryWidth: document.querySelector('.component-gallery')?.offsetWidth || 0,
                    viewportWidth: window.innerWidth,
                    viewportHeight: window.innerHeight,
                    spacing: this.extractSpacingValues(),
                    grid: this.extractGridConfigs()
                };

                // 3. TYPOGRAPHY SYSTEM - All text configurations
                const typographySystem = {
                    fonts: this.extractFontConfigs(),
                    sizes: this.extractFontSizes(),
                    weights: this.extractFontWeights(),
                    lineHeights: this.extractLineHeights(),
                    letterSpacings: this.extractLetterSpacings()
                };

                // 4. SHAPE SYSTEM - All geometric properties
                const shapeSystem = {
                    borderRadii: this.extractBorderRadii(),
                    padding: this.extractPadding(),
                    margins: this.extractMargins(),
                    borders: this.extractBorderConfigs()
                };

                // 5. ANIMATION SYSTEM - All motion configurations
                const animationSystem = {
                    settings: { ...animationSettings },
                    durations: this.extractAnimationDurations(),
                    easings: this.extractEasings(),
                    trajectories: this.extractTrajectories()
                };

                // 6. COMPONENT SYSTEM - All UI widgets and states
                const componentSystem = {
                    widgets: this.extractWidgetConfigs(),
                    states: this.extractComponentStates(),
                    interactions: this.extractInteractionStates()
                };

                // 7. COMPLIANCE SYSTEM - All validation and accessibility
                const complianceSystem = {
                    wcag: this.extractWCAGStatus(),
                    apca: this.extractAPCAStatus(),
                    validation: globalColorValidator.validationResults,
                    safeZone: this.extractSafeZoneData()
                };

                // 8. COUNTER-WEIGHT SYSTEM - Balance and relationships
                const counterWeightSystem = {
                    lightDarkBalance: this.calculateLightDarkBalance(),
                    chromaDistribution: this.calculateChromaDistribution(),
                    hueDistribution: this.calculateHueDistribution(),
                    contrastRatios: this.calculateAllContrastRatios(),
                    visualWeight: this.calculateVisualWeight()
                };

                // 9. TEMPLATE SYSTEM - All presets and hotspots
                const templateSystem = {
                    activeTemplate: this.extractActiveTemplate(),
                    hotspots: this.extractHotspotData(),
                    presets: this.extractPresetData()
                };

                // 10. META SYSTEM - Environment and settings
                const metaSystem = {
                    timestamp: timestamp.toISOString(),
                    version: '1.0.0',
                    userAgent: navigator.userAgent,
                    settings: this.extractGlobalSettings()
                };

                // ASSEMBLE COMPLETE SNAPSHOT
                this.snapshot = {
                    meta: metaSystem,
                    color: colorSystem,
                    layout: layoutSystem,
                    typography: typographySystem,
                    shape: shapeSystem,
                    animation: animationSystem,
                    component: componentSystem,
                    compliance: complianceSystem,
                    counterWeight: counterWeightSystem,
                    template: templateSystem
                };

                this.lastUpdate = timestamp;

                console.log('✅ Complete UI State Captured:', this.snapshot);
                return this.snapshot;
            },

            // EXTRACTION METHODS

            extractScaffoldColors() {
                const rootStyles = getComputedStyle(document.documentElement);
                const scaffoldVars = [
                    '--scaffold-bg', '--scaffold-bg-elevated', '--scaffold-bg-input',
                    '--scaffold-text', '--scaffold-text-muted',
                    '--scaffold-border', '--scaffold-border-hover'
                ];

                const scaffold = {};
                scaffoldVars.forEach(varName => {
                    const value = rootStyles.getPropertyValue(varName).trim();
                    scaffold[varName.replace('--', '')] = value;
                });
                return scaffold;
            },

            extractHarmonies() {
                // Extract active color harmonies from hotspots
                const hotspots = document.querySelectorAll('.hotspot-preview-card');
                return Array.from(hotspots).map(card => ({
                    name: card.querySelector('.hotspot-preview-card-title')?.textContent,
                    harmony: card.querySelector('.hotspot-label')?.textContent
                }));
            },

            extractColorRelationships() {
                // Calculate relationships between all color groups
                const groups = colorGroupRegistry.getAllGroups();
                const relationships = [];

                for (let i = 0; i < groups.length; i++) {
                    for (let j = i + 1; j < groups.length; j++) {
                        const g1 = groups[i];
                        const g2 = groups[j];
                        const contrast = colorGroupRegistry.calculateContrast(g1.color, g2.color);
                        const hueDiff = Math.abs(g1.color.h - g2.color.h);

                        relationships.push({
                            pair: [g1.name, g2.name],
                            contrast: contrast.toFixed(2),
                            hueDifference: hueDiff.toFixed(0),
                            harmony: this.detectHarmony(hueDiff)
                        });
                    }
                }
                return relationships;
            },

            detectHarmony(hueDiff) {
                if (hueDiff < 30) return 'analogous';
                if (hueDiff > 150 && hueDiff < 210) return 'complementary';
                if (hueDiff > 110 && hueDiff < 130) return 'triadic';
                if (hueDiff > 80 && hueDiff < 100) return 'square';
                return 'custom';
            },

            extractSpacingValues() {
                const elements = document.querySelectorAll('[data-color-group]');
                const spacing = new Set();
                elements.forEach(el => {
                    const styles = getComputedStyle(el);
                    spacing.add(styles.padding);
                    spacing.add(styles.margin);
                    spacing.add(styles.gap);
                });
                return Array.from(spacing);
            },

            extractGridConfigs() {
                const gallery = document.querySelector('.component-gallery');
                if (!gallery) return {};
                const styles = getComputedStyle(gallery);
                return {
                    gridTemplateColumns: styles.gridTemplateColumns,
                    gap: styles.gap,
                    padding: styles.padding
                };
            },

            extractFontConfigs() {
                const elements = document.querySelectorAll('[data-color-group]');
                const fonts = new Set();
                elements.forEach(el => {
                    fonts.add(getComputedStyle(el).fontFamily);
                });
                return Array.from(fonts);
            },

            extractFontSizes() {
                const elements = document.querySelectorAll('[data-color-group]');
                const sizes = new Set();
                elements.forEach(el => {
                    sizes.add(getComputedStyle(el).fontSize);
                });
                return Array.from(sizes).sort((a, b) => parseFloat(a) - parseFloat(b));
            },

            extractFontWeights() {
                const elements = document.querySelectorAll('[data-color-group]');
                const weights = new Set();
                elements.forEach(el => {
                    weights.add(getComputedStyle(el).fontWeight);
                });
                return Array.from(weights).sort((a, b) => parseInt(a) - parseInt(b));
            },

            extractLineHeights() {
                const elements = document.querySelectorAll('[data-color-group]');
                const lineHeights = new Set();
                elements.forEach(el => {
                    lineHeights.add(getComputedStyle(el).lineHeight);
                });
                return Array.from(lineHeights);
            },

            extractLetterSpacings() {
                const elements = document.querySelectorAll('[data-color-group]');
                const spacings = new Set();
                elements.forEach(el => {
                    spacings.add(getComputedStyle(el).letterSpacing);
                });
                return Array.from(spacings);
            },

            extractBorderRadii() {
                const elements = document.querySelectorAll('[data-color-group]');
                const radii = new Set();
                elements.forEach(el => {
                    radii.add(getComputedStyle(el).borderRadius);
                });
                return Array.from(radii);
            },

            extractPadding() {
                const elements = document.querySelectorAll('[data-color-group]');
                const padding = new Set();
                elements.forEach(el => {
                    padding.add(getComputedStyle(el).padding);
                });
                return Array.from(padding);
            },

            extractMargins() {
                const elements = document.querySelectorAll('[data-color-group]');
                const margins = new Set();
                elements.forEach(el => {
                    margins.add(getComputedStyle(el).margin);
                });
                return Array.from(margins);
            },

            extractBorderConfigs() {
                const elements = document.querySelectorAll('[data-color-group]');
                const borders = new Set();
                elements.forEach(el => {
                    const styles = getComputedStyle(el);
                    borders.add(`${styles.borderWidth} ${styles.borderStyle} ${styles.borderColor}`);
                });
                return Array.from(borders);
            },

            extractAnimationDurations() {
                return [animationSettings.duration];
            },

            extractEasings() {
                return ['cubic-bezier(0.4, 0.0, 0.2, 1)']; // ease-in-out-cubic
            },

            extractTrajectories() {
                return ['linear', 'easeInOutCubic'];
            },

            extractWidgetConfigs() {
                const widgets = document.querySelectorAll('[data-widget-id]');
                return Array.from(widgets).map(w => ({
                    id: w.dataset.widgetId,
                    visible: w.style.display !== 'none',
                    collapsed: w.classList.contains('collapsed')
                }));
            },

            extractComponentStates() {
                const components = document.querySelectorAll('[data-color-group]');
                return {
                    total: components.length,
                    byGroup: this.groupComponentsByColorGroup(components)
                };
            },

            groupComponentsByColorGroup(components) {
                const grouped = {};
                components.forEach(el => {
                    const group = el.dataset.colorGroup;
                    if (!grouped[group]) grouped[group] = 0;
                    grouped[group]++;
                });
                return grouped;
            },

            extractInteractionStates() {
                return {
                    currentMode: currentMode,
                    currentGroup: currentGroup,
                    sidebarOpen: !document.querySelector('.left-sidebar')?.classList.contains('collapsed')
                };
            },

            extractWCAGStatus() {
                const groups = colorGroupRegistry.getAllGroups();
                return {
                    compliant: groups.filter(g => g.wcagCompliant).length,
                    nonCompliant: groups.filter(g => !g.wcagCompliant).length,
                    total: groups.length
                };
            },

            extractAPCAStatus() {
                return { enabled: false }; // Placeholder
            },

            extractSafeZoneData() {
                const safeZone = document.querySelector('.safe-zone-grid');
                if (!safeZone) return {};
                return {
                    visible: safeZone.style.display !== 'none',
                    cards: document.querySelectorAll('.safe-zone-card').length
                };
            },

            calculateLightDarkBalance() {
                const lightColors = Object.values(colorPalette.light);
                const darkColors = Object.values(colorPalette.dark);

                const avgLightL = lightColors.reduce((sum, c) => sum + c.l, 0) / lightColors.length;
                const avgDarkL = darkColors.reduce((sum, c) => sum + c.l, 0) / darkColors.length;

                return {
                    lightAvgLightness: avgLightL.toFixed(2),
                    darkAvgLightness: avgDarkL.toFixed(2),
                    difference: Math.abs(avgLightL - avgDarkL).toFixed(2)
                };
            },

            calculateChromaDistribution() {
                const groups = colorGroupRegistry.getAllGroups();
                const chromas = groups.map(g => g.color.c);

                return {
                    min: Math.min(...chromas).toFixed(2),
                    max: Math.max(...chromas).toFixed(2),
                    avg: (chromas.reduce((a, b) => a + b, 0) / chromas.length).toFixed(2),
                    distribution: chromas.map(c => c.toFixed(2))
                };
            },

            calculateHueDistribution() {
                const groups = colorGroupRegistry.getAllGroups();
                const hues = groups.map(g => g.color.h);

                return {
                    min: Math.min(...hues).toFixed(0),
                    max: Math.max(...hues).toFixed(0),
                    avg: (hues.reduce((a, b) => a + b, 0) / hues.length).toFixed(0),
                    distribution: hues.map(h => h.toFixed(0))
                };
            },

            calculateAllContrastRatios() {
                const groups = colorGroupRegistry.getAllGroups();
                const ratios = [];

                groups.forEach((g1, i) => {
                    groups.forEach((g2, j) => {
                        if (i < j) {
                            const ratio = colorGroupRegistry.calculateContrast(g1.color, g2.color);
                            ratios.push({
                                pair: [g1.name, g2.name],
                                ratio: ratio.toFixed(2)
                            });
                        }
                    });
                });

                return ratios;
            },

            calculateVisualWeight() {
                const groups = colorGroupRegistry.getAllGroups();

                return groups.map(g => ({
                    name: g.name,
                    weight: (g.color.l * 0.5 + g.color.c * 0.5).toFixed(2), // Simple visual weight formula
                    usage: g.usageCount
                }));
            },

            extractActiveTemplate() {
                return null; // TODO: Implement template tracking
            },

            extractHotspotData() {
                const hotspotName = document.getElementById('current-hotspot-name')?.textContent;
                return { active: hotspotName !== 'None' ? hotspotName : null };
            },

            extractPresetData() {
                return {}; // TODO: Implement preset tracking
            },

            extractGlobalSettings() {
                return {
                    allowWCAGViolation: document.getElementById('allow-wcag-violation')?.checked || false,
                    allowAPCAViolation: document.getElementById('allow-apca-violation')?.checked || false,
                    autoSync: true,
                    animationEnabled: true
                };
            },

            // EXPORT METHODS

            exportAsJSON() {
                if (!this.snapshot) this.captureCompleteState();
                return JSON.stringify(this.snapshot, null, 2);
            },

            exportAsCompactJSON() {
                if (!this.snapshot) this.captureCompleteState();
                return JSON.stringify(this.snapshot);
            },

            downloadJSON() {
                const json = this.exportAsJSON();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ui-config-${new Date().toISOString()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },

            // COUNTER-WEIGHT OPERATIONS

            calculateSlideTrajectory(fromColor, toColor, duration) {
                // Calculate optimal animation path for color transition
                const lDelta = toColor.l - fromColor.l;
                const cDelta = toColor.c - fromColor.c;

                // Shortest hue path
                let hDelta = toColor.h - fromColor.h;
                if (Math.abs(hDelta) > 180) {
                    hDelta = hDelta > 0 ? hDelta - 360 : hDelta + 360;
                }

                return {
                    deltas: { l: lDelta, c: cDelta, h: hDelta },
                    distance: Math.sqrt(lDelta ** 2 + cDelta ** 2 + (hDelta / 360) ** 2),
                    duration: duration,
                    velocity: {
                        l: lDelta / duration,
                        c: cDelta / duration,
                        h: hDelta / duration
                    }
                };
            },

            calculateCounterWeight(targetGroup, targetColor) {
                // Calculate what other groups need to adjust to maintain balance
                const groups = colorGroupRegistry.getAllGroups();
                const adjustments = [];

                groups.forEach(g => {
                    if (g.name === targetGroup) return;

                    // Calculate required adjustment to maintain harmony
                    const currentContrast = colorGroupRegistry.calculateContrast(g.color, targetColor);
                    const targetContrast = g.name === 'text' ? 4.5 : 3.0;

                    if (currentContrast < targetContrast) {
                        adjustments.push({
                            group: g.name,
                            currentContrast: currentContrast.toFixed(2),
                            targetContrast: targetContrast,
                            action: 'increase_lightness_difference'
                        });
                    }
                });

                return adjustments;
            },

            // QUERY METHODS

            getSystemByCategory(category) {
                if (!this.snapshot) this.captureCompleteState();
                return this.snapshot[category] || null;
            },

            getAllCategories() {
                if (!this.snapshot) this.captureCompleteState();
                return Object.keys(this.snapshot);
            },

            getStatistics() {
                if (!this.snapshot) this.captureCompleteState();

                return {
                    totalColors: this.snapshot.color.groups.length,
                    totalComponents: this.snapshot.component.states.total,
                    totalWidgets: this.snapshot.component.widgets.length,
                    wcagCompliance: `${this.snapshot.compliance.wcag.compliant}/${this.snapshot.compliance.wcag.total}`,
                    visualWeightBalance: this.snapshot.counterWeight.visualWeight.reduce((sum, w) => sum + parseFloat(w.weight), 0) / this.snapshot.counterWeight.visualWeight.length
                };
            }
        };

        // ========== GLOBAL VALIDATOR (INCLUDES SCAFFOLD) ==========
        // Tests core UI rules across ENTIRE system and reports violations

        const globalColorValidator = {
            validationResults: null,

            // CORE VALIDATION RULES
            rules: {
                // Rule 1: WCAG Text Contrast (4.5:1 minimum)
                wcagTextContrast: {
                    name: 'WCAG Text Contrast',
                    severity: 'critical',
                    check: (element, registry) => {
                        const group = element.dataset.colorGroup;
                        if (!group || (!group.includes('text') && group !== 'text')) return { valid: true };

                        const groupData = registry.groups.get(group);
                        if (!groupData) return { valid: false, reason: 'Group not found in registry' };

                        const bgColor = colorPalette[currentMode]['background'];
                        const contrast = registry.calculateContrast(groupData.color, bgColor);

                        return {
                            valid: contrast >= 4.5,
                            contrast: contrast.toFixed(2),
                            required: '4.5:1',
                            reason: contrast < 4.5 ? `Insufficient contrast: ${contrast.toFixed(2)}:1 (need 4.5:1)` : null
                        };
                    }
                },

                // Rule 2: WCAG UI Contrast (3.0:1 minimum)
                wcagUIContrast: {
                    name: 'WCAG UI Contrast',
                    severity: 'high',
                    check: (element, registry) => {
                        const group = element.dataset.colorGroup;
                        if (!group || group.includes('text') || group === 'background' || group === 'surface') return { valid: true };

                        const groupData = registry.groups.get(group);
                        if (!groupData) return { valid: false, reason: 'Group not found in registry' };

                        const bgColor = colorPalette[currentMode]['surface'];
                        const contrast = registry.calculateContrast(groupData.color, bgColor);

                        return {
                            valid: contrast >= 3.0,
                            contrast: contrast.toFixed(2),
                            required: '3.0:1',
                            reason: contrast < 3.0 ? `Insufficient contrast: ${contrast.toFixed(2)}:1 (need 3.0:1)` : null
                        };
                    }
                },

                // Rule 3: Scaffold Variables Usage
                scaffoldUsage: {
                    name: 'Scaffold Variables Usage',
                    severity: 'medium',
                    check: (element, registry) => {
                        const computedStyle = getComputedStyle(element);
                        const bgColor = computedStyle.backgroundColor;
                        const textColor = computedStyle.color;

                        // Check if using scaffold variables (presence in registry indicates proper usage)
                        const hasScaffoldBg = bgColor.includes('oklch') || bgColor.includes('var(--scaffold');
                        const hasScaffoldText = textColor.includes('oklch') || textColor.includes('var(--scaffold');

                        return {
                            valid: hasScaffoldBg || hasScaffoldText,
                            reason: !hasScaffoldBg && !hasScaffoldText ? 'Element not using scaffold variables' : null
                        };
                    }
                },

                // Rule 4: Color Group Tagging
                colorGroupTagging: {
                    name: 'Color Group Tagging',
                    severity: 'low',
                    check: (element, registry) => {
                        const hasColorGroup = element.hasAttribute('data-color-group');
                        const hasColor = getComputedStyle(element).backgroundColor !== 'rgba(0, 0, 0, 0)';

                        return {
                            valid: !hasColor || hasColorGroup,
                            reason: hasColor && !hasColorGroup ? 'Colored element missing data-color-group attribute' : null
                        };
                    }
                },

                // Rule 5: Semantic Consistency (same groups should use same colors)
                semanticConsistency: {
                    name: 'Semantic Consistency',
                    severity: 'medium',
                    check: (element, registry) => {
                        const group = element.dataset.colorGroup;
                        if (!group) return { valid: true };

                        const groupData = registry.groups.get(group);
                        if (!groupData) return { valid: false, reason: 'Group not in registry' };

                        const expectedColor = groupData.color;
                        const computedStyle = getComputedStyle(element);
                        const actualBg = computedStyle.backgroundColor;

                        // Parse actual color if OKLCH
                        if (actualBg.includes('oklch')) {
                            const match = actualBg.match(/oklch\(([\d.]+)\s+([\d.]+)\s+([\d.]+)\)/);
                            if (match) {
                                const actual = { l: parseFloat(match[1]), c: parseFloat(match[2]), h: parseFloat(match[3]) };
                                const delta = Math.abs(actual.l - expectedColor.l) +
                                             Math.abs(actual.c - expectedColor.c) +
                                             Math.abs(actual.h - expectedColor.h);

                                return {
                                    valid: delta < 0.1, // Tolerance for floating point
                                    reason: delta >= 0.1 ? `Color mismatch: element color differs from registry (Δ${delta.toFixed(3)})` : null
                                };
                            }
                        }

                        return { valid: true };
                    }
                }
            },

            // RUN FULL VALIDATION
            validate() {
                console.log('🔍 Starting Global Validation...');

                // Scan UI first
                colorGroupRegistry.scanUIElements();

                const violations = {
                    critical: [],
                    high: [],
                    medium: [],
                    low: []
                };

                let totalChecks = 0;
                let totalViolations = 0;

                // Scan all elements with color-group attributes
                const elements = document.querySelectorAll('[data-color-group]');

                elements.forEach(element => {
                    Object.entries(this.rules).forEach(([ruleId, rule]) => {
                        totalChecks++;
                        const result = rule.check(element, colorGroupRegistry);

                        if (!result.valid) {
                            totalViolations++;
                            violations[rule.severity].push({
                                rule: rule.name,
                                element: element,
                                group: element.dataset.colorGroup,
                                reason: result.reason,
                                details: result
                            });
                        }
                    });
                });

                // Store results
                this.validationResults = {
                    timestamp: new Date(),
                    totalChecks,
                    totalViolations,
                    violations,
                    score: ((totalChecks - totalViolations) / totalChecks * 100).toFixed(1)
                };

                console.log(`✅ Validation Complete: ${this.validationResults.score}% compliant (${totalViolations}/${totalChecks} violations)`);
                console.log(`   Critical: ${violations.critical.length} | High: ${violations.high.length} | Medium: ${violations.medium.length} | Low: ${violations.low.length}`);

                return this.validationResults;
            },

            // GET VALIDATION REPORT (human-readable)
            getReport() {
                if (!this.validationResults) {
                    return 'No validation results. Run validate() first.';
                }

                const r = this.validationResults;
                let report = `
🔍 GLOBAL COLOR VALIDATION REPORT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Overall Score: ${r.score}% compliant
Total Checks: ${r.totalChecks}
Violations: ${r.totalViolations}

SEVERITY BREAKDOWN:
🔴 Critical: ${r.violations.critical.length}
🟠 High: ${r.violations.high.length}
🟡 Medium: ${r.violations.medium.length}
🔵 Low: ${r.violations.low.length}
`;

                // Detail critical violations
                if (r.violations.critical.length > 0) {
                    report += `\n🔴 CRITICAL VIOLATIONS:\n`;
                    r.violations.critical.forEach((v, i) => {
                        report += `   ${i+1}. ${v.rule} - ${v.group}\n`;
                        report += `      ${v.reason}\n`;
                    });
                }

                // Detail high violations
                if (r.violations.high.length > 0) {
                    report += `\n🟠 HIGH VIOLATIONS:\n`;
                    r.violations.high.forEach((v, i) => {
                        report += `   ${i+1}. ${v.rule} - ${v.group}\n`;
                        report += `      ${v.reason}\n`;
                    });
                }

                return report;
            },

            // GET VIOLATIONS BY GROUP
            getViolationsByGroup() {
                if (!this.validationResults) return {};

                const byGroup = {};

                ['critical', 'high', 'medium', 'low'].forEach(severity => {
                    this.validationResults.violations[severity].forEach(v => {
                        if (!byGroup[v.group]) {
                            byGroup[v.group] = { critical: 0, high: 0, medium: 0, low: 0, violations: [] };
                        }
                        byGroup[v.group][severity]++;
                        byGroup[v.group].violations.push(v);
                    });
                });

                return byGroup;
            },

            // AUTO-FIX (where possible)
            autoFix() {
                if (!this.validationResults) {
                    console.warn('⚠️ No validation results to fix. Run validate() first.');
                    return;
                }

                let fixedCount = 0;

                // Fix WCAG contrast violations by adjusting lightness
                this.validationResults.violations.critical.forEach(v => {
                    if (v.rule === 'WCAG Text Contrast') {
                        const group = v.group;
                        const groupData = colorGroupRegistry.groups.get(group);

                        if (groupData) {
                            // Adjust lightness to meet 4.5:1 contrast
                            const bgColor = colorPalette[currentMode]['background'];
                            let newColor = { ...groupData.color };

                            // Increase contrast by adjusting lightness
                            if (bgColor.l > 0.5) {
                                // Dark mode - decrease lightness
                                newColor.l = Math.max(0.1, newColor.l - 0.1);
                            } else {
                                // Light mode - increase lightness
                                newColor.l = Math.min(0.9, newColor.l + 0.1);
                            }

                            colorGroupRegistry.updateGroup(group, newColor);
                            colorPalette[currentMode][group] = newColor;
                            fixedCount++;
                        }
                    }
                });

                console.log(`✨ Auto-fixed ${fixedCount} violations`);

                // Re-validate
                return this.validate();
            }
        };

        // ========== COMPREHENSIVE COLOR NAMING DATABASE ==========

        const COLOR_NAME_DATABASE = [
            // Reds
            { name: "Crimson", l: 0.47, c: 0.16, h: 24 },
            { name: "Red", l: 0.55, c: 0.22, h: 27 },
            { name: "Scarlet", l: 0.58, c: 0.21, h: 25 },
            { name: "Ruby", l: 0.45, c: 0.18, h: 23 },
            { name: "Cherry", l: 0.42, c: 0.15, h: 22 },
            { name: "Rose", l: 0.65, c: 0.12, h: 15 },
            { name: "Coral", l: 0.68, c: 0.14, h: 35 },
            { name: "Salmon", l: 0.72, c: 0.11, h: 38 },
            { name: "Pink", l: 0.78, c: 0.09, h: 12 },
            { name: "Hot Pink", l: 0.65, c: 0.20, h: 350 },

            // Oranges
            { name: "Orange", l: 0.70, c: 0.16, h: 45 },
            { name: "Tangerine", l: 0.68, c: 0.18, h: 42 },
            { name: "Amber", l: 0.75, c: 0.14, h: 65 },
            { name: "Gold", l: 0.80, c: 0.12, h: 75 },
            { name: "Apricot", l: 0.76, c: 0.10, h: 50 },
            { name: "Peach", l: 0.82, c: 0.08, h: 48 },

            // Yellows
            { name: "Yellow", l: 0.92, c: 0.14, h: 95 },
            { name: "Lemon", l: 0.94, c: 0.16, h: 100 },
            { name: "Canary", l: 0.90, c: 0.15, h: 98 },
            { name: "Cream", l: 0.95, c: 0.04, h: 90 },
            { name: "Butter", l: 0.88, c: 0.09, h: 92 },

            // Greens
            { name: "Lime", l: 0.85, c: 0.18, h: 125 },
            { name: "Green", l: 0.60, c: 0.15, h: 140 },
            { name: "Emerald", l: 0.65, c: 0.16, h: 155 },
            { name: "Jade", l: 0.62, c: 0.14, h: 150 },
            { name: "Forest", l: 0.42, c: 0.12, h: 145 },
            { name: "Olive", l: 0.55, c: 0.08, h: 110 },
            { name: "Mint", l: 0.88, c: 0.10, h: 155 },
            { name: "Sage", l: 0.70, c: 0.06, h: 135 },

            // Cyans
            { name: "Cyan", l: 0.90, c: 0.14, h: 195 },
            { name: "Turquoise", l: 0.75, c: 0.12, h: 200 },
            { name: "Teal", l: 0.55, c: 0.10, h: 205 },
            { name: "Aqua", l: 0.85, c: 0.13, h: 192 },

            // Blues
            { name: "Sky Blue", l: 0.78, c: 0.11, h: 235 },
            { name: "Blue", l: 0.55, c: 0.18, h: 265 },
            { name: "Azure", l: 0.70, c: 0.14, h: 240 },
            { name: "Cobalt", l: 0.48, c: 0.19, h: 260 },
            { name: "Navy", l: 0.28, c: 0.14, h: 270 },
            { name: "Indigo", l: 0.38, c: 0.16, h: 285 },
            { name: "Sapphire", l: 0.42, c: 0.17, h: 255 },

            // Purples/Magentas
            { name: "Purple", l: 0.50, c: 0.16, h: 300 },
            { name: "Violet", l: 0.55, c: 0.18, h: 310 },
            { name: "Magenta", l: 0.60, c: 0.22, h: 330 },
            { name: "Fuchsia", l: 0.65, c: 0.24, h: 325 },
            { name: "Plum", l: 0.52, c: 0.12, h: 315 },
            { name: "Lavender", l: 0.78, c: 0.09, h: 305 },
            { name: "Orchid", l: 0.68, c: 0.15, h: 320 },

            // Neutrals
            { name: "White", l: 0.98, c: 0.01, h: 0 },
            { name: "Snow", l: 0.96, c: 0.02, h: 0 },
            { name: "Ivory", l: 0.94, c: 0.03, h: 60 },
            { name: "Beige", l: 0.88, c: 0.04, h: 75 },
            { name: "Tan", l: 0.75, c: 0.05, h: 65 },
            { name: "Khaki", l: 0.80, c: 0.06, h: 70 },
            { name: "Silver", l: 0.75, c: 0.01, h: 0 },
            { name: "Gray", l: 0.55, c: 0.01, h: 0 },
            { name: "Charcoal", l: 0.35, c: 0.02, h: 0 },
            { name: "Black", l: 0.08, c: 0.01, h: 0 },
            { name: "Slate", l: 0.45, c: 0.03, h: 240 },

            // Browns
            { name: "Brown", l: 0.42, c: 0.08, h: 45 },
            { name: "Chocolate", l: 0.38, c: 0.09, h: 40 },
            { name: "Coffee", l: 0.32, c: 0.07, h: 42 },
            { name: "Sepia", l: 0.40, c: 0.06, h: 48 },
            { name: "Mahogany", l: 0.35, c: 0.10, h: 38 },
            { name: "Maroon", l: 0.30, c: 0.12, h: 20 }
        ];

        /**
         * Find the closest named color to an OKLCH color
         * @param {Object} oklch - OKLCH color {l, c, h}
         * @returns {string} - Closest color name
         */
        function getClosestColorName(oklch) {
            let minDistance = Infinity;
            let closestName = "Unknown";

            COLOR_NAME_DATABASE.forEach(namedColor => {
                // Calculate perceptual distance in OKLCH space
                const dL = Math.abs(oklch.l - namedColor.l);
                const dC = Math.abs(oklch.c - namedColor.c);

                // Hue distance (circular)
                let dH = Math.abs(oklch.h - namedColor.h);
                if (dH > 180) dH = 360 - dH;
                dH = dH / 360; // Normalize to 0-1

                // Weighted Euclidean distance
                // L is most important, C is moderately important, H is least important for lightness extremes
                const wL = 2.0;
                const wC = 1.0;
                const wH = oklch.l > 0.9 || oklch.l < 0.15 ? 0.3 : 1.5; // Hue matters less for very light/dark colors

                const distance = Math.sqrt(
                    wL * dL * dL +
                    wC * dC * dC +
                    wH * dH * dH
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestName = namedColor.name;
                }
            });

            return closestName;
        }

        /**
         * Get human-readable group name
         * @param {string} groupName - Internal group name (e.g., "primary", "background")
         * @returns {string} - Capitalized, human-readable name
         */
        function getGroupDisplayName(groupName) {
            const displayNames = {
                'primary': 'Primary',
                'secondary': 'Secondary',
                'accent': 'Accent',
                'background': 'Background',
                'surface': 'Surface',
                'text': 'Text',
                'border': 'Border',
                'success': 'Success',
                'warning': 'Warning',
                'error': 'Error',
                'info': 'Info',
                'disabled': 'Disabled',
                'hover': 'Hover',
                'focus': 'Focus',
                'active': 'Active'
            };

            return displayNames[groupName] || groupName.charAt(0).toUpperCase() + groupName.slice(1);
        }

        /**
         * Standard ordering for color groups
         * Background always first, then logical grouping
         */
        const COLOR_GROUP_ORDER = [
            'background',
            'surface',
            'text',
            'border',
            'primary',
            'secondary',
            'accent',
            'success',
            'warning',
            'error',
            'info',
            'disabled',
            'hover',
            'focus',
            'active'
        ];

        /**
         * Sort color-component pairs by standard order
         * @param {Array} pairs - Array of COLOR-COMPONENT PAIRS
         * @returns {Array} - Sorted pairs
         */
        function sortPairsByStandardOrder(pairs) {
            return pairs.sort((a, b) => {
                // First, sort by color group order
                const aOrder = COLOR_GROUP_ORDER.indexOf(a.colorGroup);
                const bOrder = COLOR_GROUP_ORDER.indexOf(b.colorGroup);

                const aIndex = aOrder === -1 ? 999 : aOrder;
                const bIndex = bOrder === -1 ? 999 : bOrder;

                if (aIndex !== bIndex) {
                    return aIndex - bIndex;
                }

                // If same color group, sort by usage count (descending)
                return b.count - a.count;
            });
        }

        // ========== UNIVERSAL REACTIVE COLOR NAME UPDATE SYSTEM ==========

        /**
         * Updates color names throughout the ENTIRE system
         * This creates the "SINGLE INTELLIGENT INTER-CONNECTED SYSTEM"
         *
         * Integrates color names into:
         * 1. Color Group selector buttons
         * 2. Current Selection badge
         * 3. Central Control Panel
         * 4. Console logs (via existing functions)
         * 5. Notifications (via existing functions)
         * 6. Tooltips and aria-labels
         *
         * Called automatically on:
         * - Color slider adjustments
         * - Random palette generation
         * - Mode switching (light/dark)
         * - Palette loading
         * - Trajectory applications
         * - Undo/redo operations
         */
        function updateAllColorNames() {
            // ========== 1. UPDATE COLOR GROUP SELECTOR BUTTONS ==========
            const colorGroupCards = document.querySelectorAll('.color-group-card');

            colorGroupCards.forEach(card => {
                const group = card.dataset.group;
                if (!group) return;

                const color = colorPalette[currentMode][group];
                if (!color) return;

                const colorName = getClosestColorName(color);
                const groupDisplayName = getGroupDisplayName(group);

                // Find the button or preview element inside the card
                const button = card.querySelector('.btn');
                const badge = card.querySelector('.badge');
                const preview = card.querySelector('[style*="background: var(--scaffold"]');
                const textSample = card.querySelector('span[style*="font-size: 32px"]');

                if (button) {
                    // Store original text on first run, or retrieve it
                    if (!button.dataset.originalText) {
                        button.dataset.originalText = button.textContent.trim();
                    }
                    const originalText = button.dataset.originalText;

                    // Update button text to show color name
                    button.textContent = `${colorName} ${originalText}`;
                    button.setAttribute('aria-label', `${colorName} ${groupDisplayName} button`);
                } else if (badge) {
                    // Update badge text
                    badge.textContent = `${colorName} Badge`;
                    badge.setAttribute('aria-label', `${colorName} ${groupDisplayName} badge`);
                } else if (preview) {
                    // Background/Surface previews don't need text update
                    card.setAttribute('aria-label', `${colorName} ${groupDisplayName}`);
                } else if (textSample) {
                    // Text sample keeps "Abc" but update aria-label
                    card.setAttribute('aria-label', `${colorName} ${groupDisplayName} text sample`);
                }

                // Update the description text below
                const descriptionEl = card.querySelector('div[style*="font-size: 10px"]');
                if (descriptionEl) {
                    // Store original description on first run, or retrieve it
                    if (!descriptionEl.dataset.originalText) {
                        descriptionEl.dataset.originalText = descriptionEl.textContent.trim();
                    }
                    const originalDescription = descriptionEl.dataset.originalText;

                    // Update with color name prefix
                    descriptionEl.textContent = `${colorName} • ${originalDescription}`;
                }
            });

            // ========== 2. UPDATE CURRENT SELECTION BADGE ==========
            if (currentGroup && currentColor) {
                const colorName = getClosestColorName(currentColor);
                const groupDisplayName = getGroupDisplayName(currentGroup);
                const currentGroupBadge = document.getElementById('current-group');
                if (currentGroupBadge) {
                    currentGroupBadge.textContent = `${colorName} ${groupDisplayName}`;
                }
            }

            // ========== 3. UPDATE CENTRAL CONTROL PANEL ==========
            if (currentGroup) {
                const color = colorPalette[currentMode][currentGroup];
                if (color) {
                    updateCentralControlDisplay(currentGroup, color);
                }
            }

            // ========== 4. UPDATE SLIDER TOOLTIPS/ARIA-LABELS ==========
            const lSlider = document.getElementById('lightness-slider');
            const cSlider = document.getElementById('chroma-slider');
            const hSlider = document.getElementById('hue-slider');

            if (lSlider && currentGroup && currentColor) {
                const colorName = getClosestColorName(currentColor);
                const groupDisplayName = getGroupDisplayName(currentGroup);
                lSlider.setAttribute('aria-label', `${colorName} ${groupDisplayName} lightness: ${currentColor.l.toFixed(2)}`);
                cSlider.setAttribute('aria-label', `${colorName} ${groupDisplayName} chroma: ${currentColor.c.toFixed(2)}`);
                hSlider.setAttribute('aria-label', `${colorName} ${groupDisplayName} hue: ${currentColor.h.toFixed(0)} degrees`);
            }

            console.log(`🔗 UNIFIED SYSTEM: All color names updated across entire interface`);
        }

        // ========== COLOR PALETTE ATOM MAP (DYNAMIC) - REDESIGNED ==========

        function initColorPaletteMap() {
            updateColorPaletteMap();
            updateAllColorNames(); // Initialize color names on startup
        }

        /**
         * REVOLUTIONARY Color Palette Map with:
         * - Component groups as MAIN labels (e.g., "SURFACE - CARD")
         * - Color names as SUBTITLES (e.g., "White")
         * - Expandable/collapsible CATEGORIES
         * - Math Vision (Diagnostic Lens) integration
         */
        function updateColorPaletteMap() {
            const paletteGrid = document.getElementById('palette-grid');
            if (!paletteGrid) return;

            // ========== SCAN FOR COLOR-COMPONENT PAIRS (TOTALITY APPROACH) ==========

            const allWithColorGroup = document.querySelectorAll('[data-color-group]');
            const pairMap = new Map();

            allWithColorGroup.forEach(el => {
                const colorGroup = el.dataset.colorGroup;
                const componentType = el.classList[0] || el.tagName.toLowerCase();
                const pairKey = `${colorGroup}|${componentType}`;

                if (!pairMap.has(pairKey)) {
                    pairMap.set(pairKey, {
                        colorGroup: colorGroup,
                        componentType: componentType,
                        count: 0,
                        elements: []
                    });
                }

                const pair = pairMap.get(pairKey);
                pair.count++;
                pair.elements.push(el);
            });

            // Convert to array and apply STANDARD ORDERING
            let pairs = Array.from(pairMap.entries()).map(([key, value]) => value);
            pairs = sortPairsByStandardOrder(pairs);

            const violationsByGroup = globalColorValidator.getViolationsByGroup();

            // ========== GROUP PAIRS INTO CATEGORIES ==========
            const categories = {
                'SURFACE': { label: 'Surface Components', pairs: [] },
                'PRIMARY': { label: 'Primary Actions', pairs: [] },
                'SECONDARY': { label: 'Secondary Actions', pairs: [] },
                'ACCENT': { label: 'Accent Elements', pairs: [] },
                'TEXT': { label: 'Text Elements', pairs: [] },
                'BACKGROUND': { label: 'Backgrounds', pairs: [] },
                'OTHER': { label: 'Other Components', pairs: [] }
            };

            // Categorize pairs
            pairs.forEach(pair => {
                const group = pair.colorGroup.toUpperCase();
                if (group.includes('SURFACE') || group.includes('CARD') || group.includes('PANEL')) {
                    categories.SURFACE.pairs.push(pair);
                } else if (group.includes('PRIMARY') || group.includes('BTN-PRIMARY')) {
                    categories.PRIMARY.pairs.push(pair);
                } else if (group.includes('SECONDARY') || group.includes('BTN-SECONDARY')) {
                    categories.SECONDARY.pairs.push(pair);
                } else if (group.includes('ACCENT') || group.includes('HIGHLIGHT')) {
                    categories.ACCENT.pairs.push(pair);
                } else if (group.includes('TEXT') || group.includes('HEADING')) {
                    categories.TEXT.pairs.push(pair);
                } else if (group.includes('BACKGROUND') || group.includes('BG')) {
                    categories.BACKGROUND.pairs.push(pair);
                } else {
                    categories.OTHER.pairs.push(pair);
                }
            });

            // Clear existing
            paletteGrid.innerHTML = '';
            paletteGrid.style.cssText = 'display: flex; flex-direction: column; gap: 4px; padding: 8px;';

            // Create category sections
            Object.entries(categories).forEach(([categoryKey, category]) => {
                if (category.pairs.length === 0) return; // Skip empty categories

                // CATEGORY HEADER (clickable to expand/collapse)
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                categoryHeader.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 6px 0px;
                    background: transparent;
                    border: none;
                    cursor: pointer;
                    user-select: none;
                    transition: opacity 200ms ease;
                    margin-top: ${categoryKey === 'SURFACE' ? '0' : '12px'};
                `;
                categoryHeader.dataset.category = categoryKey;
                categoryHeader.dataset.expanded = 'true'; // Start expanded

                // Expand/Collapse Icon
                const expandIcon = document.createElement('span');
                expandIcon.style.cssText = `
                    font-size: 12px;
                    transition: transform 200ms ease;
                    transform: rotate(90deg);
                `;
                expandIcon.textContent = '▶';
                categoryHeader.appendChild(expandIcon);

                // Category Label
                const categoryLabel = document.createElement('span');
                categoryLabel.style.cssText = `
                    flex: 1;
                    font-size: 10px;
                    font-weight: 600;
                    color: var(--scaffold-text);
                    text-transform: uppercase;
                    letter-spacing: 0.8px;
                    opacity: 0.7;
                `;
                categoryLabel.textContent = category.label;
                categoryHeader.appendChild(categoryLabel);

                // Pair Count Badge
                const countBadge = document.createElement('span');
                countBadge.style.cssText = `
                    padding: 0;
                    background: transparent;
                    border: none;
                    font-size: 9px;
                    font-weight: 500;
                    color: var(--scaffold-text-muted);
                    opacity: 0.6;
                `;
                countBadge.textContent = `(${category.pairs.length})`;
                categoryHeader.appendChild(countBadge);

                paletteGrid.appendChild(categoryHeader);

                // CATEGORY CONTENT (color-group pairs)
                const categoryContent = document.createElement('div');
                categoryContent.className = 'category-content';
                categoryContent.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 2px;
                    padding-left: 20px;
                    margin-bottom: 8px;
                    overflow: hidden;
                    transition: max-height 300ms ease, opacity 200ms ease;
                `;
                categoryContent.dataset.category = categoryKey;

                // Add pairs to category
                category.pairs.forEach(({ colorGroup, componentType, count, elements }) => {
                    const color = colorPalette[currentMode][colorGroup] || { l: 0.5, c: 0.1, h: 0 };
                    const colorStr = `oklch(${color.l} ${color.c} ${color.h})`;
                    const colorName = getClosestColorName(color);
                    const groupDisplayName = getGroupDisplayName(colorGroup);

                    // ROW CONTAINER
                    const row = document.createElement('div');
                    row.className = 'palette-row' + (colorGroup === currentGroup ? ' active' : '');
                    row.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        padding: 4px 0px;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        transition: opacity 200ms ease, transform 200ms cubic-bezier(0.4, 0, 0.2, 1);
                        opacity: ${colorGroup === currentGroup ? '1' : '0.85'};
                    `;
                    row.dataset.group = colorGroup;
                    row.dataset.componentType = componentType;

                    // SINGLE COLOR CIRCLE
                    const circle = document.createElement('div');
                    circle.style.cssText = `
                        flex-shrink: 0;
                        width: 16px;
                        height: 16px;
                        background: ${colorStr};
                        border: none;
                        border-radius: 50%;
                        box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
                    `;
                    row.appendChild(circle);

                    // COMPONENT TYPE (without category redundancy)
                    const componentLabel = document.createElement('div');
                    componentLabel.style.cssText = `
                        flex: 0 0 auto;
                        font-size: 11px;
                        font-weight: 600;
                        color: var(--scaffold-text);
                        text-transform: uppercase;
                        letter-spacing: 0.3px;
                        min-width: 60px;
                    `;
                    componentLabel.textContent = componentType;
                    row.appendChild(componentLabel);

                    // COLOR NAME
                    const colorLabel = document.createElement('div');
                    colorLabel.style.cssText = `
                        flex: 1;
                        font-size: 11px;
                        font-weight: 400;
                        color: var(--scaffold-text-muted);
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    `;
                    colorLabel.textContent = colorName;
                    row.appendChild(colorLabel);

                    // TOTAL COUNT BADGE (neutral styling)
                    const countBadge = document.createElement('div');
                    countBadge.style.cssText = `
                        flex-shrink: 0;
                        padding: 0;
                        font-size: 10px;
                        font-weight: 400;
                        color: var(--scaffold-text-muted);
                        background: transparent;
                        border: none;
                        opacity: 0.5;
                    `;
                    countBadge.textContent = `[${count}]`;
                    row.appendChild(countBadge);

                    // VALIDATION INDICATOR
                    if (violationsByGroup[colorGroup]) {
                        const v = violationsByGroup[colorGroup];
                        let indicatorColor = '';
                        if (v.critical > 0) indicatorColor = 'oklch(0.60 0.18 25)';
                        else if (v.high > 0) indicatorColor = 'oklch(0.60 0.18 35)';
                        else if (v.medium > 0) indicatorColor = 'oklch(0.70 0.15 70)';
                        else if (v.low > 0) indicatorColor = 'oklch(0.50 0.15 230)';

                        if (indicatorColor) {
                            const indicator = document.createElement('div');
                            indicator.style.cssText = `
                                flex-shrink: 0;
                                width: 8px;
                                height: 8px;
                                background: ${indicatorColor};
                                border-radius: 50%;
                                border: 1px solid rgba(255,255,255,0.3);
                                margin-left: 6px;
                            `;
                            indicator.title = 'Has validation violations';
                            row.appendChild(indicator);
                        }
                    }

                    // HOVER EFFECTS
                    row.addEventListener('mouseenter', () => {
                        row.style.opacity = '1';
                        row.style.transform = 'translateX(2px)';
                    });
                    row.addEventListener('mouseleave', () => {
                        row.style.opacity = colorGroup === currentGroup ? '1' : '0.85';
                        row.style.transform = 'translateX(0)';
                    });

                    // CLICK INTERACTIONS
                    row.addEventListener('click', (e) => {
                        if (e.shiftKey) {
                            // Shift+Click = Navigate to first instance
                            if (elements[0]) {
                                elements[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                                elements[0].classList.add('component-highlight');
                                setTimeout(() => {
                                    elements[0].classList.remove('component-highlight');
                                }, 250);
                            }
                        } else {
                            // Regular Click = Select for Central Control + highlight all
                            selectColorForCentralControl(colorGroup, color);

                            elements.forEach((el, idx) => {
                                setTimeout(() => {
                                    el.classList.add('component-highlight');
                                    setTimeout(() => {
                                        el.classList.remove('component-highlight');
                                    }, 250);
                                }, idx * 50);
                            });

                            // Update active state
                            document.querySelectorAll('.palette-row').forEach(r => r.classList.remove('active'));
                            row.classList.add('active');
                        }
                    });

                    // TOOLTIP
                    let tooltip = `${groupDisplayName} - ${componentType.toUpperCase()}\n${colorName}\n${count}× instances\n${colorStr}\n\n🔬 Click Math Vision to analyze`;
                    if (violationsByGroup[colorGroup]) {
                        const v = violationsByGroup[colorGroup];
                        tooltip += `\n\n⚠️ VIOLATIONS:`;
                        if (v.critical > 0) tooltip += `\n🔴 ${v.critical} Critical`;
                        if (v.high > 0) tooltip += `\n🟠 ${v.high} High`;
                        if (v.medium > 0) tooltip += `\n🟡 ${v.medium} Medium`;
                        if (v.low > 0) tooltip += `\n🔵 ${v.low} Low`;
                    }
                    row.title = tooltip;

                    // Add row to category content
                    categoryContent.appendChild(row);
                });

                // Add category content to grid
                paletteGrid.appendChild(categoryContent);

                // ========== EXPAND/COLLAPSE INTERACTION ==========
                categoryHeader.addEventListener('click', () => {
                    const isExpanded = categoryHeader.dataset.expanded === 'true';
                    const newState = !isExpanded;

                    categoryHeader.dataset.expanded = newState;

                    // Animate icon
                    expandIcon.style.transform = newState ? 'rotate(90deg)' : 'rotate(0deg)';

                    // Animate content
                    if (newState) {
                        categoryContent.style.maxHeight = categoryContent.scrollHeight + 'px';
                        categoryContent.style.opacity = '1';
                    } else {
                        categoryContent.style.maxHeight = '0';
                        categoryContent.style.opacity = '0';
                    }

                    // Update header appearance
                    categoryHeader.style.background = newState ? 'var(--scaffold-bg)' : 'var(--scaffold-bg-elevated)';
                });

                // Initialize expanded state
                categoryContent.style.maxHeight = categoryContent.scrollHeight + 'px';
                categoryContent.style.opacity = '1';
            });

            const categoryCount = Object.values(categories).filter(c => c.pairs.length > 0).length;
            console.log(`🎨 REVOLUTIONARY Color Palette Map:`);
            console.log(`   📦 ${categoryCount} Categories with ${pairs.length} COLOR-COMPONENT PAIRS`);
            console.log(`   🔬 Math Vision (Diagnostic Lens) integrated on each row`);
            console.log(`   📂 Expandable/Collapsible categories for organized navigation`);
            console.log(`   🎯 Component groups as MAIN labels, color names as subtitles`);
        }

        // ========== CENTRAL CONTROL SYSTEM ==========

        let centralControlState = {
            selectedGroup: 'primary',
            selectedParam: 'l', // 'l', 'c', or 'h'
            isAdjusting: false
        };

        function selectColorForCentralControl(groupName, color) {
            console.log(`🎯 Selected ${groupName} for Central Control`);

            centralControlState.selectedGroup = groupName;

            // Update visual selection on atoms
            document.querySelectorAll('.palette-atom').forEach(atom => {
                if (atom.dataset.group === groupName) {
                    atom.classList.add('selected-for-control');
                } else {
                    atom.classList.remove('selected-for-control');
                }
            });

            // Update Central Control Panel
            updateCentralControlDisplay(groupName, color);

            // Select this group in sidebar too
            selectColorGroup(groupName);
        }

        /**
         * INTEGRATED: Update Central Control Display with color names
         */
        function updateCentralControlDisplay(groupName, color) {
            // Update color preview
            const preview = document.getElementById('central-control-color-preview');
            if (preview) {
                preview.style.background = `oklch(${color.l} ${color.c} ${color.h})`;
            }

            // ========== INTEGRATED: Color Name + Group Name ==========
            const colorName = getClosestColorName(color);
            const groupDisplayName = getGroupDisplayName(groupName);

            const nameEl = document.getElementById('central-control-color-name');
            if (nameEl) {
                nameEl.textContent = `${colorName} ${groupDisplayName}`;
            }

            // Update value with OKLCH
            const valueEl = document.getElementById('central-control-color-value');
            if (valueEl) {
                valueEl.textContent = `oklch(${color.l.toFixed(2)} ${color.c.toFixed(2)} ${color.h.toFixed(0)})`;
            }

            // Update slider based on selected parameter
            updateCentralSliderFromColor(color);
        }

        function updateCentralSliderFromColor(color) {
            const slider = document.getElementById('central-master-slider');
            const valueDisplay = document.getElementById('central-slider-value');
            const param = centralControlState.selectedParam;

            if (param === 'l') {
                slider.min = 0;
                slider.max = 100;
                slider.value = color.l * 100;
                slider.step = 1;
                valueDisplay.textContent = color.l.toFixed(2);
            } else if (param === 'c') {
                slider.min = 0;
                slider.max = 37;
                slider.value = color.c * 100;
                slider.step = 1;
                valueDisplay.textContent = color.c.toFixed(2);
            } else if (param === 'h') {
                slider.min = 0;
                slider.max = 360;
                slider.value = color.h;
                slider.step = 1;
                valueDisplay.textContent = color.h.toFixed(0);
            }
        }

        function initCentralControlSystem() {
            // Parameter Selector (REVOLVER)
            const paramButtons = document.querySelectorAll('.central-param-btn');
            paramButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const param = btn.dataset.param;

                    // Update active state (REVOLVER SPIN!)
                    paramButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update selected parameter
                    centralControlState.selectedParam = param;

                    // Update slider range and value for new parameter
                    const group = centralControlState.selectedGroup;
                    const color = colorPalette[currentMode][group];
                    updateCentralSliderFromColor(color);

                    // 🎯 Update 3D slice visualization
                    update3DSliceFromCentralControl();

                    console.log(`🔫 REVOLVER SPUN to ${param.toUpperCase()} → 3D Slice Updated`);
                });
            });

            // Master Slider
            const masterSlider = document.getElementById('central-master-slider');
            const valueDisplay = document.getElementById('central-slider-value');

            if (masterSlider) {
                masterSlider.addEventListener('input', () => {
                    const group = centralControlState.selectedGroup;
                    const param = centralControlState.selectedParam;
                    const rawValue = parseFloat(masterSlider.value);

                    // Convert raw value to OKLCH scale
                    let value;
                    if (param === 'l') {
                        value = rawValue / 100;
                        valueDisplay.textContent = value.toFixed(2);
                    } else if (param === 'c') {
                        value = rawValue / 100;
                        valueDisplay.textContent = value.toFixed(2);
                    } else if (param === 'h') {
                        value = rawValue;
                        valueDisplay.textContent = value.toFixed(0);
                    }

                    // Update the selected color
                    centralControlState.isAdjusting = true;
                    updateColorParameter(group, param, value);
                    centralControlState.isAdjusting = false;

                    // 🎯 Update 3D slice visualization in real-time
                    update3DSliceFromCentralControl();
                });
            }

            // Initialize with primary color
            const primaryColor = colorPalette[currentMode]['primary'];
            selectColorForCentralControl('primary', primaryColor);

            // 🎯 Initialize 3D Slice Visualizer
            init3DSliceVisualizer();
        }

        // ========== 🎯 3D OKLCH SLICE VISUALIZER SYSTEM ==========

        let sliceVisualizer = null;

        async function init3DSliceVisualizer() {
            const container = document.getElementById('oklch-3d-slice-viewer');
            if (!container) return;

            // Import Three.js
            const THREE = await import('three');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = null; // Transparent

            const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2, 2, 3);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.innerHTML = ''; // Clear placeholder
            container.appendChild(renderer.domElement);

            // Orbit controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Color space volume (OKLCH cylinder)
            const colorVolume = new THREE.Group();
            scene.add(colorVolume);

            // Create the OKLCH color space representation
            // Cylinder: height = Lightness, radius = Chroma, angle = Hue
            function createColorSpace() {
                const geometry = new THREE.CylinderGeometry(0.37, 0.37, 1, 64, 20, true);
                const material = new THREE.MeshPhongMaterial({
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                    vertexColors: true
                });

                const colors = [];
                const positions = geometry.attributes.position;

                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);

                    // Convert cylinder coords to OKLCH
                    const l = (y + 0.5); // Map -0.5 to 0.5 → 0 to 1
                    const c = Math.sqrt(x * x + z * z);
                    const h = (Math.atan2(z, x) * 180 / Math.PI + 360) % 360;

                    // Convert OKLCH to RGB for vertex colors
                    const rgb = oklchToRgb(l, c, h);
                    colors.push(rgb.r / 255, rgb.g / 255, rgb.b / 255);
                }

                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const mesh = new THREE.Mesh(geometry, material);
                return mesh;
            }

            const colorSpace = createColorSpace();
            colorVolume.add(colorSpace);

            // Slice plane (initially hidden)
            const slicePlaneGeometry = new THREE.PlaneGeometry(1, 1, 32, 32);
            const slicePlaneMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide,
                vertexColors: true
            });
            const slicePlane = new THREE.Mesh(slicePlaneGeometry, slicePlaneMaterial);
            colorVolume.add(slicePlane);

            // Update slice visualization
            function updateSlice(param, value) {
                // Update slice info display
                const sliceInfo = document.getElementById('current-slice-info');
                if (sliceInfo) {
                    if (param === 'l') {
                        sliceInfo.textContent = `L = ${value.toFixed(2)} (Lightness)`;
                    } else if (param === 'c') {
                        sliceInfo.textContent = `C = ${value.toFixed(2)} (Chroma)`;
                    } else if (param === 'h') {
                        sliceInfo.textContent = `H = ${value.toFixed(0)}° (Hue)`;
                    }
                }

                // Update color space opacity (rest of space becomes 50% transparent)
                colorSpace.material.opacity = 0.3;

                // Update slice plane
                slicePlane.visible = true;

                if (param === 'l') {
                    // Lightness slice: horizontal plane
                    slicePlane.rotation.set(0, 0, 0);
                    slicePlane.position.set(0, value - 0.5, 0);
                    slicePlane.scale.set(0.74, 0.74, 1); // Diameter of cylinder

                    // Color the plane with the slice colors
                    const colors = [];
                    const positions = slicePlaneGeometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const z = positions.getY(i); // Y in 2D becomes Z in 3D

                        const c = Math.sqrt(x * x + z * z) * 0.37;
                        const h = (Math.atan2(z, x) * 180 / Math.PI + 360) % 360;

                        const rgb = oklchToRgb(value, c, h);
                        colors.push(rgb.r / 255, rgb.g / 255, rgb.b / 255);
                    }
                    slicePlaneGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                } else if (param === 'c') {
                    // Chroma slice: vertical cylinder at radius
                    slicePlane.visible = false; // For now, hide chroma slice (complex to visualize)

                } else if (param === 'h') {
                    // Hue slice: vertical plane through center
                    slicePlane.rotation.set(0, value * Math.PI / 180, 0);
                    slicePlane.position.set(0, 0, 0);
                    slicePlane.scale.set(0.74, 1, 1);

                    // Color the plane with the hue slice
                    const colors = [];
                    const positions = slicePlaneGeometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i); // Chroma
                        const y = positions.getY(i); // Lightness

                        const c = Math.abs(x) * 0.37;
                        const l = (y + 0.5);

                        const rgb = oklchToRgb(l, c, value);
                        colors.push(rgb.r / 255, rgb.g / 255, rgb.b / 255);
                    }
                    slicePlaneGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                }

                slicePlaneGeometry.attributes.color.needsUpdate = true;
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            window.addEventListener('resize', onWindowResize);

            // Store reference for external control
            sliceVisualizer = {
                updateSlice,
                scene,
                camera,
                renderer,
                controls
            };

            // Initial slice (Lightness at 0.60)
            updateSlice('l', 0.60);
        }

        // Hook into central control system to update 3D visualization
        function update3DSliceFromCentralControl() {
            if (!sliceVisualizer) return;

            const param = centralControlState.selectedParam;
            const group = centralControlState.selectedGroup;
            const color = colorPalette[currentMode][group];

            let value;
            if (param === 'l') {
                value = color.l;
            } else if (param === 'c') {
                value = color.c;
            } else if (param === 'h') {
                value = color.h;
            }

            sliceVisualizer.updateSlice(param, value);
        }

        // ========== COUNTER-WEIGHT TRAJECTORY FORMULA SYSTEM (42-DIMENSIONAL HYPER-SPACE) ==========

        const counterWeightSystem = {
            // 🎭 REACTIVE HARMONY ENGINE: THE DANCE OF ATOMS
            // Every atom responds proportionally to maintain beauty, proportion, and harmony

            // FORMULA TYPES (Mathematical Relationships)
            formulas: {
                identity: (sourceΔ) => sourceΔ,
                offset: (constantOffset) => (sourceΔ) => sourceΔ + constantOffset,
                scale: (factor) => (sourceΔ) => sourceΔ * factor,
                inverse: (factor = 0.5) => (sourceΔ) => -sourceΔ * factor,
                harmonic: (degrees) => (sourceΔ) => sourceΔ, // Hue shifts
                // NEW: Proportional preservation
                proportional: (ratio) => (sourceΔ) => sourceΔ * ratio,
                // NEW: Damped response (prevents over-adjustment)
                damped: (factor = 0.5) => (sourceΔ) => sourceΔ * factor * Math.exp(-Math.abs(sourceΔ)),
                // NEW: Contrast preservation
                contrastPreserve: (targetL) => (sourceΔ) => {
                    // If source gets brighter, make target darker (and vice versa)
                    const bg = colorPalette[currentMode].background;
                    const needsDarker = (targetL + sourceΔ) - bg.l < 0.15;
                    return needsDarker ? -Math.abs(sourceΔ) * 0.5 : sourceΔ * 0.3;
                }
            },

            // FAMILY GROUPS (Related color-component pairs)
            families: {
                "primary-interactions": ["primary|btn", "primary|badge", "primary|selectable"],
                "secondary-interactions": ["secondary|btn", "secondary|badge", "secondary|selectable"],
                "accent-interactions": ["accent|btn", "accent|badge", "accent|selectable"],
                "surface-containers": ["surface|card", "surface|input", "surface|selectable"],
                "all-buttons": ["primary|btn", "secondary|btn", "accent|btn"],
                "all-badges": ["primary|badge", "secondary|badge", "accent|badge"]
            },

            // TRAJECTORY RELATIONSHIPS (How pairs respond to each other)
            // Format: targetPair → { sourcePair → { param → formula } }
            trajectories: {
                // PRIMARY FAMILY
                "primary|badge": {
                    "primary|btn": {
                        l: (Δ) => Δ * 1.05, // Badges slightly lighter
                        c: (Δ) => Δ,         // Same chroma
                        h: (Δ) => Δ          // Same hue
                    }
                },
                "primary|selectable": {
                    "primary|btn": {
                        l: (Δ) => Δ * 0.95, // Slightly darker
                        c: (Δ) => Δ * 0.9,  // Less saturated
                        h: (Δ) => Δ
                    }
                },

                // SECONDARY responds to PRIMARY (maintain contrast)
                "secondary|btn": {
                    "primary|btn": {
                        l: (Δ) => -Δ * 0.3, // Inverse relationship for contrast
                        c: (Δ) => Δ * 0.8,
                        h: (Δ) => Δ + 30    // Slight hue shift (analogous)
                    }
                },
                "secondary|badge": {
                    "secondary|btn": {
                        l: (Δ) => Δ * 1.05,
                        c: (Δ) => Δ,
                        h: (Δ) => Δ
                    },
                    "primary|btn": {
                        l: (Δ) => -Δ * 0.25,
                        c: (Δ) => Δ * 0.7,
                        h: (Δ) => Δ + 30
                    }
                },

                // ACCENT responds to PRIMARY (triadic harmony)
                "accent|btn": {
                    "primary|btn": {
                        l: (Δ) => Δ * 1.1,  // Slightly brighter
                        c: (Δ) => Δ * 1.2,  // More vibrant
                        h: (Δ) => Δ         // Same hue (or could be +120 for triadic)
                    }
                },
                "accent|badge": {
                    "accent|btn": {
                        l: (Δ) => Δ * 1.05,
                        c: (Δ) => Δ,
                        h: (Δ) => Δ
                    },
                    "primary|btn": {
                        l: (Δ) => Δ * 1.08,
                        c: (Δ) => Δ * 1.15,
                        h: (Δ) => Δ
                    }
                },

                // SURFACE responds inversely to interactions (background adaptation)
                "surface|card": {
                    "primary|btn": {
                        l: (Δ) => -Δ * 0.1, // Subtle inverse
                        c: (Δ) => -Δ * 0.2,
                        h: (Δ) => Δ * 0.5   // Slight color influence
                    },
                    "secondary|btn": {
                        l: (Δ) => -Δ * 0.08,
                        c: (Δ) => -Δ * 0.15,
                        h: (Δ) => Δ * 0.5
                    }
                },
                "surface|input": {
                    "surface|card": {
                        l: (Δ) => Δ * 0.98, // Slightly different from cards
                        c: (Δ) => Δ,
                        h: (Δ) => Δ
                    }
                },

                // 🎭 UNIVERSAL HARMONY RULES - TEXT RESPONDS TO EVERYTHING
                "text|span": {
                    "background|div": {
                        // Text MUST maintain contrast with background
                        l: (Δ) => {
                            const bg = colorPalette[currentMode].background;
                            const text = colorPalette[currentMode].text;
                            // If background gets brighter, text gets darker (inverse)
                            // Magnitude preserves contrast ratio
                            return -Δ * 0.8;
                        },
                        c: (Δ) => -Δ * 0.5, // Less chroma when background changes
                        h: (Δ) => Δ * 0.3   // Slight hue influence
                    },
                    "surface|card": {
                        // Text subtly adapts to surface changes
                        l: (Δ) => -Δ * 0.4,
                        c: (Δ) => -Δ * 0.3,
                        h: (Δ) => Δ * 0.2
                    },
                    "primary|btn": {
                        // Text maintains hierarchy (primary shouldn't overpower text)
                        l: (Δ) => -Δ * 0.2,
                        c: (Δ) => Δ * 0.1, // Text can pick up slight color influence
                        h: (Δ) => 0         // Text hue stays neutral
                    }
                },

                // 🎭 BACKGROUND RESPONDS TO EVERYTHING (FOUNDATION LAYER)
                "background|div": {
                    "primary|btn": {
                        // Background subtly adapts to maintain contrast with primary
                        l: (Δ) => -Δ * 0.05, // Very subtle inverse
                        c: (Δ) => -Δ * 0.1,  // Reduce chroma slightly
                        h: (Δ) => Δ * 0.1    // Slight color temperature shift
                    },
                    "text|span": {
                        // Background ensures text remains readable
                        l: (Δ) => -Δ * 0.6, // Strong inverse relationship
                        c: (Δ) => -Δ * 0.8, // Background stays neutral
                        h: (Δ) => Δ * 0.2   // Can pick up slight hue influence
                    },
                    "surface|card": {
                        // Background and surface maintain separation
                        l: (Δ) => Δ * 0.5,  // Move together but maintain delta
                        c: (Δ) => Δ * 0.7,
                        h: (Δ) => Δ * 0.9   // Stay in harmony
                    }
                },

                // 🎭 CROSS-GROUP HARMONY PRESERVATION
                "primary|btn": {
                    "background|div": {
                        // Primary maintains contrast with background
                        l: (Δ) => -Δ * 0.3,
                        c: (Δ) => Δ * 0.2,  // Primary can be more saturated
                        h: (Δ) => Δ * 0.8   // Preserve hue relationship
                    },
                    "text|span": {
                        // Primary ensures it doesn't conflict with text
                        l: (Δ) => Δ * 0.4,  // Different lightness from text
                        c: (Δ) => Δ * 1.2,  // Primary can be more vibrant
                        h: (Δ) => Δ * 0.5   // Some hue independence
                    }
                },

                "secondary|btn": {
                    "background|div": {
                        l: (Δ) => -Δ * 0.25,
                        c: (Δ) => Δ * 0.15,
                        h: (Δ) => Δ * 0.7
                    },
                    "text|span": {
                        l: (Δ) => Δ * 0.35,
                        c: (Δ) => Δ * 1.0,
                        h: (Δ) => Δ * 0.4
                    }
                },

                "accent|btn": {
                    "background|div": {
                        l: (Δ) => -Δ * 0.2,
                        c: (Δ) => Δ * 0.25,
                        h: (Δ) => Δ * 0.6
                    },
                    "primary|btn": {
                        // Accent maintains distinction from primary
                        l: (Δ) => Δ * 0.15, // Slightly different lightness
                        c: (Δ) => Δ * 0.9,  // Similar saturation
                        h: (Δ) => Δ + 15    // Hue shift for distinction (analogous harmony)
                    },
                    "secondary|btn": {
                        // Accent and secondary maintain hierarchy
                        l: (Δ) => Δ * 0.2,
                        c: (Δ) => Δ * 1.1,  // Accent more vibrant than secondary
                        h: (Δ) => Δ + 10
                    }
                },

                // 🎭 SURFACE COMPREHENSIVE ADAPTATION
                "surface|card": {
                    "background|div": {
                        // Surface maintains elevation distinction from background
                        l: (Δ) => Δ * 0.8,  // Move together but maintain delta
                        c: (Δ) => Δ * 0.9,  // Similar but not identical
                        h: (Δ) => Δ * 0.95  // Harmonious hue relationship
                    },
                    "primary|btn": {
                        // Surface ensures primary stands out
                        l: (Δ) => -Δ * 0.1, // Subtle inverse
                        c: (Δ) => -Δ * 0.2, // Stay neutral
                        h: (Δ) => Δ * 0.5   // Can adopt slight color temperature
                    },
                    "text|span": {
                        // Surface ensures text readability
                        l: (Δ) => -Δ * 0.5,
                        c: (Δ) => -Δ * 0.7, // Stay very neutral
                        h: (Δ) => Δ * 0.3
                    }
                }
            },

            // ========== 🎨 GOLDEN CONSTRAINTS OF UI BEAUTY ==========
            // These formulas GUARANTEE beautiful, professional UI by enforcing
            // the mathematical principles of visual harmony

            validateColor(color, group) {
                const validated = { ...color };
                const bg = colorPalette[currentMode].background;
                const isLightMode = bg.l > 0.5;

                console.log(`%c🎨 BEAUTY VALIDATION: ${group}`, 'background: #4a2a1a; color: #ffcc99; font-weight: bold; padding: 2px 6px; border-radius: 3px;');

                // ========== FORMULA SET 1: CONTRAST PRESERVATION (MANDATORY) ==========
                // "Font x Surroundings must have LARGE DISTANCE in OKLCH space"

                if (group === 'text') {
                    // TEXT MUST MAINTAIN MINIMUM 4.5:1 CONTRAST (WCAG AA)
                    const targetContrast = 4.5;
                    let iterations = 0;

                    while (iterations < 20) {
                        const contrast = calculateContrastFromObjects(validated, bg);
                        if (contrast >= targetContrast) break;

                        // Adjust lightness to increase contrast
                        if (isLightMode) {
                            validated.l -= 0.05; // Darker text in light mode
                        } else {
                            validated.l += 0.05; // Lighter text in dark mode
                        }
                        iterations++;
                    }

                    // ENFORCE: Text must be neutral (low chroma)
                    validated.c = Math.min(0.02, validated.c);
                    console.log(`   ✓ Text contrast enforced: ${calculateContrastFromObjects(validated, bg).toFixed(1)}:1`);
                }

                // ========== FORMULA SET 2: SURFACE LIGHTNESS COHERENCE ==========
                // "Surfaces must not have too different lightness from theme mode"

                if (group === 'surface' || group === 'background') {
                    if (isLightMode) {
                        // LIGHT MODE: Surfaces MUST be high-lightness [0.85, 1.0]
                        validated.l = Math.max(0.85, Math.min(1.0, validated.l));
                        console.log(`   ✓ Light mode surface: L clamped to [0.85, 1.0] → ${validated.l.toFixed(2)}`);
                    } else {
                        // DARK MODE: Surfaces MUST be low-lightness [0.0, 0.20]
                        validated.l = Math.max(0.0, Math.min(0.20, validated.l));
                        console.log(`   ✓ Dark mode surface: L clamped to [0.0, 0.20] → ${validated.l.toFixed(2)}`);
                    }

                    // ENFORCE: Surfaces must be nearly neutral
                    validated.c = Math.min(0.03, validated.c);
                    console.log(`   ✓ Surface chroma limited to 0.03 → ${validated.c.toFixed(3)}`);
                }

                // ========== FORMULA SET 3: BACKGROUND SAFE ZONE ==========
                // "Limited region of OKLCH space good for backgrounds"
                // "Low chroma + (Low L OR High L) = SAFE"

                if (group === 'background') {
                    // ENFORCE: Background MUST be low chroma
                    validated.c = Math.min(0.02, validated.c);

                    // ENFORCE: Background must be either very light OR very dark
                    // Avoid mid-lightness (0.3-0.7) = muddy, ugly
                    if (validated.l > 0.3 && validated.l < 0.7) {
                        if (isLightMode) {
                            validated.l = Math.max(0.9, validated.l); // Push to light
                        } else {
                            validated.l = Math.min(0.15, validated.l); // Push to dark
                        }
                        console.log(`   ⚠️ Background mid-lightness avoided → ${validated.l.toFixed(2)}`);
                    }

                    console.log(`   ✓ Background safe zone: L=${validated.l.toFixed(2)}, C=${validated.c.toFixed(3)}`);
                }

                // ========== FORMULA SET 4: DISCRETE BUTTON COLORS ==========
                // "Buttons must have color but VERY DISCRETE"
                // "Avoid strong saturated colors on 2D surfaces"

                if (group === 'primary' || group === 'secondary' || group === 'accent') {
                    // MAXIMUM CHROMA FOR BUTTONS (Professional, not garish)
                    const maxButtonChroma = 0.15; // VERY DISCRETE

                    if (validated.c > maxButtonChroma) {
                        validated.c = maxButtonChroma;
                        console.log(`   ⚠️ Button chroma limited to ${maxButtonChroma} (discrete) → ${validated.c.toFixed(3)}`);
                    }

                    // ENFORCE: Buttons maintain contrast with background (3:1 minimum)
                    const targetContrast = 3.0;
                    let iterations = 0;

                    while (iterations < 15) {
                        const contrast = calculateContrastFromObjects(validated, bg);
                        if (contrast >= targetContrast) break;

                        // Adjust lightness for contrast
                        if (isLightMode) {
                            validated.l -= 0.03;
                        } else {
                            validated.l += 0.03;
                        }
                        iterations++;
                    }

                    console.log(`   ✓ Button contrast: ${calculateContrastFromObjects(validated, bg).toFixed(1)}:1`);
                }

                // ========== FORMULA SET 5: FORBIDDEN ZONES ==========
                // "Mid-lightness + High-chroma = FORBIDDEN (cheap looking)"

                const isMidLightness = validated.l > 0.3 && validated.l < 0.7;
                const isHighChroma = validated.c > 0.15;

                if (isMidLightness && isHighChroma) {
                    // FORBIDDEN ZONE DETECTED - Auto-correct
                    if (isLightMode) {
                        // Push to high-lightness + reduce chroma
                        validated.l = Math.max(0.75, validated.l);
                        validated.c = Math.min(0.12, validated.c);
                    } else {
                        // Push to low-lightness + reduce chroma
                        validated.l = Math.min(0.25, validated.l);
                        validated.c = Math.min(0.12, validated.c);
                    }
                    console.log(`   🚫 FORBIDDEN ZONE avoided: Mid-L + High-C → L=${validated.l.toFixed(2)}, C=${validated.c.toFixed(3)}`);
                }

                // ========== FORMULA SET 6: ABSOLUTE BOUNDS ==========
                validated.l = Math.max(0, Math.min(1, validated.l));
                validated.c = Math.max(0, Math.min(0.37, validated.c));
                validated.h = ((validated.h % 360) + 360) % 360;

                console.log(`   ✅ BEAUTY VALIDATED: ${group} final → L=${validated.l.toFixed(2)} C=${validated.c.toFixed(3)} H=${validated.h.toFixed(0)}°`);

                return validated;
            },

            // CORE TRAJECTORY COMPUTATION ENGINE
            /**
             * INTEGRATED: Apply trajectory with color names in console logs
             */
            applyTrajectory(sourceGroup, sourceParam, oldValue, newValue) {
                const sourceΔ = newValue - oldValue;
                const adjustments = [];

                // Get all color-component pairs from the UI
                const allPairs = this.getAllActivePairs();

                // Find all source pairs (all pairs with the source color group)
                const sourcePairs = allPairs.filter(pair => pair.startsWith(sourceGroup + '|'));

                // ========== INTEGRATED: Color name in console log ==========
                const sourceColor = colorPalette[currentMode][sourceGroup];
                const sourceColorName = getClosestColorName(sourceColor);
                const sourceGroupName = getGroupDisplayName(sourceGroup);
                console.log(`🎯 Counter-Weight Trajectory: ${sourceColorName} ${sourceGroupName}.${sourceParam} → ${oldValue.toFixed(2)} to ${newValue.toFixed(2)} (${sourcePairs.length} source pairs)`);

                // For each source pair, check if other pairs have trajectory formulas responding to it
                sourcePairs.forEach(sourcePairKey => {
                    // For each target pair, check if it has a trajectory formula for this source pair
                    allPairs.forEach(targetPairKey => {
                        if (targetPairKey === sourcePairKey) return; // Skip self

                        const [targetColor, targetComponent] = targetPairKey.split('|');

                        // Check if there's a trajectory formula
                        const pairTrajectories = this.trajectories[targetPairKey];
                        if (!pairTrajectories) return;

                        const sourceTrajectories = pairTrajectories[sourcePairKey];
                        if (!sourceTrajectories) return;

                        const formula = sourceTrajectories[sourceParam];
                        if (!formula) return;

                        // Compute adjustment using formula
                        const targetΔ = formula(sourceΔ);

                        if (Math.abs(targetΔ) > 0.001) { // Only if significant change
                            // Check if we already have an adjustment for this target
                            const existing = adjustments.find(a => a.pairKey === targetPairKey && a.param === sourceParam);
                            if (!existing) {
                                adjustments.push({
                                    pairKey: targetPairKey,
                                    colorGroup: targetColor,
                                    param: sourceParam,
                                    delta: targetΔ,
                                    sourcePair: sourcePairKey
                                });
                            }
                        }
                    });
                });

                // 🎭 THE DANCE OF ATOMS - Enhanced visual feedback
                if (adjustments.length > 0) {
                    console.log(`%c🎭 THE DANCE OF ATOMS BEGINS ✨`, 'background: #2a1a4a; color: #e0b3ff; font-weight: bold; padding: 4px 8px; border-radius: 4px;');
                    console.log(`   🎯 ${sourceColorName} ${sourceGroupName} leads the dance`);
                    console.log(`   💃 ${adjustments.length} atoms respond harmoniously:`);

                    adjustments.forEach(adj => {
                        const targetColor = colorPalette[currentMode][adj.colorGroup];
                        const targetColorName = getClosestColorName(targetColor);
                        const targetGroupName = getGroupDisplayName(adj.colorGroup);
                        const sign = adj.delta > 0 ? '+' : '';
                        const emoji = adj.param === 'l' ? '💡' : adj.param === 'c' ? '🎨' : '🌈';

                        console.log(`      ${emoji} ${targetColorName} ${targetGroupName}: ${adj.param.toUpperCase()} ${sign}${adj.delta.toFixed(3)}`);
                    });

                    console.log(`%c⚖️ HARMONY PRESERVED - Theme remains beautiful`, 'background: #1a4a2a; color: #b3ffcc; font-weight: bold; padding: 4px 8px; border-radius: 4px;');

                    // Show floating notification
                    showNotification(`🎭 ${adjustments.length} atoms danced in harmony`, 1500);
                } else {
                    console.log(`   💤 No trajectory adjustments needed`);
                }

                return adjustments;
            },

            // GET ALL ACTIVE COLOR-COMPONENT PAIRS
            getAllActivePairs() {
                const allWithColorGroup = document.querySelectorAll('[data-color-group]');
                const pairSet = new Set();

                allWithColorGroup.forEach(el => {
                    const colorGroup = el.dataset.colorGroup;
                    const componentType = el.classList[0] || el.tagName.toLowerCase();
                    pairSet.add(`${colorGroup}|${componentType}`);
                });

                return Array.from(pairSet);
            },

            /**
             * INTEGRATED: Apply adjustments with color names in console logs
             */
            applyAdjustments(adjustments) {
                adjustments.forEach(adj => {
                    const currentColor = colorPalette[currentMode][adj.colorGroup];
                    if (!currentColor) return;

                    const newColor = { ...currentColor };
                    newColor[adj.param] += adj.delta;

                    // Validate constraints
                    const validated = this.validateColor(newColor, adj.colorGroup);

                    // Apply to palette
                    colorPalette[currentMode][adj.colorGroup] = validated;

                    // Apply to CSS
                    const colorStr = `oklch(${validated.l.toFixed(2)} ${validated.c.toFixed(2)} ${validated.h})`;
                    document.documentElement.style.setProperty(`--${adj.colorGroup}`, colorStr);

                    // ========== INTEGRATED: Color name in console log ==========
                    const adjustedColorName = getClosestColorName(validated);
                    const groupName = getGroupDisplayName(adj.colorGroup);
                    console.log(`  ↳ ${adjustedColorName} ${groupName}.${adj.param} adjusted by ${adj.delta.toFixed(3)}`);
                });

                // ========== INTEGRATED: Update all color names after trajectory adjustments ==========
                if (adjustments.length > 0) {
                    updateAllColorNames();
                }
            }
        };

        function updateColorParameter(group, param, value) {
            // Get current color and store old value for trajectory calculation
            const oldColor = { ...colorPalette[currentMode][group] };
            const oldValue = oldColor[param];
            const color = { ...oldColor };

            // Update the parameter
            if (param === 'l') {
                color.l = Math.max(0, Math.min(1, value));
            } else if (param === 'c') {
                color.c = Math.max(0, Math.min(0.37, value));
            } else if (param === 'h') {
                color.h = ((value % 360) + 360) % 360; // Wrap hue
            }

            // Store in palette (source color)
            colorPalette[currentMode][group] = color;

            // ========== APPLY COUNTER-WEIGHT TRAJECTORY FORMULAS ==========
            // Compute trajectory adjustments for ALL related pairs
            const adjustments = counterWeightSystem.applyTrajectory(group, param, oldValue, color[param]);

            // Apply adjustments to other pairs
            if (adjustments.length > 0) {
                counterWeightSystem.applyAdjustments(adjustments);
            }

            // Apply to CSS
            const colorStr = `oklch(${color.l.toFixed(2)} ${color.c.toFixed(2)} ${color.h})`;
            document.documentElement.style.setProperty(`--${group}`, colorStr);

            // Update currentColor if this is the selected group
            if (group === currentGroup) {
                currentColor.l = color.l;
                currentColor.c = color.c;
                currentColor.h = color.h;

                // Update individual L/C/H sliders
                document.getElementById('current-l').value = color.l * 100;
                document.getElementById('current-c').value = color.c * 100;
                document.getElementById('current-h').value = color.h;
                document.getElementById('current-l-val').textContent = color.l.toFixed(2);
                document.getElementById('current-c-val').textContent = color.c.toFixed(2);
                document.getElementById('current-h-val').textContent = color.h.toFixed(0);

                // Update OKLCH code display
                updateOklchCodeDisplay(color.l, color.c, color.h);

                // Update 3D viewer
                if (window.updateColorPoint) {
                    window.updateColorPoint(color.l, color.c, color.h);
                }

                // Update 2D wheels
                if (window.drawHueWheel) window.drawHueWheel();
                if (window.drawChromaLightness) window.drawChromaLightness();
            }

            // Update Central Control Display
            updateCentralControlDisplay(group, color);

            // Update Color Palette Map (LIVE FEEDBACK!)
            updateColorPaletteMap();

            // Check counter-weight balance
            checkCounterWeightBalance();
        }

        function checkCounterWeightBalance() {
            const group = centralControlState.selectedGroup;
            const color = colorPalette[currentMode][group];

            // Calculate counter-weight adjustments needed
            const adjustments = completeUIRegistry.calculateCounterWeight(group, color);

            const statusEl = document.getElementById('counter-weight-status');
            if (statusEl) {
                if (adjustments.length === 0) {
                    statusEl.textContent = '⚖️ Counter-Weight: Balanced';
                    statusEl.style.color = 'oklch(0.60 0.18 145)';
                } else {
                    statusEl.textContent = `⚠️ ${adjustments.length} groups need adjustment`;
                    statusEl.style.color = 'oklch(0.60 0.18 35)';
                }
            }
        }

        function navigateToColorGroup(group) {
            // Find the component in the gallery that uses this color group
            const componentCards = document.querySelectorAll('[data-color-group="' + group + '"]');

            if (componentCards.length > 0) {
                const firstComponent = componentCards[0];

                // Scroll into view
                firstComponent.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Apply hue spin highlight animation
                firstComponent.classList.add('component-highlight');

                // Remove animation class after completion
                setTimeout(() => {
                    firstComponent.classList.remove('component-highlight');
                }, 250);
            }

            // Also select this color group in the sidebar
            selectColorGroup(group);
        }

        initCopyToClipboard();
        initSidebarResize(); // Initialize sidebar resize
        initColorPaletteMap(); // Initialize color palette map
        initCentralControlSystem(); // 🎯 CENTRAL SLIDE WITH REVOLVER (after all functions defined)
        updateAutoSyncStatus();
        updateSafeZone();

        // Initial selection
        selectColorGroup('primary');
    </script>
</body>
</html>
