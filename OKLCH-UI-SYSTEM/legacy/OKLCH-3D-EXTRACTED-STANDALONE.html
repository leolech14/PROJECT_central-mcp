<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OKLCH 3D Visualization - Extracted from Evil Martians</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: oklch(12% 0.01 250);
            color: oklch(95% 0.01 250);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas3d {
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: oklch(20% 0.01 250 / 0.9);
            border: 2px solid oklch(35% 0.02 250);
            border-radius: 16px;
            padding: 1.5rem;
            min-width: 300px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg,
                oklch(75% 0.15 0),
                oklch(75% 0.15 120),
                oklch(75% 0.15 240));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-group {
            margin-bottom: 1.2rem;
        }

        .control-label {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: oklch(30% 0.02 250);
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: oklch(75% 0.15 240);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: oklch(75% 0.15 240);
            cursor: pointer;
            border: none;
        }

        .value-display {
            font-family: 'SF Mono', monospace;
            font-size: 0.95rem;
            color: oklch(85% 0.02 250);
        }

        .color-preview {
            width: 100%;
            height: 60px;
            border-radius: 10px;
            border: 2px solid oklch(40% 0.02 250);
            margin-top: 1rem;
        }

        .info {
            font-size: 0.8rem;
            color: oklch(65% 0.02 250);
            margin-top: 1rem;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: oklch(75% 0.12 240);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas3d"></canvas>

        <div id="controls">
            <h1>üé® OKLCH 3D Space</h1>

            <div class="control-group">
                <div class="control-label">
                    <span>Lightness (L)</span>
                    <span class="value-display" id="valueL">50%</span>
                </div>
                <input type="range" class="slider" id="sliderL" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Chroma (C)</span>
                    <span class="value-display" id="valueC">0.15</span>
                </div>
                <input type="range" class="slider" id="sliderC" min="0" max="37" value="15">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Hue (H)</span>
                    <span class="value-display" id="valueH">240¬∞</span>
                </div>
                <input type="range" class="slider" id="sliderH" min="0" max="360" value="240">
            </div>

            <div class="color-preview" id="colorPreview"></div>

            <div class="info">
                üñ±Ô∏è <strong>Drag</strong> to rotate<br>
                üîç <strong>Scroll</strong> to zoom<br>
                ‚ö° Extracted from <strong>Evil Martians</strong>
            </div>
        </div>

        <div id="loading">Loading 3D Model...</div>
    </div>

    <!-- Three.js from CDN -->
    <script async src="https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js" type="module"></script>

    <!-- Main Script -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js';

        // Constants from config.js
        const L_MAX_COLOR = 1;
        const C_MAX = 0.37;

        // OKLCH to RGB conversion (from Culori)
        function oklchToRgb(l, c, h) {
            // 1. OKLCH ‚Üí OKLAB
            const hRad = (h * Math.PI) / 180;
            const a = c * Math.cos(hRad);
            const b = c * Math.sin(hRad);

            // 2. OKLAB ‚Üí Linear RGB
            const l_ = l + 0.3963377774 * a + 0.2158037573 * b;
            const m_ = l - 0.1055613458 * a - 0.0638541728 * b;
            const s_ = l - 0.0894841775 * a - 1.2914855480 * b;

            const lCube = l_ * l_ * l_;
            const mCube = m_ * m_ * m_;
            const sCube = s_ * s_ * s_;

            let r = +4.0767245293 * lCube - 3.3072168827 * mCube + 0.2307590544 * sCube;
            let g = -1.2681437731 * lCube + 2.6093323231 * mCube - 0.3411344290 * sCube;
            let b2 = -0.0041119885 * lCube - 0.7034763098 * mCube + 1.7068625689 * sCube;

            // 3. Gamma correction
            r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;
            g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;
            b2 = b2 > 0.0031308 ? 1.055 * Math.pow(b2, 1/2.4) - 0.055 : 12.92 * b2;

            return {
                r: Math.max(0, Math.min(1, r)),
                g: Math.max(0, Math.min(1, g)),
                b: Math.max(0, Math.min(1, b2))
            };
        }

        // Check if on gamut edge (from model.ts line 30)
        function onGamutEdge(r, g, b) {
            return r === 0 || g === 0 || b === 0 || r > 0.99 || g > 0.99 || b > 0.99;
        }

        // Generate model data (from model.ts line 34)
        function getModelData() {
            const coordinates = [];
            const colors = [];

            for (let x = 0; x <= 1; x += 0.01) {
                for (let y = 0; y <= 1; y += 0.01) {
                    for (let z = 0; z <= 1; z += 0.01) {
                        if (onGamutEdge(x, y, z)) {
                            // Convert RGB to OKLCH
                            // For simplicity, we'll sample the color space directly
                            colors.push(x, y, z);

                            // Map to cylindrical OKLCH space
                            // Approximate mapping for visualization
                            const l = (x + y + z) / 3;
                            const c = Math.sqrt((x-0.5)**2 + (y-0.5)**2) * 0.5;
                            const h = Math.atan2(y-0.5, x-0.5) * 180 / Math.PI;

                            coordinates.push(
                                new THREE.Vector3(l, c * 2, (h + 180) / 360)
                            );
                        }
                    }
                }
            }

            // Add bounds
            const bounds = [
                [0, 0, 0],
                [0, 0, 1],
                [1, 0, 0],
                [1, 1, 0],
                [1, 0, 1],
                [1, 0, 1],
                [1, 1, 1]
            ];
            for (let i of bounds) {
                coordinates.push(new THREE.Vector3(...i));
                colors.push(i[0], i[0], i[0]);
            }

            return [coordinates, colors];
        }

        // Initialize scene
        const canvas = document.getElementById('canvas3d');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            canvas,
            antialias: true
        });

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.set(0.79, 0, 0.79);
        camera.lookAt(new THREE.Vector3(0, 1, 0));

        // OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 0.9;
        controls.maxDistance = 3;

        // Generate mesh
        console.log('Generating OKLCH 3D model...');
        const [coordinates, colors] = getModelData();

        const geometry = new THREE.BufferGeometry().setFromPoints(coordinates);
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.center();

        // Use Delaunator for triangulation (simplified - using built-in for now)
        const indices = [];
        for (let i = 0; i < coordinates.length - 2; i += 3) {
            indices.push(i, i+1, i+2);
        }
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        const material = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            vertexColors: true,
            opacity: 0.8,
            transparent: true
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.translateY(0.3);
        scene.add(mesh);

        // Add ground plane
        const planeGeometry = new THREE.PlaneGeometry(1, 1, 20, 20);
        const planeColors = [];
        const positions = planeGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const gray = i / positions.count;
            planeColors.push(gray, gray, gray);
        }
        planeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(planeColors, 3));
        planeGeometry.translate(0, 0, -0.2);
        planeGeometry.rotateZ(Math.PI * 0.5);
        planeGeometry.rotateX(-Math.PI * 0.5);

        const planeMesh = new THREE.Mesh(planeGeometry, material);
        scene.add(planeMesh);

        // Add cursor sphere
        const cursorGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const cursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
        scene.add(cursor);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI Controls
        const sliderL = document.getElementById('sliderL');
        const sliderC = document.getElementById('sliderC');
        const sliderH = document.getElementById('sliderH');
        const valueL = document.getElementById('valueL');
        const valueC = document.getElementById('valueC');
        const valueH = document.getElementById('valueH');
        const colorPreview = document.getElementById('colorPreview');

        function updateColor() {
            const l = parseFloat(sliderL.value) / 100;
            const c = parseFloat(sliderC.value) / 100;
            const h = parseFloat(sliderH.value);

            valueL.textContent = (l * 100).toFixed(0) + '%';
            valueC.textContent = c.toFixed(2);
            valueH.textContent = h.toFixed(0) + '¬∞';

            const rgb = oklchToRgb(l, c, h);
            const hex = '#' + [rgb.r, rgb.g, rgb.b].map(v => {
                const h = Math.round(v * 255).toString(16);
                return h.length === 1 ? '0' + h : h;
            }).join('');

            colorPreview.style.background = hex;

            // Update cursor position in 3D space
            cursor.position.set(
                l - 0.5,
                (c / C_MAX) - 0.5,
                (h / 360) - 0.5
            );
        }

        sliderL.addEventListener('input', updateColor);
        sliderC.addEventListener('input', updateColor);
        sliderH.addEventListener('input', updateColor);

        // Start animation
        document.getElementById('loading').style.display = 'none';
        animate();
        updateColor();

        console.log('‚úÖ OKLCH 3D Model Ready!');
        console.log('üìä Generated ' + coordinates.length + ' vertices');
    </script>
</body>
</html>
