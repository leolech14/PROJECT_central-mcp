# Central-MCP: System Analysis and Refactoring Plan

**Generated by:** Gemini
**Date:** 2025-10-14

## 1. System Analysis & Beliefs

This document outlines the current understanding of the Central-MCP system based on an analysis of its file system, running processes, and source code.

### Belief 1: Core Architecture is a Monorepo
*   **Statement:** The project is a monorepo containing multiple, distinct but interconnected services and applications.
*   **Evidence:** Presence of multiple `package.json` files and top-level directories for `dashboard`, `central-mcp` (core logic), and `OKLCH-UI-SYSTEM`.
*   **Confidence Score:** **High**

### Belief 2: The System is a Multi-Process Architecture
*   **Statement:** The system is composed of at least two primary, separate services running on the VM:
    1.  **Core Backend (`photon-agent`):** A Node.js application built from the `src/` directory. Its "cloud" entry point (`index-cloud.ts`) runs a **WebSocket-only server** on port 3000, which communicates via the JSON-RPC protocol. It does not handle HTTP requests directly.
    2.  **Frontend (`nextjs-dashboard`):** A Next.js application in the `/dashboard` directory that provides the user interface and its own set of HTTP API routes.
*   **Evidence:** The `pm2 status` command shows two separate processes. The source code for `index-cloud.ts` and `WebSocketTransport.ts` confirms the backend is WebSocket-only. The `/dashboard` directory is a standard Next.js application.
*   **Confidence Score:** **High**

### Belief 3: Service Interconnection is via WebSocket
*   **Statement:** The frontend (`nextjs-dashboard`) communicates with the core backend (`photon-agent`) by acting as a WebSocket client, connecting to the `ws://localhost:3000/mcp` endpoint. The `photon-lite.cjs` HTTP server running on port 8080 is a separate component, likely a proxy, a secondary service, or a deprecated part of the system, but it is *not* the primary backend.
*   **Evidence:** The backend only exposes a WebSocket server. For the two running processes to communicate, the frontend must initiate the WebSocket connection.
*   **Confidence Score:** **High**

### Belief 4: Deployment is Automated and Multi-Platform
*   **Statement:** Production-like deployments on platforms like Railway or Heroku are automated. The process involves compiling the TypeScript source (`npm run build`) and running the cloud entry point (`dist/index.js`). Database migrations are also automatically run as part of the release cycle.
*   **Evidence:** The contents of `railway.json` and `Procfile`, which define build, start, and release commands.
*   **Confidence Score:** **High**

### Belief 5: State is Managed in a SQLite Database
*   **Statement:** The central state for tasks and agents is managed in a local SQLite database (`registry.db`). This database is accessed by the core backend and manipulated by the tools it exposes over its WebSocket API.
*   **Evidence:** The `TaskRegistry.js` class explicitly initializes a `better-sqlite3` database instance, which is then passed to the tools in `WebSocketTransport.ts`.
*   **Confidence Score:** **High**

---

## 2. The Robustness-Mega-Plan

### Executive Summary
The current Central-MCP project is a powerful and feature-rich prototype. However, its organizational structure and manual processes introduce significant risk, inefficiency, and fragility. This three-phase plan will address these core issues by introducing professional engineering practices for repository structure, automation, and infrastructure management.

### Phase 1: Repository Consolidation & Standardization (The Foundation)
**Objective:** To create a clean, predictable, and logically organized monorepo. This phase eliminates ambiguity and makes the system understandable and easier to work on.

1.  **Establish a Standard Monorepo Layout:**
    *   Create a top-level `packages/` directory.
    *   Move the primary applications (`dashboard`, the core backend from `src`, `OKLCH-UI-SYSTEM`) into their own subdirectories inside `packages/`.
2.  **Unify the Backend Service:**
    *   Formally deprecate and remove scattered, redundant server files (`photon-lite.cjs`, `server.js`, etc.).
    *   Establish the code in `packages/core-backend` as the single source of truth.
    *   Create a single, unified HTTP server within this package to serve both the WebSocket endpoint and any necessary HTTP routes (like health checks).
3.  **Centralize Scripts & Documentation:**
    *   Consolidate all build, deployment, and utility scripts into a single top-level `/scripts` directory.
    *   Relocate the extensive documentation into a top-level `/docs` directory, with a sub-folder structure that mirrors the new `packages/` layout.

### Phase 2: Build System & CI/CD Implementation (Automation & Quality)
**Objective:** To automate the entire build, test, and deployment lifecycle to dramatically increase development velocity and reduce human error.

1.  **Implement a Monorepo Build Tool:**
    *   Integrate **Turborepo** to manage the monorepo, enabling intelligent build/test caching.
2.  **Establish a CI/CD Pipeline:**
    *   Create a **GitHub Actions** workflow to automatically run linting, tests, and production builds on every pull request, preventing broken code from being merged.
3.  **Automate Deployments:**
    *   Extend the GitHub Actions workflow to automatically build and push Docker images and deploy them to the target environment on merges to the `main` branch.

### Phase 3: Infrastructure as Code (IaC) & Professional Hosting (Stability & Scalability)
**Objective:** To create a production-grade, reproducible, and scalable infrastructure foundation.

1.  **Define Infrastructure as Code:**
    *   Define all cloud resources (VM instances, firewall rules, networking) in code using **Terraform**. This makes the entire environment version-controlled, auditable, and reproducible.
2.  **Migrate to a Scalable Hosting Model:**
    *   Deploy the containerized services to **Google Cloud Run**, providing a fully managed, serverless environment with automatic scaling and zero-downtime deployments.
3.  **Implement Centralized Configuration and Secrets Management:**
    *   Migrate all secrets (API keys, database credentials) into **Google Secret Manager**.
    *   Applications will securely fetch secrets at runtime, ensuring they are never stored in the codebase.

---
This concludes the requested documentation.
